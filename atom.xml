<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>upbear</title>
  
  
  <link href="https://up-bear.github.io/atom.xml" rel="self"/>
  
  <link href="https://up-bear.github.io/"/>
  <updated>2024-01-01T03:41:49.298Z</updated>
  <id>https://up-bear.github.io/</id>
  
  <author>
    <name>upbear</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter学习笔记</title>
    <link href="https://up-bear.github.io/2024/01/01/flutter-xue-xi-bi-ji/"/>
    <id>https://up-bear.github.io/2024/01/01/flutter-xue-xi-bi-ji/</id>
    <published>2024-01-01T03:33:10.000Z</published>
    <updated>2024-01-01T03:41:49.298Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="打包APK"><a href="#打包APK" class="headerlink" title="打包APK"></a>打包APK</h1><h2 id="应用图标"><a href="#应用图标" class="headerlink" title="应用图标"></a>应用图标</h2><p>工具包：flutter_launcher_icons</p><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="attr">flutter_launcher_icons:</span> <span class="string">&quot;^0.13.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flutter_launcher_icons:</span></span><br><span class="line">  <span class="attr">android:</span> <span class="string">&quot;launcher_icon&quot;</span></span><br><span class="line">  <span class="comment"># ios平台开启</span></span><br><span class="line">  <span class="attr">ios:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 图标位置</span></span><br><span class="line">  <span class="attr">image_path:</span> <span class="string">&quot;assets/icon/icon.png&quot;</span></span><br><span class="line">  <span class="attr">min_sdk_android:</span> <span class="number">21</span> <span class="comment"># android min sdk min:16, default 21</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">generate:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">image_path:</span> <span class="string">&quot;path/to/image.png&quot;</span></span><br><span class="line">    <span class="attr">background_color:</span> <span class="string">&quot;#hexcode&quot;</span></span><br><span class="line">    <span class="attr">theme_color:</span> <span class="string">&quot;#hexcode&quot;</span></span><br><span class="line">  <span class="attr">windows:</span></span><br><span class="line">    <span class="attr">generate:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">image_path:</span> <span class="string">&quot;path/to/image.png&quot;</span></span><br><span class="line">    <span class="attr">icon_size:</span> <span class="number">48</span> <span class="comment"># min:48, max:256, default: 48</span></span><br><span class="line">  <span class="attr">macos:</span></span><br><span class="line">    <span class="attr">generate:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">image_path:</span> <span class="string">&quot;path/to/image.png&quot;</span></span><br></pre></td></tr></table></figure><p>运行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter pub get</span><br><span class="line">flutter pub run flutter_launcher_icons</span><br></pre></td></tr></table></figure><h2 id="build-APK"><a href="#build-APK" class="headerlink" title="build APK"></a>build APK</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --debug</span><br><span class="line">flutter build apk --release</span><br><span class="line"><span class="comment"># 打包中忽略 IconData的优化问题</span></span><br><span class="line">flutter build apk --release --no-tree-shake-icons</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MallChat笔记</title>
    <link href="https://up-bear.github.io/2023/12/31/mallchat-bi-ji/"/>
    <id>https://up-bear.github.io/2023/12/31/mallchat-bi-ji/</id>
    <published>2023-12-31T06:10:00.000Z</published>
    <updated>2023-12-31T06:58:39.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="微信登录"><a href="#微信登录" class="headerlink" title="微信登录"></a>微信登录</h1><h2 id="扫公众号事件码-授权"><a href="#扫公众号事件码-授权" class="headerlink" title="扫公众号事件码 + 授权"></a>扫公众号事件码 + 授权</h2><p>用户扫描二维码，关注公共号后，后端会获取到用户的 openid 和 事件码<br>如果后端不需要其他用户信息，则可以直接登录。<br>需要获取用户头像等信息，则公共号向用户推送授权链接，用户点击授权完成</p><p><strong>缺点</strong><br>获取用户授权的接口2022年7月就关停了，现在只有微信认证才能访问，难度比较大。<br>那普通的公众号有没有办法做扫码登录呢？见下面</p><h2 id="扫公众号获取事件码-网站填写事件码"><a href="#扫公众号获取事件码-网站填写事件码" class="headerlink" title="扫公众号获取事件码 + 网站填写事件码"></a>扫公众号获取事件码 + 网站填写事件码</h2><p>用户扫码关注公共号后，公众号推送一个事件码，用户再网页填写该事件码</p><p><strong>缺点</strong></p><p>事件码容易被暴力撞库，因此要设计复杂，且有时间限制</p><h2 id="网站展示事件码-公众号填写事件码"><a href="#网站展示事件码-公众号填写事件码" class="headerlink" title="网站展示事件码 + 公众号填写事件码"></a>网站展示事件码 + 公众号填写事件码</h2><p>用户扫码后，在公共号填写事件码，然后公共号向后端推送用户信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图书馆</title>
    <link href="https://up-bear.github.io/2023/02/25/tu-shu-guan/"/>
    <id>https://up-bear.github.io/2023/02/25/tu-shu-guan/</id>
    <published>2023-02-25T12:17:43.000Z</published>
    <updated>2023-02-25T14:39:21.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h1><ol><li>博主：SharpCJ’s blog。篇名：SpringIOC 二—— 容器 和 Bean的深入理解</li></ol><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><ol><li>博主：SharpCJ’s blog。篇名：Spring AOP——Spring 中面向切面编程 。<a class="link"   href="https://www.cnblogs.com/joy99/p/10941543.html" >https://www.cnblogs.com/joy99/p/10941543.html<i class="fas fa-external-link-alt"></i></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记</title>
    <link href="https://up-bear.github.io/2022/11/04/leetcode-shua-ti-bi-ji/"/>
    <id>https://up-bear.github.io/2022/11/04/leetcode-shua-ti-bi-ji/</id>
    <published>2022-11-04T03:32:03.000Z</published>
    <updated>2023-02-24T09:12:12.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="优先队列、最大-小堆"><a href="#优先队列、最大-小堆" class="headerlink" title="优先队列、最大/小堆"></a>优先队列、最大/小堆</h2><p>优先队列：<br>优先队列是一种概念，而不是一种具体的数据结构。</p><p>满足以下条件的数据结构都可以叫优先队列：</p><ol><li>可以快速插入新元素</li><li>可以快速取出所有元素的最值</li></ol><p>使用最大堆可以实现最大优先队列，使用最小堆实现最小优先队列</p><p>最大堆和最小堆都是完全二叉树！</p><p>最大堆：父节点大于所有子孙节点<br>最小堆：父节点小于所有子孙节点</p><p><img src="/./leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/001.png" alt="img 001"></p><p>上图所示为一个最小堆。</p><p>堆的插入：</p><p><img src="/./leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/002.png" alt="img 002"></p><p>取出最值：根节点即为最值。</p><p>删除最值：首先将堆的最后一个节点复制到根节点（最值删除），并删除最后一个节点，然后将根节点不断向下调整，直至满足最大/小堆的定义。</p><p><img src="/./leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/003.png" alt="img 003"></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a class="link"   href="https://blog.csdn.net/qq_35500719/article/details/127142965" >https://blog.csdn.net/qq_35500719/article/details/127142965<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/ACM_hades/article/details/89671679" >https://blog.csdn.net/ACM_hades/article/details/89671679<i class="fas fa-external-link-alt"></i></a></li></ol><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><ol><li>队列中元素其对应在<strong>原来序列中的顺序必须是单调递增的</strong></li><li>队列中元素的大小必须是<strong>单调递(增/减/自定义)</strong></li></ol><h3 id="适用问题"><a href="#适用问题" class="headerlink" title="适用问题"></a>适用问题</h3><ol><li>RMQ</li></ol><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a class="link"   href="https://blog.csdn.net/LJD201724114126/article/details/80663855" >https://blog.csdn.net/LJD201724114126/article/details/80663855<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/I-Love-You-520/p/13454305.html" >https://www.cnblogs.com/I-Love-You-520/p/13454305.html<i class="fas fa-external-link-alt"></i></a></li></ol><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h1 id="经典方法"><a href="#经典方法" class="headerlink" title="经典方法"></a>经典方法</h1><h2 id="DP动态规划"><a href="#DP动态规划" class="headerlink" title="DP动态规划"></a>DP动态规划</h2><h2 id="未解题目"><a href="#未解题目" class="headerlink" title="未解题目"></a>未解题目</h2><ol><li>LCP 64 二叉树灯饰</li><li>LCP 34 二叉树染色</li></ol><h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><h2 id="RMQ区间最值问题"><a href="#RMQ区间最值问题" class="headerlink" title="RMQ区间最值问题"></a>RMQ区间最值问题</h2><p><strong>Range Minimum/Maximum Query</strong></p><p>LeetCode 239. 滑动窗口最大值<br>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line"></span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"> </span><br><span class="line">示例2：</span><br><span class="line">输入：nums = [1], k = 1</span><br><span class="line"></span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>优先队列（堆）</strong><br>可以使用优先队列（最大堆）。为了保证滑动窗口的合法性，以二元数组（index，nums[index]）的形式进行入队。二元数组的作用会在代码中用注释标识出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b[<span class="number">1</span>]-a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, m = n - k + <span class="number">1</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            q.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, nums[i]&#125;);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//循环条件中的 i-k 正是当前位置 i 为右端点的窗口左界限，&lt;i-k 说明该值滑出窗口 </span></span><br><span class="line">                <span class="keyword">while</span> (q.peek()[<span class="number">0</span>] &lt;= i - k) q.poll();</span><br><span class="line">                ans[idx++] = q.peek()[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单调队列</strong><br>关于 RMQ 的另外一个优秀做法通常是使用「单调队列/单调栈」。</p><p>随着窗口的不断平移，该过程会一直发生。若同一时刻存在两个数  和 （）所在一个窗口内，下标更大的数会被更晚移出窗口，此时如果有  的话，可以完全确定  将不会成为后续任何一个窗口的最大值，此时可以将必然不会是答案的  从候选中进行移除。</p><p>不难发现，当我们将所有必然不可能作为答案的元素（即所有满足的小于等于  ）移除后，候选集合满足「单调递减」特性，即集合首位元素为当前窗口中的最大值（为了满足窗口长度为  的要求，在从集合头部取答案时需要先将下标小于的等于的  的元素移除）。</p><p>为方便从尾部添加元素，从头部获取答案，我们可使用「双端队列」存储所有候选元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, m = n - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; nums[d.peekLast()] &lt;= nums[i]) d.pollLast();</span><br><span class="line">            d.addLast(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; d.peekFirst() &lt;= i - k) d.pollFirst();</span><br><span class="line">                ans[i - k + <span class="number">1</span>] = nums[d.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果 num[i] 比队列末尾小，则 num[i] 仍能入队，因为有可能成为窗口的最大值。<br>第二个 while 循环，为了保证宽距为 k 窗口的合法性，清除已滑出窗口的元素<br>ans[i - k + 1] = nums[d.peekFirst()] 清除不合法元素后，队列的首元素即为以当前 i 为窗口右边界的窗口最大值</p></blockquote><h3 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a class="link"   href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247493262&amp;idx=1&amp;sn=2d8e192a5767b49b9a13a6192ab3b833" >https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247493262&amp;idx=1&amp;sn=2d8e192a5767b49b9a13a6192ab3b833<i class="fas fa-external-link-alt"></i></a></li></ol><p>再手写的话今天两道题的任务就G了，偷懒一下。。。</p><h1 id="1668-最大重复子字符串"><a href="#1668-最大重复子字符串" class="headerlink" title="1668.最大重复子字符串"></a>1668.最大重复子字符串</h1><p>给你一个字符串 sequence ，如果字符串 word 连续重复 k 次形成的字符串是 sequence 的一个子字符串，那么单词 word 的 重复值为 k 。单词 word 的 最大重复值 是单词 word 在 sequence 中最大的重复值。如果 word 不是 sequence 的子串，那么重复值 k 为 0 。</p><h2 id="方法1：简单枚举-动态规划"><a href="#方法1：简单枚举-动态规划" class="headerlink" title="方法1：简单枚举+动态规划"></a>方法1：简单枚举+动态规划</h2><p>巧妙思路：巧妙利用了状态方程：f[i] = f[i-word.length]+1，数组<code>f</code>的元素值只与前面间隔<code>word.length</code>的元素有关（题目要求是连续重复的子字符串），最后数组<code>f</code>中的最大值即为最大重复值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRepeating</span><span class="params">(String sequence, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sequence.length(), m = word.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sequence.charAt(i - m + j + <span class="number">1</span>) != word.charAt(j)) &#123;</span><br><span class="line">                    valid = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                f[i] = (i == m - <span class="number">1</span> ? <span class="number">0</span> : f[i - m]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(f).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="剑指Offer-047-二叉树剪枝"><a href="#剑指Offer-047-二叉树剪枝" class="headerlink" title="剑指Offer || 047.二叉树剪枝"></a>剑指Offer || 047.二叉树剪枝</h1><p>给定一个二叉树 根节点 root ，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树（所属节点值和为0的子树）。<br>节点 node 的子树为 node 本身，以及所有 node 的后代。</p><h2 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h2><p>从树的底部向上开始剪枝，采用<strong>后序遍历</strong>的方式遍历二叉树，先判断左右子树为非零子树后，再判断整棵树是否为非零树。<br>如果左或右子树为零树，则将其赋值为<code>null</code>，完成剪枝动作。</p><p>判断子树是否为零树方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeSum</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    v1 = node.left != <span class="keyword">null</span> ? ((node.left.val + treeSum(node.left)) &gt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line">    v2 = node.right != <span class="keyword">null</span> ? ((node.right.val + treeSum(node.right)) &gt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (node.val + v1 + v2) &gt;=<span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 方法：递归遍历二叉树，遍历方式采用后序遍历</span></span><br><span class="line"><span class="comment">         * 思路：每一子树综合值为‘1’或者‘0’,如果根节点及两个子树值都为‘0‘，则删除该根节点及其子树</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v1, v2;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            pruneTree(root.left);</span><br><span class="line">            v1 = treeSum(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pruneTree(root.right);</span><br><span class="line">            v2 = treeSum(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v1 == <span class="number">0</span>)</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(v2 == <span class="number">0</span>)</span><br><span class="line">            root.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((root.val + v1 + v2) == <span class="number">0</span>)</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeSum</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v1, v2;</span><br><span class="line"></span><br><span class="line">        v1 = node.left != <span class="keyword">null</span> ? ((node.left.val + treeSum(node.left)) &gt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line">        v2 = node.right != <span class="keyword">null</span> ? ((node.right.val + treeSum(node.right)) &gt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (node.val + v1 + v2) &gt;=<span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="改进完善"><a href="#改进完善" class="headerlink" title="改进完善"></a>改进完善</h3><p>问题：当前判断子树是否为零树的方法<code>treeSum</code>，由于我们是从下到上去剪枝，会产生子树重复判断的问题。<br>假定一个树有3层，且子树都是非零树，当剪枝操作进行到第2层，调用方法<code>treeSum</code>判断第2层子树时，第3层子树便重复判断了一次。</p><p>改进：使用空间换时间的思想，用一种数据结构记录当前子树所有节点值之和（或者用布尔变量表示是否为零树），当判断一棵二叉树的子树时，只需到<code>对应的子树根节点</code>去判断即可。（该子树之前已经被判断过）</p><h2 id="方法1：递归"><a href="#方法1：递归" class="headerlink" title="方法1：递归"></a>方法1：递归</h2><p>树相关的题目首先考虑用递归解决。首先确定边界条件，当输入为空时，即可返回空。然后对左子树和右子树分别递归进行 pruneTree 操作。递归完成后，当这三个条件：左子树为空，右子树为空，当前节点的值为 0，同时满足时，才表示以当前节点为根的原二叉树的所有节点都为 0，需要将这棵子树移除，返回空。有任一条件不满足时，当前节点不应该移除，返回当前节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路对比"><a href="#思路对比" class="headerlink" title="思路对比"></a>思路对比</h2><p>看了官方的解题思路后，感觉是我递归了，但没有完全递归。。。<br>官方递归代码之简洁，显得我自己的代码很sb。<br>说明我有巨大的进步空间。</p><h1 id="795-区间子数组个数"><a href="#795-区间子数组个数" class="headerlink" title="795.区间子数组个数"></a>795.区间子数组个数</h1><h2 id="失败思路"><a href="#失败思路" class="headerlink" title="失败思路"></a>失败思路</h2><p>二级循环。</p><p>失败原因：时间复杂度高，接近O(n平方)。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路1</span></span><br><span class="line"><span class="comment">         * 双指针法：时间复杂度接近二级循环</span></span><br><span class="line"><span class="comment">         * 问题：耗时久，时间复杂度高</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length)&#123;</span><br><span class="line">            j = i;</span><br><span class="line">            max = nums[j];</span><br><span class="line">            <span class="keyword">while</span> (j &lt; nums.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; max)</span><br><span class="line">                    max = nums[j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(max &lt; left)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(max &gt;= left &amp;&amp; max &lt;= right)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法1：一次遍历"><a href="#方法1：一次遍历" class="headerlink" title="方法1：一次遍历"></a>方法1：一次遍历</h2><p>一个子数组的最大值范围在 [left,right] 表示子数组中不能含有大于 right 的元素，且至少含有一个处于 [left,right] 区间的元素。</p><p>我们可以将数组中的元素分为三类，并分别用 0, 1, 2 来表示：</p><ul><li>小于 left，用 0 表示；</li><li>大于等于 left 且小于等于 right，用 1 表示；</li><li>大于 right，用 2 表示。</li></ul><p>那么本题可以转换为求解不包含 2，且至少包含一个 1 的子数组数目。我们遍历 i，并将右端点固定在 i，求解有多少合法的子区间。过程中需要维护两个变量：</p><ol><li>last1，表示上一次 1 出现的位置，如果不存在则为 -1</li><li>last2，表示上一次 2 出现的位置，如果不存在则为 -1</li></ol><p>如果 last !=−1，那么子数组若以 i 为右端点，合法的左端点可以落在 (last2，last1] 之间。这样的左端点共有 last1−last2 个。</p><p>因此，我们遍历 i ：</p><ol><li>如果 left &lt;= nums[i] &lt;= right，则令 last1 = i</li><li>如果 nums[i] &gt; right，令 last2 = i，last1 = -1</li></ol><p>如果 last != -1，则将 last1 - last2 累加到结果中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, last1 = -<span class="number">1</span>, last2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= left &amp;&amp; nums[i] &lt;= right)&#123;</span><br><span class="line">                last1 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; right)&#123;</span><br><span class="line">                last2 = i;</span><br><span class="line">                last1 = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(last1 != -<span class="number">1</span>)&#123;</span><br><span class="line">                res += last1 - last2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解思考"><a href="#题解思考" class="headerlink" title="题解思考"></a>题解思考</h3><p>该方法为什么只需要一次遍历？<br>因为使用了两个变量<code>last1</code>和<code>last2</code>记录上一次<code>1</code>和<code>2</code>出现的位置，然后通过<code>last1 - last2</code>来计算子数组的数量，代替了第二次遍历。</p><p>为什么能代替第二次遍历呢？<br>该方法再<code>i</code>的遍历中，将当前<code>i</code>所在位置作为<code>子数组的右端点</code>，而<code>子数组的左端点</code>的数量由<code>last1 - last2</code>计算。</p><p>这里着重说明一下两个变量的更新规则和累加规则：</p><ul><li>last1 在<code>nums[i] &lt; left</code>时是不更新的，因为这时的 nums[i] 只能作为右端点和前面的元素组成子数组，自己本身是不能作为左端点的！</li><li>累加操作，只有在 last1 != -1 时进行，因为要在<code>last1 - last2</code>中选择左端点！</li></ul><p>该类似双指针，一开始我认为我的失败代码是双指针，简直笑死，算是真假李逵了。</p><h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h1><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p><h2 id="个人思路-1"><a href="#个人思路-1" class="headerlink" title="个人思路"></a>个人思路</h2><p>将 int 型的<strong>最大值或最小值</strong>装入数组 ms 中（不包括符号），同时将 <strong>x</strong> 也反转装入数组 xs 中（位数不够时前面补零）。<br>最终输出结果时，将 xs 和 ms 对位比较，通过一个 int 变量 s，判断反转后的 x是否会超出界限</p><ul><li>s 初始值 = 1</li><li>如果 xs[i] &lt; ms[i]，s = s*0</li><li>如果 xs[i] == ms[i]，s = s*1</li><li>如果 xs[i] &gt; ms[i]，s = s*2；</li></ul><p>对位比较结束时，如果 s &lt;= 1，则反转后的 <strong>x</strong> 不超出界限，否则返回0。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 首先获取符号 +/-</span></span><br><span class="line"><span class="comment">         * 将int型的 Max 和 Min存入最值数组中</span></span><br><span class="line"><span class="comment">         * 将x也补零倒叙装入数组中</span></span><br><span class="line"><span class="comment">         * 通过两个数组进行比较</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ms;</span><br><span class="line">        <span class="keyword">int</span>[] xs;</span><br><span class="line">        <span class="keyword">if</span>( x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            len = String.valueOf(Integer.MAX_VALUE).length();</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            m = Integer.MAX_VALUE;</span><br><span class="line">            ms = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            xs = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            len = String.valueOf(Integer.MIN_VALUE).length()-<span class="number">1</span>;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">            m = Integer.MIN_VALUE;</span><br><span class="line">            ms = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            xs = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ms[len - <span class="number">1</span> - i] = flag * (m % <span class="number">10</span>);</span><br><span class="line">            m = m / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;  <span class="comment">//如果对位ys[i] &lt; ms[i]，s = s*0；如果对位等于，s = s*1；如果对位大于，s = s*2；</span></span><br><span class="line">        <span class="keyword">int</span> lenX = flag &gt; <span class="number">0</span> ? String.valueOf(x).length() : String.valueOf(x).length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; len - lenX)&#123;</span><br><span class="line">                xs[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                xs[i] = flag * (x % <span class="number">10</span>);</span><br><span class="line">                x = x / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xs[i] &lt; ms[i]) &#123;</span><br><span class="line">                    s = s * <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xs[i] == ms[i])&#123;</span><br><span class="line">                    s = s * <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    s = s * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            y = y*<span class="number">10</span> + xs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> flag * y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><p>解答成功:<br>    执行耗时:1 ms,击败了43.24% 的Java用户<br>    内存消耗:39 MB,击败了35.08% 的Java用户</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>负数对10求余，结果为负数！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = -123;</span><br><span class="line">int y = x % 10;</span><br><span class="line"></span><br><span class="line">输出：y = -3</span><br></pre></td></tr></table></figure><h1 id="剑指Offer-55-II-平衡二叉树"><a href="#剑指Offer-55-II-平衡二叉树" class="headerlink" title="剑指Offer 55 - II.平衡二叉树"></a>剑指Offer 55 - II.平衡二叉树</h1><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><h2 id="个人思路-2"><a href="#个人思路-2" class="headerlink" title="个人思路"></a>个人思路</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 前序遍历</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ld = countDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rd = countDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Math.abs(ld-rd) &gt; <span class="number">1</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>) &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDepth</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(countDepth(node.left), countDepth(node.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意后面还要判断左右子树是否为平衡树</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + Math.max(countDepth(node.left), countDepth(node.right));</span><br></pre></td></tr></table></figure><h1 id="剑指Offer-07-重建二叉树"><a href="#剑指Offer-07-重建二叉树" class="headerlink" title="剑指Offer 07.重建二叉树"></a>剑指Offer 07.重建二叉树</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。<br>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><h2 id="个人思路-3"><a href="#个人思路-3" class="headerlink" title="个人思路"></a>个人思路</h2><p>记录下思路加深记忆。</p><p>前序数组：pre = {3,9,20,15,7}<br>中序数组：in = {9,3,15,20,7}</p><p>每次重建一个节点需要以下参数：</p><ul><li>pre：前序数组</li><li>i1：前序数组中<strong>树节点范围</strong>开始下标</li><li>i2：前序数组中<strong>树节点范围</strong>末尾下标</li><li>in：中序数组</li><li>j1：中序数组<strong>树节点范围</strong>开始下标</li><li>j2：中序数组<strong>树节点范围</strong>末尾下标</li></ul><blockquote><p><strong>树节点范围</strong>指的是当前所重建节点及其所有子孙节点</p></blockquote><p>重建节点所需步骤：</p><ol><li>**pre[i1]**肯定为重建的根节点值</li><li><strong>in</strong>数组中和<strong>pre[i1]<strong>值相同的下标设为</strong>j</strong></li><li>**in[j]**左边为重建根节点左子树的所有节点，右边为重建根节点右子树的所有节点</li><li>重复以上操作重建根节点的左右子节点</li></ol><p>终止条件：</p><ol><li>i1 &gt; i2：重建所需节点数量为空，返回<strong>null</strong></li><li>i1 = i2：重建只需一个节点，则不需要再递归重建其左右子节点，直接返回该重建节点</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="keyword">null</span> ||preorder.length == <span class="number">0</span> || inorder == <span class="keyword">null</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length-<span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span>[] in, <span class="keyword">int</span> j1, <span class="keyword">int</span> j2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i1 &gt; i2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(pre[i1]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i1 == i2)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = j1;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt;= j2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j] == pre[i1])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = build(pre, i1+<span class="number">1</span>, i1+j-j1, in, j1, j-<span class="number">1</span>);</span><br><span class="line">        node.right = build(pre, i1+j-j1+<span class="number">1</span>, i2, in, j+<span class="number">1</span>, j2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1110-删点成林"><a href="#1110-删点成林" class="headerlink" title="1110.删点成林"></a>1110.删点成林</h1><p>给出二叉树的根节点 root，树上每个节点都有一个不同的值。<br>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。<br>返回森林中的每棵树。你可以按任意顺序组织答案。</p><h2 id="个人思路-4"><a href="#个人思路-4" class="headerlink" title="个人思路"></a>个人思路</h2><p>首先，判断一个节点是普通节点还是待删节点：</p><ul><li>普通节点：继续判断左右子节点，递归</li><li>待删节点：将该节点赋值为<code>null</code>，并对待删节点执行<strong>删除操作shear</strong><ul><li>将待删节点置为<code>null</code>需要借助其父节点，因为Java中的引用传递实质上也是值传递，只不过传递的是对象存储地址，因此在普通节点的递归函数<code>iterator</code>含有一个父节点参数！</li><li>删除操作shear：首先尝试从<code>list</code>中移除待删节点（因为后面会将待删节点左右子节点放入<code>list</code>中，如果后面递归中发现其子节点也是待删节点，则需从链表中移除！删除失败也无关紧要嘛），然后将其非空子节点放入链表中。</li></ul></li></ul><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">delNodes</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] to_delete)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : to_delete)&#123;</span><br><span class="line">            set.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode n0 = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        n0.left = root;</span><br><span class="line">        list.add(root);</span><br><span class="line">        iterator(n0, root, set);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否要删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIn</span><span class="params">(<span class="keyword">int</span> val, Set&lt;Integer&gt; set)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> set.contains(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(TreeNode root, TreeNode node, Set&lt;Integer&gt; set)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isIn(node.val, set))&#123;</span><br><span class="line">            shear(node, set);</span><br><span class="line">            <span class="keyword">if</span>(root.left == node)</span><br><span class="line">                root.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            iterator(node, node.left, set);</span><br><span class="line">            iterator(node, node.right, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shear</span><span class="params">(TreeNode root, Set&lt;Integer&gt; set)</span></span>&#123;</span><br><span class="line">        list.remove(root);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(root.left);</span><br><span class="line">            iterator(root, root.left, set);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(root.right);</span><br><span class="line">            iterator(root, root.right, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不足之处-1"><a href="#不足之处-1" class="headerlink" title="不足之处"></a>不足之处</h3><p>方法运行耗时和内存消耗不理想（leetcode打败几%的用户），我的方法也只对二叉树做一次遍历啊，复杂度应该是<code>O(n)</code>啊，暂时没想通为什么。</p><h2 id="labuladong"><a href="#labuladong" class="headerlink" title="labuladong"></a>labuladong</h2><p>关键在于理解到<strong>一个节点不是待删节点，且没有父节点，则是一棵新树</strong><br>其他细节：</p><ul><li>利用递归函数<code>doDelete</code>的返回值来完成节点的删除操作，即<strong>分解问题</strong>的思路</li><li>使用布尔变量<code>hasParent</code>传递节点是否有父节点这一信息</li></ul><p>这就是刷题二十年的功力，妙啊！</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; delSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">delNodes</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d : to_delete)&#123;</span><br><span class="line">            delSet.add(d);</span><br><span class="line">        &#125;</span><br><span class="line">        doDelete(root, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">doDelete</span><span class="params">(TreeNode root, <span class="keyword">boolean</span> hasParent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> deleted = delSet.contains(root.val);</span><br><span class="line">        <span class="keyword">if</span>(!deleted &amp;&amp; !hasParent)&#123;</span><br><span class="line">            res.add(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = doDelete(root.left, !deleted);</span><br><span class="line">        root.right = doDelete(root.right, !deleted);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deleted ? <span class="keyword">null</span> : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h1><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><h2 id="个人思路-5"><a href="#个人思路-5" class="headerlink" title="个人思路"></a>个人思路</h2><p>对每个结点进行的操作：</p><ul><li>将左右字节点连接</li><li>将本节点的右子节点和<strong>右边兄弟节点</strong>的左子节点连接</li></ul><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果节点1的左右节点都不为 null，则将左子节点与右子节点连接</span></span><br><span class="line">        <span class="comment">//然后判断节点1是否有右侧节点，如果有，则将节点1的右子节点和节点2的右子节点进行连接</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)</span><br><span class="line">            root.left.next  = root.right;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span> &amp;&amp; root.next != <span class="keyword">null</span>)</span><br><span class="line">            root.right.next = root.next.left;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="labuladong-1"><a href="#labuladong-1" class="headerlink" title="labuladong"></a>labuladong</h2><p>将此题目中的二叉树看作一个三叉树，<strong>连接左右节点</strong>整体看作第三个节点（从代码的递归函数形式看勉强算吧，感觉这个抽象不是很有意义）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 遍历「三叉树」，连接相邻节点</span></span><br><span class="line">    traverse(root.left, root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node node1, Node node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">    <span class="comment">// 将传入的两个节点穿起来</span></span><br><span class="line">    node1.next = node2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接相同父节点的两个子节点</span></span><br><span class="line">    traverse(node1.left, node1.right);</span><br><span class="line">    traverse(node2.left, node2.right);</span><br><span class="line">    <span class="comment">// 连接跨越父节点的两个子节点</span></span><br><span class="line">    traverse(node1.right, node2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.二叉树展开为链表</h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li><li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li></ul><h2 id="个人思路-6"><a href="#个人思路-6" class="headerlink" title="个人思路"></a>个人思路</h2><p>采用分解问题的思路</p><p>每个节点进行的操作：</p><ul><li>返回当前子树的<strong>最右端节点</strong></li><li>将左子树迁移到子树的右边</li><li>将右子树迁移到<strong>最右端节点</strong>下面</li></ul><p>代码的复杂之处就在于<strong>如何找到并返回最右端节点</strong>，相比之下<strong>labuladong</strong>的思路就要巧妙很多，代码也简洁易懂</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每个子树根节点操作如下：</span></span><br><span class="line">        <span class="comment">// 1.TreeNode node = root.right</span></span><br><span class="line">        <span class="comment">// root.right = root.left</span></span><br><span class="line">        <span class="comment">// root.left = null</span></span><br><span class="line">        <span class="comment">// 2.返回最右端的节点 root_maxRight</span></span><br><span class="line">        <span class="comment">// root_maxRight.right = node</span></span><br><span class="line">        <span class="comment">// 关键！！！</span></span><br><span class="line">        <span class="comment">// 如果返回子树的最优端节点</span></span><br><span class="line"></span><br><span class="line">        change(root, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">change</span><span class="params">(TreeNode root, TreeNode parent)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode tempLeft = root.left;</span><br><span class="line">        TreeNode tempRight = root.right;</span><br><span class="line">        <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.right = root;</span><br><span class="line">            parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode leftParent = change(tempLeft, root);</span><br><span class="line">        TreeNode rightParent = <span class="keyword">null</span>;    </span><br><span class="line">        <span class="keyword">if</span>(leftParent != <span class="keyword">null</span>)</span><br><span class="line">            rightParent = change(tempRight, leftParent);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rightParent = change(root.right, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rightParent != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> rightParent;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftParent != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> leftParent;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="labuladong-2"><a href="#labuladong-2" class="headerlink" title="labuladong"></a>labuladong</h2><p>思路的巧妙之处在于：在后序位置利用了前面已经被递归处理的节点肯定是<strong>链式连接</strong>的，使用一个简单的循环就可以找出<strong>右子树需要连接的头节点</strong>，也即<strong>最右端节点</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：将以 root 为根的树拉平为链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用定义，把左右子树拉平</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**** 后序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">// 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    TreeNode right = root.right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、将左子树作为右子树</span></span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    root.right = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将原先的右子树接到当前右子树的末端</span></span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    p.right = right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p><strong>labuladong</strong>的代码胜在思路简单，代码优雅。但是我的代码在<strong>寻找最右端节点</strong>上不需要遍历之前已经处理过的节点，时间复杂度上应该会小胜一筹。嘻嘻。</p><h1 id="1372-二叉树中的最长交错路径"><a href="#1372-二叉树中的最长交错路径" class="headerlink" title="1372.二叉树中的最长交错路径"></a>1372.二叉树中的最长交错路径</h1><p>给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：</p><ul><li>选择二叉树中 任意 节点和一个方向（左或者右）</li><li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点</li><li>改变前进方向：左变右或者右变左</li><li>重复第二步和第三步，直到你在树中无法继续移动</li><li>交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）</li></ul><p>请你返回给定树中最长 交错路径 的长度。</p><h2 id="个人思路-7"><a href="#个人思路-7" class="headerlink" title="个人思路"></a>个人思路</h2><p>题目的注意点：节点的走向必须左右交替进行</p><p>采用遍历二叉树思路</p><p>每个节点需要做的事情：</p><ul><li>接替父节点的路径，方向交替的走向其子节点（如果父节点选择左方向，则该节点应选右方向走向其右子节点），路径长度加一</li><li>开辟一个新的路径，作为起始节点。选择与父节点相同的方向走向子节点，路径长度置零</li><li>更新最大路径长度</li></ul><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            traverse(root.left, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            traverse(root.right, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 路径长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> direction 0:左， 1：右</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> length, <span class="keyword">int</span> direction)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(length+<span class="number">1</span> &gt; max)</span><br><span class="line">            max = length+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(direction == <span class="number">0</span>) &#123;</span><br><span class="line">            traverse(root.left, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            traverse(root.right, length + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            traverse(root.left, length+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            traverse(root.right, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1696-跳跃游戏-VI"><a href="#1696-跳跃游戏-VI" class="headerlink" title="1696.跳跃游戏 VI"></a>1696.跳跃游戏 VI</h1><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。</p><p>一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。</p><p>你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。</p><p>请你返回你能得到的 最大得分 。</p><h2 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h2><p>思路如下：题目限制每次最大跳<code>K</code>步，且首尾已经限制，追求跳跃总和最大。每次在接下来的<code>K</code>个元素中<strong>顺序寻找第一个正数</strong>，加入到总和中；如果<code>K</code>个元素全为负则寻找<strong>最大的负数</strong>加入到总和中。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case: i=0, return nums[0],即f(0) = nums[0]</span></span><br><span class="line">        <span class="comment">//状态转移方程: f(n) = max&#123;f(n-m), m = 1,...,k&#125; + nums[n]</span></span><br><span class="line">        <span class="comment">//有两种写法：1. 从nums[n-1]倒着计算</span></span><br><span class="line">        <span class="comment">//          2. 从nums[0]顺着计算</span></span><br><span class="line">        <span class="keyword">return</span> dp(nums, k, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-<span class="number">1</span>-j &gt;= <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>-j] &gt; max)&#123;</span><br><span class="line">                max = nums[i-<span class="number">1</span>-j];</span><br><span class="line">                maxIndex = i-<span class="number">1</span>-j;</span><br><span class="line">                <span class="keyword">if</span>(max &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[i] + dp(nums, k, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><p>如果测试数据中出现一长段连续负数，<code>-1, -100, -100, -100, 1</code>，假设<code>K=3</code>此时按照思路会依次选择<code>-1, -100, 1</code>，但是实际上应该选择<code>-100, 1</code>。证明思路有问题！！！</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>这题也是用<strong>动态规划</strong>思路去解的，但是在解题的过程中太过注重问题细节，反观<strong>labuladong</strong>的题解，会发现<strong>动态规划类型问题</strong>的关键在于明确<strong>状态转移方程</strong>、如何定义<strong>dp函数/数组</strong>、怎么做<strong>选择</strong>，不用去过分关注解题的每一步是怎么进行，这些<strong>动态规划框架</strong>会帮你完成！！！</p><h2 id="labuladong-3"><a href="#labuladong-3" class="headerlink" title="labuladong"></a>labuladong</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步，暴力递归解法（超时）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">return</span> dp(nums, n - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：到达 nums[p] 所能获得的最大分数是 dp(nums, p)</span></span><br><span class="line">    <span class="comment">// 能跳到 nums[p]，必然是从 nums[p-k..p-1] 中的某个位置跳来的</span></span><br><span class="line">    <span class="comment">// 故状态转移方程为：dp[p] = max(nums[p-k..p-1]) + nums[p]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现状态转移方程</span></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp(nums, p - i, k));</span><br><span class="line">        &#125;</span><br><span class="line">        res += nums[p];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，带备忘录的递归解法（超时）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 备忘录初始化为最小值</span></span><br><span class="line">        Arrays.fill(memo, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">return</span> dp(nums, n - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：到达 nums[p] 所能获得的最大分数是 dp(nums, p)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查备忘录，避免冗余计算</span></span><br><span class="line">        <span class="keyword">if</span> (memo[p] != Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现状态转移方程，结果存入备忘录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            memo[p] = Math.max(memo[p], dp(nums, p - i, k));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[p] += nums[p];</span><br><span class="line">        <span class="keyword">return</span> memo[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步，自顶向下的递归改为自底向上的迭代解法（超时）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 定义：到达 nums[p] 的最大分数为 dp[p]</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// dp 数组初始化为最小值</span></span><br><span class="line">        Arrays.fill(dp, Integer.MIN_VALUE);</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; n; p++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p - i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[p] = Math.max(dp[p], dp[p - i]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[p] += nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四步，利用单调队列结构消除内层循环（通过）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        MonotonicQueue&lt;Integer&gt; window = <span class="keyword">new</span> MonotonicQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 定义：到达 nums[p] 的最大分数为 dp[p]</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// dp 数组初始化为最小值</span></span><br><span class="line">        Arrays.fill(dp, Integer.MIN_VALUE);</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        window.push(dp[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; n; p++) &#123;</span><br><span class="line">            dp[p] = window.max() + nums[p];</span><br><span class="line">            <span class="comment">// 维护窗口装着 dp[p-1..p-k]</span></span><br><span class="line">            <span class="keyword">if</span> (window.size() == k) &#123;</span><br><span class="line">                window.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            window.push(dp[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">单调队列的通用实现，可以高效维护最大值和最小值</span></span><br><span class="line"><span class="comment">由于考虑泛型和通用性，提交的性能会略差，你可自行精简</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h1><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。</p><p>返回 你可以获得的最大乘积 。</p><blockquote><p>2 &lt;= n &lt;= 58</p></blockquote><h2 id="思路初试"><a href="#思路初试" class="headerlink" title="思路初试"></a>思路初试</h2><p>读完题目可以感觉到是<strong>动态规划</strong>题目，那么想出<strong>状态转移方程</strong>是最为重要的。</p><p>很明显<strong>状态即数字n的大小</strong>，题目要求的是<strong>求和为n的一系列数字的乘积最大</strong>，那么可以想到构造方程：<code>f(n) = max&#123;k * f(n-k), k=1,2,...,n-1&#125;</code><br>用长度为n的数组<code>states</code>作为<code>bp Table</code>来完成剪枝</p><blockquote><p>题目中要求 n &gt;=2，状态方程中n实际上可以为 1，但是这没有太大关系</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] states;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * f(n) = max&#123;(n-k)*f(k), k = 1,2,...,n-2,n-1&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        states = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> bp(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bp</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(states[n] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> states[n];</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i*bp(n-i);</span><br><span class="line">            <span class="keyword">if</span>(max &lt; temp)</span><br><span class="line">                max = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        states[n] = max;</span><br><span class="line">        <span class="keyword">return</span> states[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交运行，报错。<code>f(10)</code>结果为<code>27</code>。debug发现，求解过程中，<code>f(4)</code>结果为<code>3</code>，这显然是不对的，说明我们的状态方程出了问题。</p><h2 id="思路改进"><a href="#思路改进" class="headerlink" title="思路改进"></a>思路改进</h2><p><code>f(4) = max&#123;1*f(3), 2*f(2), 3*f(1)&#125;</code>，这里<code>f(2)=1</code>，到这里就能看出问题所在了。<code>f(4)</code>应该为<code>2*2 = 4</code>，但是按照我们的状态方程，我们又把<code>后面的2</code>转换为<code>f(2)</code>求解，所以最终导致<code>f(4)</code>结果错误。</p><p>分析发现，转换后的<code>f(n-k)</code>并不一定比<code>n-k</code>大。应改进状态方程，先得到原始的<code>n-k</code>和转换为<code>f(n-k)</code>中较大者，再乘<code>k</code>，改进后方程：<code>f(n) = max&#123;k * max[n-k, f(n-k)], k=1,2,...,n-1&#125;</code></p><p>正确代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] states;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * f(n) = max&#123;(n-k) * max[n-k,f(k)], k = 1,2,...,n-2,n-1&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        states = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> bp(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bp</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(states[n] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> states[n];</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bp = bp(n-i);</span><br><span class="line">            <span class="keyword">int</span> temp = i * (n-i &gt; bp ? n-i : bp);</span><br><span class="line">            <span class="keyword">if</span>(max &lt; temp)</span><br><span class="line">                max = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        states[n] = max;</span><br><span class="line">        <span class="keyword">return</span> states[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h1><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><h2 id="要点笔记"><a href="#要点笔记" class="headerlink" title="要点笔记"></a>要点笔记</h2><p>解题关键和难点在于<strong>状态方程</strong>，一旦理解到了最大正方形的找法，一切都迎刃而解了！可惜自己做的时候百思不得其解，哈哈。</p><p>状态方程见下<strong>labuladong</strong></p><p>还有需要注意的是，此题中的<strong>base case</strong>，为矩阵的首行和首列。</p><h2 id="labuladong-4"><a href="#labuladong-4" class="headerlink" title="labuladong"></a>labuladong</h2><p>关键是你要观察出一个全是 1 的正方形有什么特点，如何根据小的正方形推导出大的正方形（状态转移方程）</p><p>当<code>matrix[i][j]为1</code>，且它的左边、上边、左上边都存在正方形时，<code>matrix[i][j]</code>才能够作为一个更大的正方形的右下角：</p><p><img src="/./leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/221%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2.jpg" alt="img 221.最大正方形"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 类似「水桶效应」，最大边长取决于边长最短的那个正方形</span></span><br><span class="line">    dp[i][j] = min(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dp[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>题解代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 定义：以 matrix[i][j] 为右下角元素的全为 1 正方形矩阵的最大边长为 dp[i][j]。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base case，第一行和第一列的正方形边长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 值为 0 不可能是正方形的右下角</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(</span><br><span class="line">                    dp[i - <span class="number">1</span>][j],</span><br><span class="line">                    dp[i][j - <span class="number">1</span>]),</span><br><span class="line">                    dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                ) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                len = Math.max(len, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len * len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-II-017-含有所有字符的最短字符（76-最小覆盖字串）"><a href="#剑指-Offer-II-017-含有所有字符的最短字符（76-最小覆盖字串）" class="headerlink" title="剑指 Offer II 017 含有所有字符的最短字符（76.最小覆盖字串）"></a>剑指 Offer II 017 含有所有字符的最短字符（76.最小覆盖字串）</h1><p>给定两个字符串 s 和 t 。返回 s 中包含 t 的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 “” 。</p><p>如果 s 中存在多个符合条件的子字符串，返回任意一个。</p><p>注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>示例 1：</p><p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>解释：最短子字符串 “BANC” 包含了字符串 t 的所有字符 ‘A’、’B’、’C’<br>示例 2：</p><p>输入：s = “a”, t = “a”<br>输出：”a”<br>示例 3：</p><p>输入：s = “a”, t = “aa”<br>输出：””<br>解释：t 中两个字符 ‘a’ 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。<br>提示：</p><ul><li>1 &lt;= s.length, t.length &lt;= 10^5</li><li>s 和 t 由英文字母组成</li></ul><h2 id="个人思路-8"><a href="#个人思路-8" class="headerlink" title="个人思路"></a>个人思路</h2><p>遇到求字串问题，优先考虑<strong>滑动窗口</strong>方法。</p><p>滑动窗口的关键在于<strong>缩小窗口的时机</strong>和<strong>如何缩小窗口</strong>，而且重点在于后者！！！</p><p>根据题目要求，所求字符串必须包含 t 的所有字符，且相应字符的数量必须不小于 t 中的数量。</p><p>缩小窗口：等到<strong>窗口合法</strong>后，left++。注意 left 右移后，窗口仍有可能合法，所以需要<strong>while循环</strong>判断窗口的合法性。</p><p>本方法的时间和空间复杂度都不是很好，可以看下面的改进方法。</p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> il = <span class="number">0</span>, ir = s.length();    <span class="comment">//结果字符串索引</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                map.put(c, map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            window.put(c, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//窗口数据更新</span></span><br><span class="line">            <span class="keyword">if</span>(window.containsKey(r))&#123;</span><br><span class="line">                window.put(r, window.get(r)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//窗口左侧是否需要收缩</span></span><br><span class="line">            <span class="keyword">while</span> (isValidWindow(map, window))&#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; ir - il + <span class="number">1</span>) &#123;</span><br><span class="line">                    ir = right - <span class="number">1</span>;</span><br><span class="line">                    il = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">//窗口数据更新</span></span><br><span class="line">                <span class="keyword">if</span>(window.containsKey(l))&#123;</span><br><span class="line">                    window.put(l, window.get(l)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ir == s.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> s.substring(il, ir+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isValidWindow</span><span class="params">(HashMap&lt;Character, Integer&gt; map, HashMap&lt;Character, Integer&gt; window)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Character c : window.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(window.get(c) &lt; map.get(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><p>题解思路：利用双指针找到以下标right结尾，且含有t所有字符的最小长度区间[left,right]</p><p>定义两个数组 cnt1与cnt2，将字母转化成数字，并以此为下标，出现次数作为值存进数组中，当cnt2[n]&gt;=cnt1[n]，也就是cnt2中 n 所代表的字符出现次数，比cnt1中 n 所代表的字符出现次数多或相等，也就是含有。</p><p>改进方法真的非常巧妙！！！</p><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> m = t.length();</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//cnt1:t的参照数组</span></span><br><span class="line">        <span class="keyword">int</span>[] cnt1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="keyword">int</span>[] cnt2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="comment">//初始化cnt1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            cnt1[t.charAt(i)-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;   <span class="comment">//t中字符种类数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : cnt1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">                diff++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = s.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n)&#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            cnt2[r-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(cnt1[r-<span class="string">&#x27;A&#x27;</span>] == cnt2[r-<span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">                diff--;</span><br><span class="line">            <span class="comment">//窗口满足条件,尝试缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (diff == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min &gt; right-left)&#123;</span><br><span class="line">                    min = right-left;</span><br><span class="line">                    res = s.substring(left, right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//尝试缩小窗口</span></span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                cnt2[l-<span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                <span class="comment">//若移除字符 l 是否是 t 中的字符，且破环了窗口的合法性</span></span><br><span class="line">                <span class="keyword">if</span>(cnt1[l-<span class="string">&#x27;A&#x27;</span>] != <span class="number">0</span> &amp;&amp; cnt2[l-<span class="string">&#x27;A&#x27;</span>] &lt; cnt1[l-<span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">                    diff++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004.最大连续1的个数 III"></a>1004.最大连续1的个数 III</h1><p>给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。</p><p>示例 1：</p><p>输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2<br>输出：6<br>解释：[1,1,1,0,0,1,1,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 6。<br>示例 2：</p><p>输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3<br>输出：10<br>解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 10。</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 105</li><li>nums[i] 不是 0 就是 1</li><li>0 &lt;= k &lt;= nums.length</li><li>Related Topics</li><li><h2 id="个人思路-9"><a href="#个人思路-9" class="headerlink" title="个人思路"></a>个人思路</h2>这个题目很好体现了<strong>缩小窗口的时机</strong>也很重要，当然<strong>如何缩小窗口</strong>也很重要。<br>题目还有需要注意的是<strong>如何维护窗口</strong>，其他滑动窗口题目中<strong>维护窗口</strong>都很简单。</li></ul><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = nums[right];</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(r == <span class="number">1</span>)&#123;</span><br><span class="line">                max = Math.max(max, right-left);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//r == 0</span></span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//不能再翻转 r,缩小窗口，移动left到下一个 0 的后面位置</span></span><br><span class="line">                    <span class="comment">//这里条件不能写为 left &lt; right ,因为循环体里 left++ 是在后面！！！</span></span><br><span class="line">                    <span class="comment">// 因为 left = right-1时，还要进行 num[left] == 0的判断</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[left] == <span class="number">0</span>)&#123;</span><br><span class="line">                            k++;</span><br><span class="line">                            left++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前面将 left移动下一个 0 的后面的位置，k++。但是当前 r = 0，又消耗了一次 k，所以 k--</span></span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//翻转 r</span></span><br><span class="line">                    k--;</span><br><span class="line">                    max = Math.max(max, right-left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://up-bear.github.io/2022/08/27/she-ji-mo-shi/"/>
    <id>https://up-bear.github.io/2022/08/27/she-ji-mo-shi/</id>
    <published>2022-08-27T08:05:18.000Z</published>
    <updated>2024-01-02T12:53:17.469Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="## 适配器模式"></a>## 适配器模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 适配器模式：使用新接口包装旧接口，达到适配目的</span></span><br><span class="line"><span class="comment">* 目标抽象类：定义业务新接口</span></span><br><span class="line"><span class="comment">* 适配器类：实现业务新接口，并持有旧接口对象的引用</span></span><br><span class="line"><span class="comment">* 被适配类：旧接口实现类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapterInterface</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> newMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">AdapterInterface</span></span>&#123;</span><br><span class="line">  OldInterfaceImpl oldInterfaceImpl;</span><br><span class="line"></span><br><span class="line">  Adapter(<span class="keyword">this</span>.oldInterfaceImpl);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> newMethod() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;new method start&#x27;</span>);</span><br><span class="line">    oldInterfaceImpl.oldMethod();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;new method end&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldInterfaceImpl</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> oldMethod()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;this is old method&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 桥接模式：将抽象类的方法实现抽离出实现类，交由桥接接口及其实现类负责</span></span><br><span class="line"><span class="comment">* 抽象化接口：原始的接口</span></span><br><span class="line"><span class="comment">* - 具体抽象化类：拓展抽象化接口以实现更多功能（不太理解）</span></span><br><span class="line"><span class="comment">* 桥接接口：定义实现“抽象化接口”方法的方法</span></span><br><span class="line"><span class="comment">* - 具体实现类：实现桥接接口的方法（实际上就是“抽象化接口”的方法）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span>不太理解</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span></span>&#123;</span><br><span class="line">  Bridge bridge;</span><br><span class="line"></span><br><span class="line">  Abstraction(<span class="keyword">this</span>.bridge);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span>&#123;</span><br><span class="line">  Circle(<span class="keyword">super</span>.bridge);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> draw() &#123;</span><br><span class="line">    bridge.draw();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bridge</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BridgeChild</span> <span class="keyword">extends</span> <span class="title">Bridge</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> draw() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I finish drawing one Circle&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 建造者模式：组装复杂对象</span></span><br><span class="line"><span class="comment">* 产品类：要组装的对象</span></span><br><span class="line"><span class="comment">* 建造者：每一个组装步骤。</span></span><br><span class="line"><span class="comment">* - 抽象建造者：定义每个建造步骤</span></span><br><span class="line"><span class="comment">* - 具体建造者：实现每个建造步骤</span></span><br><span class="line"><span class="comment">* 指挥者：通过多个建造步骤实现组装对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String?</span> name;</span><br><span class="line">  <span class="built_in">String?</span> sex;</span><br><span class="line">  <span class="built_in">String?</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> setPart1();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setPart2();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setPart3();</span><br><span class="line"></span><br><span class="line">  Product result();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuilderA</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">  Product _product = Product();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> setPart1() &#123;</span><br><span class="line">    _product.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> setPart2() &#123;</span><br><span class="line">    _product.sex = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> setPart3() &#123;</span><br><span class="line">    _product.age = <span class="string">&#x27;18&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Product result() &#123;</span><br><span class="line">    <span class="keyword">return</span> _product;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> direct(Builder builder)&#123;</span><br><span class="line">    builder.setPart1();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;建造步骤-1&#x27;</span>);</span><br><span class="line">    builder.setPart2();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;建造步骤-2&#x27;</span>);</span><br><span class="line">    builder.setPart3();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;建造步骤-3&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 责任链模式：请求处理的处理链，</span></span><br><span class="line"><span class="comment">* 抽象处理器：定义处理器的接口，并且持有下一个处理器的引用</span></span><br><span class="line"><span class="comment">* 具体处理器：实现抽象处理器的接口</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 在职责链模式中，每个处理者都有机会处理请求，但是处理者并不知道下一个处理者是谁，</span></span><br><span class="line"><span class="comment">* 请求会依次经过处理者链中的每个处理者，直到有一个处理者处理它为止。因此，职责链</span></span><br><span class="line"><span class="comment">* 模式可以避免请求的发送者和接收者之间的耦合关系，以及将请求的处理从发送者中分离出来。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 职责链模式适用于以下情况：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 多个对象都有机会处理请求，但是不知道哪个对象最终会处理请求。</span></span><br><span class="line"><span class="comment">* 处理请求的对象集合可以动态配置，可以在运行时添加或删除处理对象。</span></span><br><span class="line"><span class="comment">* 发送者不需要知道请求的处理细节，只需要知道请求会被处理。</span></span><br><span class="line"><span class="comment">* 职责链模式常常应用于日志记录、异常处理、审批流程等场景。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">  Chain? nextChain;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> doRequest(<span class="built_in">String</span> request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setChain(Chain chain) &#123;</span><br><span class="line">    <span class="keyword">this</span>.nextChain = chain;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain1</span> <span class="keyword">extends</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> doRequest(<span class="built_in">String</span> request) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(request == <span class="string">&#x27;request 1&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Chain 1 do request&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(nextChain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nextChain!.doRequest(request);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 命令模式</span></span><br><span class="line"><span class="comment">* 抽象命令：定义命令接口</span></span><br><span class="line"><span class="comment">* 具体命令：定义具体命令，持有命令接受者的引用</span></span><br><span class="line"><span class="comment">* 命令接受者：命令的实现的承包，实现具体命令</span></span><br><span class="line"><span class="comment">* 调用者：持有具体命令的引用，调用命令的各个方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 一种行为设计模式，它将请求封装成一个对象，从而允许使用不同的请求、</span></span><br><span class="line"><span class="comment">* 队列或者日志来参数化其他对象。命令模式的核心在于将请求和实现分离开，</span></span><br><span class="line"><span class="comment">* 从而可以使请求具有独立的生命周期和实现。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 命令模式是一种常见的设计模式，可以应用于各种场景中，例如：</span></span><br><span class="line"><span class="comment">* 图形界面应用程序中的快捷键：将快捷键封装成一组命令对象，并将这些命令对象注册到快捷键管理器中，从而可以方便地进行调用和管理。</span></span><br><span class="line"><span class="comment">* 服务器端应用程序中的请求处理：将请求封装成一组命令对象，并将这些命令对象注册到请求处理器中，从而可以方便地进行调用、传递和管理。</span></span><br><span class="line"><span class="comment">* 游戏中的角色控制：将角色控制命令封装成一组命令对象，并将这些命令对象注册到角色管理器中，从而可以方便地进行调用、传递和管理。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> command();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartCommand</span> <span class="keyword">extends</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">  Accept accept;</span><br><span class="line"></span><br><span class="line">  StartCommand(<span class="keyword">this</span>.accept);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> command() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;具体命令开始&#x27;</span>);</span><br><span class="line">    accept.doCommand();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;具体命令实现&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象命令接受者/实现者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Accept</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doCommand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体命令接受者/实现者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcceptImpl</span> <span class="keyword">extends</span> <span class="title">Accept</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doCommand()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;具体命令的实现执行&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoke</span></span>&#123;</span><br><span class="line">  Command? command;</span><br><span class="line">  <span class="keyword">void</span> setCommand(Command command)&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = command;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> startCommand()&#123;</span><br><span class="line">    command?.command();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 组合模式：树（层级）结构的对象集合</span></span><br><span class="line"><span class="comment">* 抽象构件：叶子和组合构件的抽象</span></span><br><span class="line"><span class="comment">* - 叶子构件：不含有子节点</span></span><br><span class="line"><span class="comment">* - 组合构件：包含子节点的构件</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> add(Component component);</span><br><span class="line">  <span class="built_in">bool</span> remove(Component component);</span><br><span class="line">  <span class="keyword">void</span> display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaves</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> add(Component component) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Leaves can not add&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> display() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I am a leaves&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> remove(Component component) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Leaves can not remove&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;Component&gt; list = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> add(Component component) &#123;</span><br><span class="line">    list.add(component);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> display() &#123;</span><br><span class="line">    <span class="keyword">for</span>(Component component <span class="keyword">in</span> list)&#123;</span><br><span class="line">      component.display();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> remove(Component component) &#123;</span><br><span class="line">    list.remove(component);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 装饰器模式：拓展原有对象的功能</span></span><br><span class="line"><span class="comment">* 抽象接口：被装饰类和装饰器类的接口定义</span></span><br><span class="line"><span class="comment">* - 被装饰类</span></span><br><span class="line"><span class="comment">* - 装饰器类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentA</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> display() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Component-A&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  Component component;</span><br><span class="line"></span><br><span class="line">  Decorator(<span class="keyword">this</span>.component);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> display();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorExd</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">  DecoratorExd(<span class="keyword">super</span>.component);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> display() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;进行功能增强&#x27;</span>);</span><br><span class="line">    component.display();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 外观模式：将复杂操作和细节隐藏起来</span></span><br><span class="line"><span class="comment">* Facade：外观类</span></span><br><span class="line"><span class="comment">* 子系统类：系统功能类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">System1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> display() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;system-1 display&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">System2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> display() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;system-2 display&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span></span>&#123;</span><br><span class="line">  <span class="keyword">late</span> System1 system1;</span><br><span class="line">  <span class="keyword">late</span> System2 system2;</span><br><span class="line"></span><br><span class="line">  Facade()&#123;</span><br><span class="line">    system1 = System1();</span><br><span class="line">    system2 = System2();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> display()&#123;</span><br><span class="line">    system1.display();</span><br><span class="line">    system2.display();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">简单工厂模式</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Product creat(<span class="built_in">String</span> type)&#123;</span><br><span class="line">    Product product;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        product = A(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        product = B(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        product = A(<span class="string">&#x27;dufault&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">  Product(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">String?</span> name;</span><br><span class="line">  <span class="keyword">void</span> sayName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">  A(<span class="keyword">super</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> sayName() &#123;</span><br><span class="line">    <span class="built_in">print</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">  B(<span class="keyword">super</span>.name);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> sayName() &#123;</span><br><span class="line">    <span class="built_in">print</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="markdown">工厂方法模式</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">  AbstractProduct create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> say();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  AbstractProduct create() &#123;</span><br><span class="line">    <span class="keyword">return</span> ProductA();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">AbstractProduct</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> say()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Product-A&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式（轻量模式）"><a href="#享元模式（轻量模式）" class="headerlink" title="享元模式（轻量模式）"></a>享元模式（轻量模式）</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 享元模式：FlyWeight，更愿称之为轻量模式。避免重复创建对象，节省开销。</span></span><br><span class="line"><span class="comment">* 抽象享元类：创建对象的抽象类</span></span><br><span class="line"><span class="comment">* 具体享元类：抽象享元的实现类</span></span><br><span class="line"><span class="comment">* 享元工厂：创建/获取享元对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象享元类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体享元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Bike can run!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//享元工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Map</span> _cars = &lt;<span class="built_in">String</span>, Car&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Car getOrCreateCar(<span class="built_in">String</span> key)&#123;</span><br><span class="line">    Car? car = _cars[key];<span class="comment">//没有，null，所以car需要可null声明</span></span><br><span class="line">    <span class="keyword">if</span>(car == <span class="keyword">null</span>)&#123;</span><br><span class="line">      _cars[key] = Bike();</span><br><span class="line">      <span class="keyword">return</span> _cars[key];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 迭代器模式</span></span><br><span class="line"><span class="comment">* 抽象聚合类：抽象集合类，定义接口</span></span><br><span class="line"><span class="comment">* 具体聚合类：具体集合类，实现接口，（持有集合引用）</span></span><br><span class="line"><span class="comment">* 抽象迭代器：定义抽象操作</span></span><br><span class="line"><span class="comment">* 具体迭代器：实现具体迭代操作</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 迭代器模式的场景包括：</span></span><br><span class="line"><span class="comment">需要遍历一个聚合对象（如一个列表、数组等）中的元素，但是不想暴露聚合对象的内部结构。</span></span><br><span class="line"><span class="comment">需要对聚合对象进行多种方式的遍历，如顺序遍历、倒序遍历等。</span></span><br><span class="line"><span class="comment">需要在遍历过程中实现某些操作，如筛选、过滤等。</span></span><br><span class="line"><span class="comment">需要在多个不同的聚合对象上进行相同的操作，而不需要关心它们的具体实现。</span></span><br><span class="line"><span class="comment">需要提供一种统一的遍历接口，以便客户端可以使用相同的方式处理不同的聚合对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">例子：</span></span><br><span class="line"><span class="comment">遍历一个网站上的文章列表，以便按照用户的需求进行排序、搜索等操作。</span></span><br><span class="line"><span class="comment">遍历一个电商平台上的商品列表，以便实现商品的分类、筛选、排序等操作。</span></span><br><span class="line"><span class="comment">遍历一个音乐播放器中的歌曲列表，以便实现歌曲的随机播放、循环播放等操作。</span></span><br><span class="line"><span class="comment">遍历一个数据库中的数据表，以便实现数据的增删改查等操作。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象聚合类（抽象集合）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义添加方法</span></span><br><span class="line">  <span class="keyword">void</span> add(<span class="built_in">Object</span> object);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义移除方法</span></span><br><span class="line">  <span class="keyword">void</span> remove(<span class="built_in">Object</span> object);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义获取迭代器方法</span></span><br><span class="line">  <span class="built_in">Iterator</span> getIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体聚合类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCollection</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strs = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> add(<span class="built_in">Object</span> object) &#123;</span><br><span class="line">    strs.add(object <span class="keyword">as</span> <span class="built_in">String</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> remove(<span class="built_in">Object</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">is</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">      strs.remove(object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">Iterator</span> getIterator() &#123;</span><br><span class="line">    <span class="keyword">return</span> IteratorImpl(strs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取下一个元素</span></span><br><span class="line">  <span class="built_in">Object</span> next();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否有下一个元素</span></span><br><span class="line">  <span class="built_in">bool</span> hasNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorImpl</span> <span class="keyword">extends</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; list = [];</span><br><span class="line">  <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  IteratorImpl(<span class="keyword">this</span>.list);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> hasNext() &#123;</span><br><span class="line">    <span class="keyword">return</span> index &lt; list.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span> next() &#123;</span><br><span class="line">    <span class="keyword">return</span> index &lt; list.length ? list[index++] : <span class="built_in">Null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 中介者模式：各个同事类之间通过中介进行通信交互</span></span><br><span class="line"><span class="comment">* 抽象中介：定义与同事类通信的方法</span></span><br><span class="line"><span class="comment">* 具体中介：实现与同事类通信的方法</span></span><br><span class="line"><span class="comment">* 抽象同事：定义与中介通信的方法，并持有中介的引用</span></span><br><span class="line"><span class="comment">* 具体同事：实现与中介通信的方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 提供一个中介对象来协调一组对象之间的交互。中介者对象封装了一些对象之间的通信方式，</span></span><br><span class="line"><span class="comment">* 使得它们不需要直接相互引用，从而降低它们之间的依赖性和耦合度。中介者模式常用于复杂</span></span><br><span class="line"><span class="comment">* 的系统中，例如GUI系统、企业应用程序等。在这些系统中，对象之间的关系非常复杂，因此</span></span><br><span class="line"><span class="comment">* 使用中介者模式可以使得系统更易于维护和扩展。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象中介</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> sendMessage(<span class="built_in">String</span> message, Colleague colleague);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体中介</span></span><br><span class="line"><span class="comment">//注册同事</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediatorImpl</span> <span class="keyword">implements</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Colleague&gt; map;</span><br><span class="line"></span><br><span class="line">  MediatorImpl(<span class="keyword">this</span>.map);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> register(Colleague colleague)&#123;</span><br><span class="line">    <span class="built_in">String</span> id = colleague.userId;</span><br><span class="line">    <span class="keyword">if</span>(!map.containsKey(id))&#123;</span><br><span class="line">      map[id] = colleague;</span><br><span class="line">      colleague.mediator = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> sendMessage(<span class="built_in">String</span> message, Colleague colleague) &#123;</span><br><span class="line">    <span class="built_in">String</span> id = colleague.userId;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(id))&#123;</span><br><span class="line">      colleague.receiveMessage(message);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;该用户未注册&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象同事</span></span><br><span class="line"><span class="comment">//发送消息，接收消息</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> userId;</span><br><span class="line">  Mediator? mediator;</span><br><span class="line">  Colleague(<span class="keyword">this</span>.userId);</span><br><span class="line">  Colleague.withMediator(<span class="keyword">this</span>.mediator, <span class="keyword">this</span>.userId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> sendMessage(<span class="built_in">String</span> message)&#123;</span><br><span class="line">    mediator?.sendMessage(message, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> receiveMessage(<span class="built_in">String</span> message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">  User(<span class="keyword">super</span>.userId);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> receiveMessage(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$userId</span> has received message: <span class="subst">$message</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 备忘录模式</span></span><br><span class="line"><span class="comment">* 发起者（存储对象）：</span></span><br><span class="line"><span class="comment">* 备忘录（存储器）：</span></span><br><span class="line"><span class="comment">* 管理者：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 备忘录模式（Memento Pattern）在面向对象设计中被广泛应用，其主要作用是在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在需要的时候将对象恢复到先前的状态。</span></span><br><span class="line"><span class="comment">下面是一些备忘录模式的应用场景：</span></span><br><span class="line"><span class="comment">撤销操作：在许多应用程序中，用户执行操作时需要有“撤销”操作。通过备忘录模式，可以在执行操作前将当前对象的状态保存到备忘录中，当需要撤销时，从备忘录中获取之前保存的状态并恢复对象。</span></span><br><span class="line"><span class="comment">数据库事务回滚：在数据库系统中，事务是一组被视为一个单独工作单元的操作。在执行事务时，如果发生了错误，需要将整个事务回滚到最初的状态。备忘录模式可以用来实现这种回滚，将事务执行前的状态保存到备忘录中，当出现错误时可以从备忘录中恢复原始状态。</span></span><br><span class="line"><span class="comment">游戏存档：在许多游戏中，玩家需要保存游戏进度，以便在之后的时间里恢复到该点。备忘录模式可以用来保存游戏状态，让玩家在需要时回到先前的状态。</span></span><br><span class="line"><span class="comment">操作系统恢复：当操作系统出现错误或崩溃时，需要将系统的状态恢复到某个先前的时间点。备忘录模式可以利用系统快照机制，将系统的状态保存到备忘录中，从而实现系统恢复。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//备忘录</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextMemento</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> text;</span><br><span class="line"></span><br><span class="line">  TextMemento(<span class="keyword">this</span>.text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> text;</span><br><span class="line"></span><br><span class="line">  Text(<span class="keyword">this</span>.text);</span><br><span class="line"></span><br><span class="line">  TextMemento createMemento() &#123;</span><br><span class="line">    <span class="keyword">return</span> TextMemento(text);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> restoreFromMemento(TextMemento memento)&#123;</span><br><span class="line">    text = memento.text;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">History</span></span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;TextMemento&gt; list = &lt;TextMemento&gt;[];</span><br><span class="line">  <span class="keyword">void</span> push(TextMemento memento)&#123;</span><br><span class="line">    list.add(memento);</span><br><span class="line">  &#125;</span><br><span class="line">  TextMemento pop()&#123;</span><br><span class="line">    <span class="keyword">return</span> list.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 观察者模式</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 抽象观察对象:状态变更通知所有观察者</span></span><br><span class="line"><span class="comment">* 具体观察对象</span></span><br><span class="line"><span class="comment">* 抽象观察者</span></span><br><span class="line"><span class="comment">* 具体观察对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> addObserver(Observer observer);</span><br><span class="line">  <span class="keyword">void</span> removeObserver(Observer observer);</span><br><span class="line">  <span class="keyword">void</span> notifyObserver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectA</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;Observer&gt; _observers = &lt;Observer&gt;[];</span><br><span class="line">  <span class="built_in">int</span> _state;</span><br><span class="line"></span><br><span class="line">  SubjectA(<span class="keyword">this</span>._state);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> state(<span class="built_in">int</span> state)&#123;</span><br><span class="line">    _state = state;</span><br><span class="line">    notifyObserver();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> state =&gt;_state;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> notifyObserver() &#123;</span><br><span class="line">    <span class="keyword">for</span>(Observer observer <span class="keyword">in</span> _observers)&#123;</span><br><span class="line">      observer.response();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> addObserver(Observer observer) &#123;</span><br><span class="line">    _observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> removeObserver(Observer observer) &#123;</span><br><span class="line">    _observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> response();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverA</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> response() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Observer A 接收到通知&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型模式（浅克隆-深克隆）"><a href="#原型模式（浅克隆-深克隆）" class="headerlink" title="原型模式（浅克隆/深克隆）"></a>原型模式（浅克隆/深克隆）</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 代理模式</span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 代理模式：对被代理类进行功能增强</span></span><br><span class="line"><span class="comment">* 抽象接口：定义接口方法</span></span><br><span class="line"><span class="comment">* 真实类（被代理类）：实现抽象接口</span></span><br><span class="line"><span class="comment">* 代理类：实现抽象接口，并持有真实类的引用</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Real</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> display() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;real class display&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">  Interface? real;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setReal(Interface real)&#123;</span><br><span class="line">    <span class="keyword">this</span>.real = real;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> display() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;代理开始&#x27;</span>);</span><br><span class="line">    real?.display();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;代理结束&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 单例模式</span></span><br><span class="line"><span class="comment">* 该实现为饿汉式</span></span><br><span class="line"><span class="comment">* 懒汉式，需要在工厂构造方法中实例化单例</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="comment">//私有静态变量，只能通过工厂构造方法获取单例</span></span><br><span class="line">  <span class="keyword">static</span> Singleton _singleton = Singleton._create();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有命名构造方法</span></span><br><span class="line">  Singleton._create();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//工厂构造方法，只能访问静态方法、静态属性</span></span><br><span class="line">  <span class="keyword">factory</span> Singleton()&#123;</span><br><span class="line">    <span class="keyword">return</span> _singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 状态模式：状态发生改变时，行为也随之改变</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 上下文Context</span></span><br><span class="line"><span class="comment">* 抽象状态State</span></span><br><span class="line"><span class="comment">* 具体状态</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象状态</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> handle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedLight</span> <span class="keyword">implements</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> handle() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Red Light:红灯&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenLight</span> <span class="keyword">implements</span> <span class="title">Light</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> handle() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Green Light:绿灯&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">  Light? state;</span><br><span class="line"></span><br><span class="line">  Context();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> handle()&#123;</span><br><span class="line">    state?.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 策略模式</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 环境Context（上下文）</span></span><br><span class="line"><span class="comment">* 抽象策略</span></span><br><span class="line"><span class="comment">* 具体策略</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span>和状态模式有什么区别？</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doOperation(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体策略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyOne</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> doOperation(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">    <span class="built_in">print</span>(a-b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyTwo</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> doOperation(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">    <span class="built_in">print</span>(a+b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">  Strategy strategy;</span><br><span class="line">  Context(<span class="keyword">this</span>.strategy);</span><br><span class="line">  <span class="keyword">void</span> doOperation(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">    strategy.doOperation(a, b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 模板方法：定义了算法的骨架，具体细节交由算法实现类完成</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 抽象模板类：算法骨架类</span></span><br><span class="line"><span class="comment">* 具体算法类：实现骨架类的算法细节</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> display() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;AAA&#x27;</span>);</span><br><span class="line">    run();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;BBB&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateImplA</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;TemplateImplA&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateImplB</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;TemplateImplB&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JUC学习笔记</title>
    <link href="https://up-bear.github.io/2022/08/11/juc-xue-xi-bi-ji/"/>
    <id>https://up-bear.github.io/2022/08/11/juc-xue-xi-bi-ji/</id>
    <published>2022-08-11T05:30:17.000Z</published>
    <updated>2022-11-20T10:56:44.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><strong>JUC</strong><br>即Java并发编程工具包，java.util.concurren。</p><p><strong>用户线程和守护线程</strong><br>当用户线程不存在时，守护线程也会随之结束，守护线程的生命周期和JVM相同（守护线程似乎顾名思义，守护用户线程，用户线程不存在时守护线程也没有了存在的意义） </p><p><strong>管程</strong><br>即Monitor(监视器)，即平时所说的锁</p><ul><li>Monitor其实是一种同步机制,它的义务是保证(在同一时间)只有一个线程可以访问被保护的数据和代码</li><li>JVM中同步时基于进入和退出的监视器对象(Monitor,管程),每个对象实例都有一个Monitor对象。</li><li>Monitor对象和JVM对象一起销毁,底层由C来实现</li></ul><h1 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h1><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>使用Callable接口</li><li>使用线程池</li></ul><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//4.创建Thread类的子类对象</span></span><br><span class="line">        MyThread myThread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//5.调用start()方法开启线程</span></span><br><span class="line">        <span class="comment">//[ 会自动调用run方法这是JVM做的事情,源码看不到 ]</span></span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是主线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//2.重写run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//3.将要执行的代码写在run方法中</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;我是线程&quot;</span>+i);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//4.创建Runnable的子类对象</span></span><br><span class="line">        MyRunnale mr=<span class="keyword">new</span> MyRunnale(); </span><br><span class="line">        <span class="comment">//5.将子类对象当做参数传递给Thread的构造函数,并开启线程</span></span><br><span class="line">        <span class="comment">//MyRunnale taget=mr; 多态</span></span><br><span class="line">        <span class="keyword">new</span> Thread(mr).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是主线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.定义一个类实现Runnable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnale</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2.重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.将要执行的代码写在run方法中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-使用Callable接口"><a href="#3-使用Callable接口" class="headerlink" title="3. 使用Callable接口"></a>3. 使用Callable接口</h2><p>需要借助FutureTask类来实现，类似适配器模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建线程的方式三: 实现callable接口 ---JDK 5.0 新增</span></span><br><span class="line"><span class="comment">1.创建一个实现Callable接口的实现类</span></span><br><span class="line"><span class="comment">2.实现call方法,将此线程需要执行的操作声明在call()中</span></span><br><span class="line"><span class="comment">3.创建callable接口实现类的对象</span></span><br><span class="line"><span class="comment">4.将此callable的对象作为参数传入到FutureTask构造器中,创建FutureTask的对象</span></span><br><span class="line"><span class="comment">5.将FutureTask对象作为参数传递到Thread类的构造器中,创建Thread对象,并调用star</span></span><br><span class="line"><span class="comment">6.获取callable接口中call方法的返回值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建callable接口实现类的对象</span></span><br><span class="line">        NumThead m=<span class="keyword">new</span> NumThead();</span><br><span class="line">        <span class="comment">//4.将此callable的对象作为参数传入到FutureTask构造器中,创建FutureTask的对象</span></span><br><span class="line">        </span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(m);</span><br><span class="line">        <span class="comment">//5.将FutureTask对象作为参数传递到Thread类的构造器中,创建Thread对象,并调用start()方法</span></span><br><span class="line">        <span class="comment">//FutureTask类继承了Runnable接口</span></span><br><span class="line">        <span class="comment">//new Runnable = futrueTask;</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.获取callable接口中call方法的返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get()方法返回值即为FutureTask构造器参数callable实现类重写的call方法的返回值</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和是:&quot;</span>+sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建一个实现Callable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">NumThead</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">   <span class="comment">// class  NumThead implements Callable&lt;Integer&gt;&#123;</span></span><br><span class="line">    <span class="comment">//2.实现call方法,将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//public Integer call() throws Exception &#123;</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>多线程/有返回值/异步任务</strong><br>FutureTask实现了RunnableFuture接口，进而实现了Future和Runnable接口。</p><ul><li>可与Runnable实现无返回值的多线程创建</li><li>与Callable接口一起实现有返回值的多线程创建，达到了<code>多线程/有返回值/异步任务</code>要求。</li></ul><p><strong>FutureTask</strong><br>get()：在Future完成计算前会使当前线程阻塞，知道计算完成<br>isDone()：查询Future是否完成计算</p><p>可以结合使用isDone()和get()，利用轮询的方式来获取Future的计算结果，但是会消耗CPU性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(futureTask.isDone())&#123;</span><br><span class="line">System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用线程池"><a href="#4-使用线程池" class="headerlink" title="4. 使用线程池"></a>4. 使用线程池</h2><h2 id="编程步骤"><a href="#编程步骤" class="headerlink" title="编程步骤"></a>编程步骤</h2><ol><li>创建资源类，创建属性和操作方法</li><li>创建多个线程，调用资源类的操作方法<ul><li>判断，同时防止虚假唤醒</li><li>干活</li><li>通知<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建资源类，定义属性和操作方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Share</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line"><span class="comment">//+1方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//判断，用while而不是if，防止虚假唤醒</span></span><br><span class="line"><span class="keyword">while</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//干活</span></span><br><span class="line">number++;</span><br><span class="line">System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot; :: &quot;</span>+number);</span><br><span class="line"><span class="comment">//通知</span></span><br><span class="line"><span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-1方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//判断，用while而不是if，防止虚假唤醒</span></span><br><span class="line"><span class="keyword">while</span>(number != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//干活</span></span><br><span class="line">number--;</span><br><span class="line">System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot; :: &quot;</span>+number);</span><br><span class="line"><span class="comment">//通知</span></span><br><span class="line"><span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo1</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建多线程，调用资源类的操作方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span> </span>&#123;</span><br><span class="line">Share share = <span class="keyword">new</span> Share();</span><br><span class="line"><span class="comment">//创建多线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">share.incr();<span class="comment">//+1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">share.decr();<span class="comment">//-1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">share.incr();<span class="comment">//+1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">share.decr();<span class="comment">//-1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;DD&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>虚假唤醒</strong><br>由于wait()<strong>在哪里睡着就在哪里起来</strong>的特性，会出现在直接在<strong>if</strong>条件体中唤醒，继续向下执行，从而跳过条件判断。使用<strong>while</strong>循环解决虚假唤醒问题，即使在循环体中唤醒也要走一遍<strong>while</strong>循环条件的判断。</p><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>可被上锁的内容：</p><ul><li>代码块：被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象</li><li>方法：被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象</li><li>静态方法：作用的范围是整个静态方法，作用的对象是这个类的所有对象</li><li>作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象</li></ul><p>synchronized是不能被子类继承的，子类方法要使用synchronized需显式声明。虽然synchronized不能被继承，但是子类调用父类的synchronized方法时，方法是同步的。</p><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p><strong>多线程下的单例实现</strong><br>传统单例（懒汉式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：并发情况下，多个线程调用getInstance()，会创建多个对象，单例失效。<br>解决方案：使用<code>synchronized</code>修饰getInstance()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="comment">//封死了</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码实际也有缺点：虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用getInstance()方法，其余线程都在空转等待。<br>解决方案：因为同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。因此在进入同步代码块之前一次非<code>null</code>检查，在单例对象<code>new</code>出后，其余线程便不会进入同步代码块。（保证只有一个线程<code>new</code>出单例，但仍然可能有其他线程等待锁释放后进入同步代码块，但是这个数量要比没有双重检验锁之前少得多，因为有一部分线程被第一次检查拒之门外）<br><strong>双重检验锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;<span class="comment">//Single Checked</span></span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;<span class="comment">//Double Checked</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h2><p><strong>为什么每个对象可以成为一个锁呢</strong><br>markOop.hpp</p><img src="/2022/08/11/juc-xue-xi-bi-ji/013.png" class=""><p>Monitor(监视器锁)可以理解为一种同步工具，也可理解为一种同步机制，常常被描述为一个Java对象。Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</p><p>Monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。<br>Mutex Lock Monitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。所以synchronized是Java语言中的一个重量级操作。</p><p>Monitor与java对象以及线程是如何关联 ？ </p><ol><li>如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址 </li><li>Monitor的Owner字段会存放拥有相关联对象锁的线程id</li></ol><p>Mutex Lock 的切换需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。</p><p><strong>同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过JDK自带的javap命令查看SynchronizedDemo类的相关字节码信息:</p><ol><li>首先切换到类的对应目录执行javac SynchronizedDemo.java命令生成编译后的.class文件</li><li>然后执行javap -c -s -v -l SynchronizedDemo.class<img src="/2022/08/11/juc-xue-xi-bi-ji/001.png" class=""></li></ol><p>可以看出<code>synchronized同步语句块</code>借助monitorenter和monitorexit指令</p><ul><li>monitorenter指令指向同步代码块的开始位置</li><li>monitorexit指令则指明同步代码块的结束位置</li></ul><p>当执行<code>monitorenter</code>指令时，线程试图获取锁也就是获取<code>对象监视器monitor(管程)</code>的持有权。在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个ObjectMonitor对象。另外<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.llegalMonitorStateException的异常的原因。</p><ul><li>在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为О则表示锁可以被获取，获取后将锁计数器设为1也就是加1。</li><li>在执行monitorexit指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</li></ul><p><strong>同步方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/11/juc-xue-xi-bi-ji/002.png" class=""><p><strong>synchronized原理总结</strong></p><ol><li>synchronized同步语句块的实现使用的是monitorenter和monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</li><li>synchronized修饰的方法并没有monitorenter指令和monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法。<br>3．不过两者的本质都是对对象监视器monitor的获取。</li></ol><img src="/2022/08/11/juc-xue-xi-bi-ji/015.png" class=""><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p>创建一个Java对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><ul><li>类型在方法区</li><li>o引用在栈区</li><li>new Object()在堆区<img src="/2022/08/11/juc-xue-xi-bi-ji/005.jpg" class=""></li></ul><p>JVM虚拟机（HotSpot）中，对象在堆内存中的存储布局分三个部分：</p><ul><li>对象头（Header）</li><li>实例数据（Instance Data）</li><li>对齐填充（Padding）：保证为8字节的倍数<img src="/2022/08/11/juc-xue-xi-bi-ji/004.jpg" class=""></li></ul><p><strong>对象头</strong><br>对象头中包含两部分:</p><ul><li>MarkWord : Mark Word用于存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等等</li><li>类型指针:虚拟机通过这个指针确定该对象是哪个类的实例</li><li>如果是数组对象的话，对象头还有一部分是存储数组的长度<img src="/2022/08/11/juc-xue-xi-bi-ji/006.png" class=""></li></ul><p>多线程下synchronized 的加锁就是对同一个对象的对象头中的MarkWord中的变量进行CAS操作。</p><p><strong>对象标记Mark Word</strong></p><img src="/2022/08/11/juc-xue-xi-bi-ji/007.png" class=""><img src="/2022/08/11/juc-xue-xi-bi-ji/008.png" class=""><p>GC年龄采用4位bit存储,最大为15,例如MaxTenuringThreshold参数默认值就是15，因为GC年龄占4位最大就是1111=15</p><p><strong>类元信息（类型指针）</strong><br>对象指向它的类元数据的指针<br>虚拟机通过这个指针来确定这个对象是哪个类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer cust = <span class="keyword">new</span> Customer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/11/juc-xue-xi-bi-ji/009.png" class=""><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。上述代码实例中对象<code>o</code>共占16字节大小，即Java中，对象内存最小为16字节（JVM开启压缩编码时，实际为12字节，但是对其填充为16字节）</p><h2 id="内存分析JOL"><a href="#内存分析JOL" class="headerlink" title="内存分析JOL"></a>内存分析JOL</h2><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">JAVA object layout</span></span><br><span class="line"><span class="comment">官网:http://openjdk.java.net/projects/code-tools/jol/</span></span><br><span class="line"><span class="comment">定位:分析对象在JVM的大小和分布</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOLDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println( ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><img src="/2022/08/11/juc-xue-xi-bi-ji/010.png" class=""><p>PS：</p><ul><li>左边的二进制数据采用的是小端序，从左向右为从低位到高位，但是每一字节从左到右为从高位到低位</li><li>类型指针只占4字节，是因为JVM默认开启类型指针压缩</li></ul><p>对象有属性值情况</p><img src="/2022/08/11/juc-xue-xi-bi-ji/011.png" class=""><img src="/2022/08/11/juc-xue-xi-bi-ji/012.png" class=""><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>使用synchronized加锁，JVM底层会对锁进行优化，具体可分为三种锁：偏向锁、轻量级锁、重量级锁。其中<strong>偏向锁</strong>和<strong>轻量级锁</strong>都不涉及CPU的用户态和内核态的切换（切换是十分消耗性能的）。</p><p>三种锁分别对应三种情况</p><ol><li>只有一个线程来访问，有且唯一Only One</li><li>有2个线程A、B来交替访问（具体线程不固定，可能A执行完后变成B、C交替执行）</li><li>竞争激烈，多个线程来访问</li></ol><p><strong>产生背景</strong><br>多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况。<br>偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁</p><p>锁标志位：01。（每个对象默认的锁标志位为<code>01</code>，无锁状态下偏向锁位为<code>0</code>，有锁状态下为<code>1</code>）</p><img src="/2022/08/11/juc-xue-xi-bi-ji/014.png" class=""><p><strong>偏向锁流程</strong></p><ol><li>锁被第一次占有时，会在Mark Word中记录下<code>线程ID</code>，如果此线程后续再试图获得该锁，JVM会比较对象标记中的<code>线程ID</code>和此线程ID，结果一致直接放行，不用再获取锁，代码执行完也不需释放锁。偏向线程会一直持有锁，只有发生线程竞争时，锁才会释放。</li><li>如果是其他线程试图获取锁，比较发现锁中的<code>线程ID</code>和线程ID不一致，便会产生竞争，进行CAS操作试图获取该锁：</li></ol><ul><li>获得锁成功：之前的偏向线程可能已经执行完成或者不存在，将新线程的ID写入对象标记Mark Word中，此时锁类型依然为偏向锁，不会升级。（可以理解为白班和夜班的工作交接）</li><li>获得锁失败：之前偏向线程依然在执行，锁获得失败。此时发生了线程竞争，此时锁升级为轻量级锁，保证多线程间进行锁竞争（可以理解为多人面试同一份工作）</li></ul><p><strong>总结</strong><br>偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。 撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行：</p><ul><li>第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。 此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。 </li><li>第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向 。</li></ul><p>优点：由于偏向锁执行同步代码块或方法不需要进行锁的获得和释放，JVM不用和操作系统协商设置Mutex(争取内核)，几乎没有额外开销，性能极高。</p><p><strong>关闭偏向锁</strong><br>关闭偏向锁:使用-XX:-UseBiasedLocking启动参数，偏向锁关闭之后程序默认会直接进入轻量级锁状态</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>有线程来参与锁的竞争，但是获取锁的冲突时间极短。本质就是自旋锁</p><p>轻量级锁是为了在线程近乎交替执行同步块时提高性能。 主要目的： 在没有多线程竞争的前提下，通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗，说白了先自旋再阻塞。 升级时机： 当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁</p><p>锁标志位：00</p><p><strong>轻量锁流程（同偏向锁）</strong><br>偏向锁由线程A持有，线程B进行CAS操作试图获取锁。<br>锁获取失败，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。</p><p>自旋次数<br>java6之前，默认启用，默认情况下自旋的次数是10次<code>-XX:PreBlockSpin=10</code>来修改，或者自旋线程数超过cpu核数一半<br>Java6之后自适应，自适应意味着自旋的次数不是固定不变的，而是根据：同一个锁上一次自旋的时间，拥有锁线程的状态来决定。</p><p><strong>轻量锁与偏向锁的区别</strong><br>争夺轻量级锁失败时，自旋尝试抢占锁。轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>有大量的线程参与锁的竞争，冲突性很高</p><p>锁标识位：10</p><img src="/2022/08/11/juc-xue-xi-bi-ji/016.png" class=""><p><strong>三种锁对比</strong></p><img src="/2022/08/11/juc-xue-xi-bi-ji/017.png" class=""><p>synchronized锁升级过程总结：一句话，就是先自旋，不行再阻塞。 实际上是把之前的悲观锁(重量级锁)变成在一定条件下使用偏向锁以及使用轻量级(自旋锁CAS)的形式</p><p>synchronized内部实现还是基于对象头的MarkWord来实现的。 JDK1.6之后拥有了无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁的升级过程，而不是无论什么情况都使用重量级锁。</p><ul><li>偏向锁:适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法/代码块则使用偏向锁。 </li><li>轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)， 存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法/代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。</li><li>重量级锁：适用于竞争激烈的情况，如果同步方法/代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。</li></ul><h2 id="JIT锁优化"><a href="#JIT锁优化" class="headerlink" title="JIT锁优化"></a>JIT锁优化</h2><p>JIT：Just In Time Compiler，即时编译器</p><ol><li><p>锁消除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁消除</span></span><br><span class="line"><span class="comment"> * 从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用，</span></span><br><span class="line"><span class="comment"> * 极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockClearUPDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();<span class="comment">//正常的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//锁消除,JIT会无视它，synchronized(对象锁)不存在了。不正常的</span></span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----hello LockClearUPDemo&quot;</span>+<span class="string">&quot;\t&quot;</span>+o.hashCode()+<span class="string">&quot;\t&quot;</span>+objectLock.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LockClearUPDemo demo = <span class="keyword">new</span> LockClearUPDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                demo.m1();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>锁粗化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁粗化</span></span><br><span class="line"><span class="comment"> * 假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块，</span></span><br><span class="line"><span class="comment"> * 加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBigDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;11111&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;22222&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;33333&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;44444&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;55555&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;66666&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p><strong>volatile内存语义</strong></p><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中。</li><li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量</li><li>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取</li></ul><h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><p>JMM中规定</p><ul><li>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的,因此不存在竞争问题</li><li>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本</li><li>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量</li><li>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成</li></ul><img src="/2022/08/11/juc-xue-xi-bi-ji/018.jpg" class=""><p>多线程环境下的问题<br>可能有线程对共享变量的修改没有即时更新到主内存，或者线程没能够即时将共享变量的最新值同步到工作内存中，从而使得线程在使用共享变量的值时，该值并不是最新的。因此出现了变量的不可见性问题。</p><p><code>volatile</code>的出现是为了解决变量在线程间的可见性问题</p><p>解决可见性的几种方案<br><strong>方案1：加锁synchronized</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * main 方法作为一个主线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">      <span class="comment">// 开启线程</span></span><br><span class="line">      myThread.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 主线程执行</span></span><br><span class="line">      <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (myThread) &#123;</span><br><span class="line">              <span class="keyword">if</span> (myThread.isFlag()) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;主线程访问到 flag 变量&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改变量值</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;flag = &quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么加锁后就保证了变量的内存可见性了?</p><ol><li>因为当一个线程进入synchronizer代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本<br>2． 将修改后的副本值刷新到主内存中，执行代码，最后线程释放锁</li></ol><p><strong>方案2：volatile修饰共享变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变量的内存可见性例子</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * main 方法作为一个主线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 开启线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myThread.isFlag()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;有点东西&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改变量值</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;flag = &quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Volatile做了啥?<br>使用volatile修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过CPU<strong>总线嗅探机制</strong>告知其他线程该变量副本已经失效，需要重新从主内存中读取。<br>volatile保证了不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。</p><h2 id="总线嗅探机制"><a href="#总线嗅探机制" class="headerlink" title="总线嗅探机制"></a>总线嗅探机制</h2><p>由于CPU与内存之间加入了缓存，在进行数据操作时，先将数据从内存拷贝到缓存中，CPU直接操作的是缓存中的数据。但在多处理器下，将可能导致各自的缓存数据不一致(这也是可见性问题的由来)，为了保证各个处理器的缓存是一致的，就会实现缓存—致性协议，而嗅探是实现缓存一致性的常见机制。<br>注意，缓存的一致性问题，不是多处理器导致，而是多缓存导致的。</p><img src="/2022/08/11/juc-xue-xi-bi-ji/019.png" class=""><p><strong>嗅探机制工作原理</strong><br>每个处理器通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。</p><p><strong>总线风暴</strong><br>基于CPU缓存一致性协议，JVM实现了volatile的可见性，但由于总线嗅探机制，会不断的监听总线，如果大量使用volatile会引起总线风暴。所以，volatile的使用要适合具体场景。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><strong>volatile的原子性问题</strong><br>volatile无法保证原子性</p><ul><li>在多线程环境下，volatile 关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性。即多线程环境下，使用volatile修饰的变量是线程不安全的。要解决这个问题，我们可以使用锁机制，或者使用原子类(如AtomicInteger)</li><li>对任意单个使用volatile修饰的变量的读/写是具有原子性，但类似于flag = !flag这种复合操作不具有原子性。简单地说就是，<strong>单纯的赋值操作是原子性的</strong></li></ul><p>示例<br>变量<code>i</code>由<code>volatile</code>修饰，<code>i++</code>操作并不是原子操作，分以下三步：</p><ol><li>从主内存读</li><li>加操作</li><li>写到主内存</li></ol><p>因为i++不是原子操作，多线程下可能有几种情况:</p><ol><li>i =1;没有其他线程干扰 i+1=2，结果正确</li><li>其他线程先执行i+1，现在i=2，因为线程的可见性，i+1=3，最后的结果为3，结果正确</li><li>其他线程执行了i+1，i=2，但是此时恰好是i+1已经读取过，生产中间值2，此时赋值后i=2，结果错误因此,volatile并不能保证变量的原子性</li></ol><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumber</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileNoAtomicDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyNumber myNumber = <span class="keyword">new</span> MyNumber();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myNumber.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + myNumber.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从i++的字节码角度说明</p><img src="/2022/08/11/juc-xue-xi-bi-ji/021.png" class=""><p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        i++; <span class="comment">//不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分3步完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败。因此对于add方法必须使用synchronized修饰，以便保证线程安全</p><p>多线程环境下，”数据计算”和”数据赋值”操作可能多次出现，即操作非原子。若数据在加载之后，若主内存count变量发生修改之后，由于线程工作内存中的值在此前已经加载，从而不会对变更操作做出相应变化，即私有内存和公共内存中变量不同步，进而导致数据不一致</p><p>对于volatile变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也就是数据加载时是最新的。</p><p>小结</p><ul><li>没使用<code>volatile</code>前，多线程间会发生线程A执行<code>i++</code>，而线程B对A的操作结果不知晓，进行了一次重复的操作，<code>i</code>最终只+1</li><li>使用<code>volatile</code>后，解决了之前重复操作的问题，但是仍然有可能别的原因导致<code>i</code>最终只+1。原因是由于<code>i++</code>并非原子操作，可能在两个子操作的间隙之间，如<code>+1</code>操作和<code>写入主内存</code>之间，线程B执行了<code>从主内存中读i</code>，结果线程B读到的值是旧的，最总结果仍只+1</li><li>可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改共享变量的场景必须使用加锁同步</li><li>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然要通过加锁(使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性:<ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ul></li></ul><h2 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h2><p><strong>指令重排序</strong><br>为了提高性能，编译器和处理器常常会对既定的代码进行指令重排序</p><img src="/2022/08/11/juc-xue-xi-bi-ji/020.jpg" class=""><p>一般重排序可以分为如下三种:</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的</li></ul><p><strong>as-if-serial</strong><br>即不管怎么重排序，单线程下的执行结果不能被改变。编译器、runtime和处理器都必须遵守asif-serial语义</p><p><strong>happens-before</strong><br>并发编程下指令重排序同样也会会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。从JDK5开始，提出了happens-before的概念，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间</p><p><strong>规则如下</strong></p><ol><li><p>次序规则<br>一个线程内,按照代码顺序,写在前面的操作先行发生于写在后面的操作(强调的是一个线程)<br>前一个操作的结果可以被后续的操作获取。将白点就是前面一个操作把变量X赋值为1,那后面一个操作肯定能知道X已经变成了1</p></li><li><p>锁定规则<br>一个unlock操作先行发生于后面((这里的”后面”是指时间上的先后))对同一个锁的lock操作(上一个线程unlock了,下一个线程才能获取到锁,进行lock)</p></li><li><p>volatile变量规则<br>对一个volatile变量的写操作先行发生于后面对这个变量的读操作,前面的写对后面的读是可见的,这里的”后面”同样是指时间是的先后</p></li><li><p>传递规则<br>如果操作A先行发生于操作B,而操作B又先行发生于操作C,则可以得出A先行发生于操作C</p></li><li><p>线程启动规则(Thread Start Rule)<br>Thread对象的start( )方法先行发生于线程的每一个动作</p></li><li><p>线程中断规则(Thread Interruption Rule)</p></li></ol><ul><li>对线程interrupt( )方法的调用先发生于被中断线程的代码检测到中断事件的发生</li><li>可以通过Thread.interrupted( )检测到是否发生中断</li></ul><ol start="7"><li><p>线程终止规则(Thread Termination Rule)<br>(线程中的所有操作都先行发生于对此线程的终止检测)</p></li><li><p>对象终结规则(Finalizer Rule)<br>对象没有完成初始化之前,是不能调用finalized( )方法的</p></li></ol><p><strong>单例双重检验+volatile</strong><br>双重检验锁+volatile</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile 保证可见性和禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 同步代码块</span></span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">              <span class="comment">// 第二次检查</span></span><br><span class="line">              <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 对象的实例化是一个非原子性操作</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中,new Singleton()是一个非原子性操作，对象实例化分为三步操作:</p><ol><li>a：分配内存空间</li><li>b：初始化实例</li><li>c：返回内存地址给引用</li></ol><ul><li>当两个线程A和B同时进入方法时，加入A抢夺到锁，则A继续执行，当A执行到new操作时，由于new操作不是原子操作，且synchronized也不能禁止重排序</li><li>不禁止重排序的情况下可能是：a-c-b，当线程A执行a-c，即将执行b的时候，由于cpu时间片结束，则有可能会让步给线程B</li><li>线程B进行第一次判断，singleton由于已经有了内存指向，并不为空，此时，对象还没有执行初始化，但已经判断为true，并且返回了</li></ul><p>此时，就产生了严重的错误，因此需要 volatile 来禁止重排序。<br>PS：不能将<code>new</code>操作类比<code>i++</code>操作，需要JVM知识支撑。</p><p><strong>为什么<code>volatile</code>能禁止指令重排序呢</strong><br>答案：内存屏障。java编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>禁止重排序规则表</p><img src="/2022/08/11/juc-xue-xi-bi-ji/022.jpg" class=""><ul><li>当第一个操作为volatile读时不论第二个操作是什么,都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前</li><li>当第二个操作为volatile写时,不论第一个操作是什么,都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后</li><li>当第一个操作为volatile写时,第二个操作为volatile读时,不能重排(写后读)</li></ul><p><strong>4种内存屏障指令</strong></p><img src="/2022/08/11/juc-xue-xi-bi-ji/023.jpg" class=""><h1 id="异步Future"><a href="#异步Future" class="headerlink" title="异步Future"></a>异步Future</h1><p>Future可以理解为未来任务，异步任务。</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException</span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3秒钟后才出来结果，还没有计算你提前来拿(只要一调用get方法，对于结果就是不见不散，会导致阻塞)</span></span><br><span class="line">        <span class="comment">//System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+futureTask.get());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3秒钟后才出来结果，我只想等待1秒钟，过时不候</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+futureTask.get(<span class="number">1L</span>,TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; run... here&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>直接调用<code>get()</code>方法，会造成线程阻塞，直至计算完成</li><li>使用<code>get(1L,TimeUnit.SECONDS)</code>方法，如果在指定时间内线程计算完成，则返回结果，否则过时不候</li></ul><p>问题：线程完成计算的时间是不确定的，如何以不阻塞的方式拿到线程结果呢？<br>答案：轮询——while+isDone()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>+ ThreadLocalRandom.current().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;线程完成任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(futureTask.isDone())&#123;</span><br><span class="line">                System.out.println(futureTask.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，轮询会耗费CPU资源</p><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><code>CompletableFuture</code>是对Future功能的拓展，简化异步编程的复杂性，功能非常强大。</p><p><strong>核心静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.runAsync 无 返回值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable,Executor executor)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//2.supplyAsync 有 返回值</span></span></span><br><span class="line"><span class="function"><span class="comment">//没有指定Executor的方法，直接使用默认的ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>Demo<br>无返回值<br>（<code>get()</code>和<code>join()</code>区别：get会抛出异常，join不会）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;-----come in&quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----task is over&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span>&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----come in&quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回调方法</strong><br>从Java8开始引入了CompletableFuture，是Future的功能增强版，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----come in&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> result = ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----计算结束耗时1秒钟，result： &quot;</span>+result);</span><br><span class="line">            <span class="keyword">if</span>(result &gt; <span class="number">6</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;).whenComplete((v,e) -&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(e == <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----result: &quot;</span>+v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----exception: &quot;</span>+e.getCause()+<span class="string">&quot;\t&quot;</span>+e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">44</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:暂停3秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>whenComplete：负责运行正常的情况</p><ul><li>whenComplete：当前线程执行任务，等待任务执行完后继续执行whenComplete任务</li><li>whenCompleteAsync：当前线程任务执行完后将whenCompleteAsync任务交给线程池中其他线程执行（如果是使用同一线程池，也可能会被交由当前线程执行）</li></ul><p>exceptionally：负责出现异常的情况</p><p>handle：whenComplete和exceptionally的结合版。方法执行后的处理，无论成功与失败都可处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法执行完成后的处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">      CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">          System.out.println(<span class="string">&quot;CompletableFuture...&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">10</span>/<span class="number">1</span>;</span><br><span class="line">      &#125;, service).handle((t,u)-&gt;&#123; <span class="comment">// R apply(T t, U u);</span></span><br><span class="line">          System.out.println(<span class="string">&quot;handle:&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (t != <span class="keyword">null</span>)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;存在返回结果:&quot;</span> + t);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (u != <span class="keyword">null</span>)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;存在日常:&quot;</span> + u);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">      Integer integer = completableFuture2.get();</span><br><span class="line">      System.out.println(integer);</span><br></pre></td></tr></table></figure><h3 id="线程串行化"><a href="#线程串行化" class="headerlink" title="线程串行化"></a>线程串行化</h3><p>即让多线程之间有序执行</p><p>thenRun：不能获取到上一步的执行结果，无返回值<br>thenAccept：能接受上一步结果，无返回值<br>thenApply：能接受上一步结果，有返回值<br>（带后缀Async表示会将任务交给线程池中的其他线程去处理）</p><p>thenApply<br>thenApplyAsync有重载版本，可以指定执行异步任务的线程池，如果不指定，默认使用ForkJoinPool.commonPool()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.2</span>;</span><br><span class="line">        &#125;,pool);</span><br><span class="line">        <span class="comment">//cf关联的异步任务的返回值作为方法入参，传入到thenApply的方法中</span></span><br><span class="line">        <span class="comment">//thenApply这里实际创建了一个新的CompletableFuture实例</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf2=cf.thenApply((result)-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;test:&quot;</span>+result;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread start cf.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//等待子任务执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;run result-&gt;&quot;</span>+cf.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread start cf2.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;run result-&gt;&quot;</span>+cf2.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread exit,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>thenRun、thenAccept</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.2</span>;</span><br><span class="line">        &#125;,pool);</span><br><span class="line">        <span class="comment">//cf关联的异步任务的返回值作为方法入参，传入到thenApply的方法中</span></span><br><span class="line">        CompletableFuture cf2=cf.thenApply((result)-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;test:&quot;</span>+result;</span><br><span class="line">        &#125;).thenAccept((result)-&gt; &#123; <span class="comment">//接收上一个任务的执行结果作为入参，但是没有返回值</span></span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job3,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job3,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125;).thenRun(()-&gt;&#123; <span class="comment">//无入参，也没有返回值</span></span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job4,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thenRun do something&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job4,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread start cf.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//等待子任务执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;run result-&gt;&quot;</span>+cf.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread start cf2.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//cf2 等待最后一个thenRun执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;run result-&gt;&quot;</span>+cf2.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread exit,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="组合处理"><a href="#组合处理" class="headerlink" title="组合处理"></a>组合处理</h3><p><strong>thenCombine、thenAcceptBoth、runAfterBoth</strong><br>将两个CompletableFuture组合起来，只有这两个都正常执行完了才会执行某个任务。注意两个任务中只要有一个执行异常，则将该异常信息作为指定任务的执行结果。</p><ul><li>thenCombine：会将两个任务的执行结果作为方法入参传递到指定方法中，且该方法有返回值</li><li>thenAcceptBoth：同样将两个任务的执行结果作为方法入参，但是无返回值</li><li>runAfterBoth：没有入参，也没有返回值</li></ul><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cf2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//cf和cf2的异步任务都执行完成后，会将其执行结果作为方法入参传递给cf3,且有返回值</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf3=cf.thenCombine(cf2,(a,b)-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job3,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            System.out.println(<span class="string">&quot;job3 param a-&gt;&quot;</span>+a+<span class="string">&quot;,b-&gt;&quot;</span>+b);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job3,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//cf和cf2的异步任务都执行完成后，会将其执行结果作为方法入参传递给cf3,无返回值</span></span><br><span class="line">        CompletableFuture cf4=cf.thenAcceptBoth(cf2,(a,b)-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job4,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            System.out.println(<span class="string">&quot;job4 param a-&gt;&quot;</span>+a+<span class="string">&quot;,b-&gt;&quot;</span>+b);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job4,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//cf4和cf3都执行完成后，执行cf5，无入参，无返回值</span></span><br><span class="line">        CompletableFuture cf5=cf4.runAfterBoth(cf3,()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job5,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;cf5 do something&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job5,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;main thread start cf.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//等待子任务执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf run result-&gt;&quot;</span>+cf.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread start cf5.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;cf5 run result-&gt;&quot;</span>+cf5.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread exit,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>applyToEither、acceptEither、runAfterEither</strong><br>将两个CompletableFuture组合起来，只要其中一个执行完了就会执行某个任务。注意两个任务中只要有一个执行异常，则将该异常信息作为指定任务的执行结果。</p><ul><li>applyToEither：会将已经执行完成的任务的执行结果作为方法入参，并有返回值</li><li>acceptEither：同样将已经执行完成的任务的执行结果作为方法入参，但是没有返回值</li><li>runAfterEither：没有方法入参，也没有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cf2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//cf和cf2的异步任务都执行完成后，会将其执行结果作为方法入参传递给cf3,且有返回值</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf3=cf.applyToEither(cf2,(result)-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job3,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            System.out.println(<span class="string">&quot;job3 param result-&gt;&quot;</span>+result);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job3,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//cf和cf2的异步任务都执行完成后，会将其执行结果作为方法入参传递给cf3,无返回值</span></span><br><span class="line">        CompletableFuture cf4=cf.acceptEither(cf2,(result)-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job4,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            System.out.println(<span class="string">&quot;job4 param result-&gt;&quot;</span>+result);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job4,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//cf4和cf3都执行完成后，执行cf5，无入参，无返回值</span></span><br><span class="line">        CompletableFuture cf5=cf4.runAfterEither(cf3,()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job5,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;cf5 do something&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job5,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;main thread start cf.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//等待子任务执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf run result-&gt;&quot;</span>+cf.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread start cf5.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;cf5 run result-&gt;&quot;</span>+cf5.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread exit,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>thenCompose</strong><br>thenCompose()：会在某个任务执行完成后，将该任务的执行结果作为方法入参然后执行指定的方法，该方法会返回一个新的CompletableFuture实例，如果该CompletableFuture实例的result不为null，则返回一个基于该result的新的CompletableFuture实例；如果该CompletableFuture实例为null，则然后执行这个新任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">    CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread()+<span class="string">&quot; start job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread()+<span class="string">&quot; exit job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; cf2= cf.thenCompose((param)-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread()+<span class="string">&quot; start job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread()+<span class="string">&quot; exit job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job3,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job3,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;job3 test&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;main thread start cf.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    <span class="comment">//等待子任务执行完成</span></span><br><span class="line">    System.out.println(<span class="string">&quot;cf run result-&gt;&quot;</span>+cf.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;main thread start cf2.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    System.out.println(<span class="string">&quot;cf2 run result-&gt;&quot;</span>+cf2.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;main thread exit,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>allOf、anyOf</strong></p><ul><li>allOf返回的CompletableFuture是多个任务都执行完成后才会执行，只有有一个任务执行异常，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回null</li><li>anyOf返回的CompletableFuture是多个任务只要其中一个执行完成就会执行，其get返回的是已经执行完成的任务的执行结果，如果该任务执行异常，则抛出异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job1,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cf2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job2,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cf3 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start job3,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;test&quot;);</span></span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; exit job3,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2.2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//allof等待所有任务执行完成才执行cf4，如果有一个任务异常终止，则cf4.get时会抛出异常，都是正常执行，cf4.get返回null</span></span><br><span class="line">        <span class="comment">//anyOf是只有一个任务执行完成，无论是正常执行或者执行异常，都会执行cf4，cf4.get的结果就是已执行完成的任务的执行结果</span></span><br><span class="line">        CompletableFuture cf4=CompletableFuture.allOf(cf,cf2,cf3).whenComplete((a,b)-&gt;&#123;</span><br><span class="line">           <span class="keyword">if</span>(b!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;error stack trace-&gt;&quot;</span>);</span><br><span class="line">               b.printStackTrace();</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;run succ,result-&gt;&quot;</span>+a);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;main thread start cf4.get(),time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//等待子任务执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf4 run result-&gt;&quot;</span>+cf4.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread exit,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><p>分支合并，将一个大任务，进行拆分(fork)成若干个小任务(拆到给出的临界值为止)，再将一个个的小任务运算的结果进行join汇总</p><p><strong>工作窃取模式</strong><br>工作窃取模式(work-stealing):当执行新的任务时它可以将其拆分成更小的任务执行，并将小任务加到线程队列中，当没有任务执行时，再从一个随机线程的队列中偷一个并把它放在自己的队列中<br>相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行那么该线程会处于等待状态。而在forkfjoin框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题(窃取过来)来执行，这种方式减少了线程的等待时间，提高了性能</p><img src="/2022/08/11/juc-xue-xi-bi-ji/029.png" class=""><p><strong>ForkJoinTask实现类</strong></p><img src="/2022/08/11/juc-xue-xi-bi-ji/030.png" class=""><ol><li>RecursiveTask：有返回值的递归任务</li><li> RecursiveAction：无返回值的递归事件</li></ol><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求和计算的任务！</span></span><br><span class="line"><span class="comment"> * 3000   6000（ForkJoin）  9000（Stream并行流）</span></span><br><span class="line"><span class="comment"> * // 如何使用 forkjoin</span></span><br><span class="line"><span class="comment"> * // 1、forkjoinPool 通过它来执行</span></span><br><span class="line"><span class="comment"> * // 2、计算任务 forkjoinPool.execute(ForkJoinTask task)</span></span><br><span class="line"><span class="comment"> * // 3. 计算类要继承 ForkJoinTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> Long end;    <span class="comment">// 1990900000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界值</span></span><br><span class="line">    <span class="keyword">private</span> Long temp = <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((end-start)&lt;temp)&#123;</span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// forkjoin 递归</span></span><br><span class="line">            <span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>; <span class="comment">// 中间值</span></span><br><span class="line">            ForkJoinDemo task1 = <span class="keyword">new</span> ForkJoinDemo(start, middle);</span><br><span class="line">            task1.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line">            ForkJoinDemo task2 = <span class="keyword">new</span> ForkJoinDemo(middle+<span class="number">1</span>, end);</span><br><span class="line">            task2.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.DoubleStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同一个任务，别人效率高你几十倍！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// test1(); // 12224</span></span><br><span class="line">        <span class="comment">// test2(); // 10038</span></span><br><span class="line">        <span class="comment">// test3(); // 153</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通程序员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Long i = <span class="number">1L</span>; i &lt;= <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot; 时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会使用ForkJoin</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinDemo(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);<span class="comment">// 提交任务</span></span><br><span class="line">        Long sum = submit.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot; 时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Stream并行流 ()  (]</span></span><br><span class="line">        <span class="keyword">long</span> sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+<span class="string">&quot;时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LockSupport与线程中断"><a href="#LockSupport与线程中断" class="headerlink" title="LockSupport与线程中断"></a>LockSupport与线程中断</h1><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>Java不提倡强中中断其他线程，线程只能自行中断。</p><p>中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。若要中断一个线程，需要手动调用该线程的interrupt方法，但该方法也仅仅是将线程对象的中断标识设成true；接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断， 此时究竟该做什么需要你自己写代码实现。</p><p>每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设为true；可以在别的线程中调用，也可以在自己的线程中调用</p><p>Thread线程中断相关API</p><ul><li>public void interrupt()：实例方法，仅仅是设置线程的中断状态为true，不会停止线程</li><li>public static boolean interrupted()：静态方法<ul><li>判断线程是否被中断，并清除当前中断状态。这个方法做了两件事：<ul><li>1 返回当前线程的中断状态</li><li>将当前线程的中断状态设为false</li></ul></li></ul></li></ul><p>具体来说，当对一个线程，调用interrupt()时:<br>如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以，interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行。<br>②如果线程处于被阻塞状态（例如处于sleep, wait, join等状态)，在别的线程中调用当前线程对象的linterrupt方法<br>那么<br>线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。</p><p>Demo<br>使用<code>volatile</code>实现线程中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isStop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isStop)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程------isStop = true,自己退出了&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;-------hello interrupt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    isStop = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo<br>通过原子类<code>AtomicBoolean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(atomicBoolean.get())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        atomicBoolean.set(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo<br>通过<code>Thread</code>相关API实现线程中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----t1 线程被中断了，break，程序结束&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**************&quot;</span>+t1.isInterrupted());</span><br><span class="line">        <span class="comment">//暂停5毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;**************&quot;</span>+t1.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。</p><p><strong>线程等待唤醒</strong></p><ol><li><p>使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程<br>wait和notify方法必须要在同步块或者方法里面，且成对出现使用，先wait后notify才OK</p></li><li><p>使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;start&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;通知了&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>lock、unlock对里面才能正确调用调用condition中线程等待和唤醒的方法，先await后signal。</p><ol start="3"><li>LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-20 16:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----come in&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>无需使用锁块(synchronized或者lock)</li><li>等待唤醒顺序谁先谁后无所谓，都不会报错，正常执行</li></ul><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>线程变量：每个线程都有属于自己的独立变量。</p><p><strong>原理分析</strong><br>线程类Thread的一个对象属性<code>threadLocals</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Thread类</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure><p>实际上线程变量存储在该<code>threadLocals</code>，而<code>ThreadLocal</code>是一个提供操作该属性的中间人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">T result = (T)e.value;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">map.set(<span class="keyword">this</span>, value);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map.set(this, value)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);<span class="comment">//获取ThreadLocal的哈希码，也即在数组tab中的下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从下标i向后检查</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;<span class="comment">//覆盖变量原有值</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;<span class="comment">//直接赋新值</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该下标i处还没有设置变量，直接new一个Entry对象</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry类：ThreadLocal类的静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Entry</code>继承了<code>WeakReference</code>，实现弱引用。</p><p><strong>为什么要用弱引用?不用如何？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadLocal tl = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();    <span class="comment">//line1</span></span><br><span class="line">    tl.set(<span class="number">2021</span>);                                   <span class="comment">//line2</span></span><br><span class="line">    tl.get();                                       <span class="comment">//line3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//line1新建了一个ThreadLocal对象，t1 是强引用指向这个对象；</span></span><br><span class="line"><span class="comment">//line2调用set()方法后新建一个Entry，通过源码可知Entry对象里的k是弱引用指向这个对象。</span></span><br></pre></td></tr></table></figure><p>当<code>function01</code>方法执行完毕后，栈帧销毁强引用<code>tl</code>也就没有了。但此时线程的<code>ThreadLocalMap</code>里某个<code>entry</code>的<code>key</code>引用还指向这个对象,若这个<code>key</code>引用是强引用，就会导致<code>key</code>指向的<code>ThreadLocal</code>对象及v指向的对象不能被gc回收，造成内存泄漏；若这个key引用是弱引用就大概率会减少内存泄漏的问题(还有一个key为null的雷)。使用弱引用，就可以使ThreadLocal对象在方法执行完毕后顺利被回收且Entry的key引用指向为null。</p><p>此后我们调用get,set或remove方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存。<br>在源码中，对<code>ThreadMap</code>进行<code>set</code>、<code>get</code>等操作时，会检查为<code>null</code>的<code>key</code>，进行垃圾回收。</p><p><strong>弱引用就万事大吉了吗？</strong><br>当我们为threadLocal变量赋值，实际上就是当前的Entry(threadLocal实例为key，值为value)往这个threadLocalMap中存放。Entry中的key是弱引用，当threadLocal外部强引用被置为null(tl=null),那么系统 GC 的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p><p>当然，如果当前thread运行结束，threadLocal，threadLocalMap,Entry没有引用链可达，在垃圾回收的时候都会被系统进行回收。</p><p>但在实际使用中我们有时候会用线程池去维护我们的线程，比如在Executors.newFixedThreadPool()时创建线程的时候，为了复用线程是不会结束的，所以threadLocal内存泄漏就值得我们小心</p><p><strong>补充知识点：Java中四种引用</strong></p><ol><li>强引用（默认）<br>当内存不足JVM开始垃圾回收,对于强引用的对象,就算是出现了OOM也不会对该对象进行回收,机器死了都不收。</li></ol><p>强引用是我们最常见的普通对象引用,只要还有强引用指向一个对象,就能表明对象还“活着”,垃圾收集器不会碰这种对象。在Java中最常见的就是强引用,把一个对象赋给一个引用变量这个引用变量就是一个强引用。当一个对象被强引用变量引用时,它处于可达状态,它是不可能被垃圾回收机制回收的,即使该对象以后永远都不会被用到,JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。</p><p>对于一个普通的对象.如果没有其他的引用关系只要超过了引用的作用域或者显式地将相应(强)引用赋值为null一般认为才是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略).</p><ol start="2"><li>软引用<br>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</li></ol><p>对于只有软引用的对象来说，当系统内存充足时它 不会被回收，当系统内存不足时它会被回收。</p><p>软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！</p><ol start="3"><li>弱引用<br>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。</li></ol><p>软引用和弱引用的适用场景</p><p>假如有一个应用需要读取大量的本地图片:</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能</li><li>如果一次性全部加载到内存中又可能造成内存溢出。</li></ul><p>此时使用软引用可以解决这个问题。<br>设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br></pre></td></tr></table></figure><ol start="4"><li>虚引用<br>虚引用需要java.lang.ref.PhantomReference类来实现。</li></ol><p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列 (ReferenceQueue)联合使用。</p><p>虚引用的主要作用是跟踪对象被垃圾回收的状态。 仅仅是提供了一种确保对象被 finalize以后，做某些事情的机制。 PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。</p><p>其意义在于：说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p><p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理</p><p><strong>内存泄漏</strong><br>不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p><strong>Lock和synchronized区别</strong></p><ul><li>Lock接口方式需要手动进行锁的获取和释放，是显式锁；使用synchronized时，锁获取和释放是JVM自动完成的，是隐式锁</li><li>使用synchronized在发生异常时，锁会自动被释放，而Lock则不会（通常会在finally块中进行锁的手动释放）</li><li>Lock能使等待的线程响应中断，但synchronized不行</li><li>Lock可以知道有无成功获取锁，synchronized不行</li><li>Lock可以提高多个线程进行读操作的效率，当竞争资源非常激烈时，Lock的性能要优于synchronized</li></ul><h2 id="AQS介绍"><a href="#AQS介绍" class="headerlink" title="AQS介绍"></a>AQS介绍</h2><p>AQS：AbstractQueuedSynchronizer，抽象队列同步器。</p><img src="/2022/08/11/juc-xue-xi-bi-ji/031.jpg" class=""><p>AQS中的队列是CLH变体的虚拟双向队列FIFO<br>（CLH : Craig.Landin and Hagersten队列，是一个单向链表）</p><p><strong>为什么使用双向队列？</strong><br>抢到资源的线程直接使用处理业务，则抢不到资源的必然涉及一种排队等候机制。抢占资源失败的线程继续去等待，那么就一定会有某种队列形成，这样的队列是什么数据结构呢?<br>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的结点对象(Node),通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态,使并发达到同步的效果。</p><img src="/2022/08/11/juc-xue-xi-bi-ji/032.jpg" class=""><h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><p>以可重入<code>ReentrantLock</code>举例说明</p><p>进入<code>reentrantLock.lock()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">reentrantLock.lock();</span><br></pre></td></tr></table></figure><p>发现调用的是<code>sync.lock()</code></p><img src="/2022/08/11/juc-xue-xi-bi-ji/034.jpg" class=""><p>lock方法的真正是由其子类<code>FairSync</code>和<code>NonfairSync</code>实现的，以下是其继承关系</p><img src="/2022/08/11/juc-xue-xi-bi-ji/035.jpg" class=""><p>非公平锁<code>NonfairSync</code>和公平锁<code>FairSync</code>代码如下，可以发现非公平多了一步<code>if</code>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/11/juc-xue-xi-bi-ji/036.jpg" class=""><img src="/2022/08/11/juc-xue-xi-bi-ji/037.jpg" class=""><p>接下来以非公平锁来进行分析</p><p>首先介绍队列中的节点结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">/** 线程被取消了 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">    <span class="comment">/** 后续线程需要唤醒 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">/** 等待condition唤醒 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate the next acquireShared should unconditionally propagate */</span></span><br><span class="line">    <span class="comment">/** 共享式同步状态获取将会无条件的传播下去 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始为0，状态就是以上几种</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The thread that enqueued this node.  Initialized on construction and nulled out after use. */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">     * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">     * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">     * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">     * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">     * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">     * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">     * mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">     * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">     * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点属性说明</p><img src="/2022/08/11/juc-xue-xi-bi-ji/033.jpg" class=""><p>state属性：AbstractQueuedSynchronizer#state</p><ul><li>0：表示<code>执行窗口</code>空闲，可以占用</li><li>1：表示有线程在占用<code>执行窗口</code></li><li><blockquote><p>1：如果是可重入锁，则表示重入次数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure></li></ul><h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><p>非公平锁<code>lock</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//compareAndSetState(0, 1)：如果state为0，则将state修改为1（即如果执行窗口空闲，则将状态修改为占用），成功返回true，失败返回false</span></span><br><span class="line"><span class="comment">//setExclusiveOwnerThread(Thread.currentThread())：将当前线程设置为执行窗口独占线程</span></span><br></pre></td></tr></table></figure><p><strong>情况一：执行窗口空闲，则当前线程直接占用窗口，不用进入到队列中等待</strong><br>进入<code>setExclusiveOwnerThread()</code>方法，在这里可以知晓<code>执行窗口</code>实际上就是<code>AbstractOwnableSynchronizer</code>的<code>exclusiveOwnerThread</code>属性。<br>公平锁FairSync和非公平锁NonfairSync都是其子类，继承了该属性，由于是对象属性，所以每一把锁都有一个<code>执行窗口</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3737899427754241961L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractOwnableSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>情况二：如果执行窗口被占用，则进入<code>acquire(1)</code>，入队等待</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>if</code>判断中，会执行<code>tryAcquire(arg)</code>再次尝试占用<code>执行窗口</code>，如果不成功则再加入到队列中。</p><p>非公平锁NonfairSync重写了<code>AbstractQueuedSynchronizer</code>的<code>tryAcquire()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Sync的nonfairTryAcquire(int acquires)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">//获得执行窗口状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//窗口空闲，尝试占用窗口</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//窗口被占用，但是占用线程为当前线程</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//可重入锁的重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//窗口被占用，且不是当前线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试再次占用窗口失败后，执行<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;<span class="comment">//队列尾节点不为空，则将当前线程设为尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列，并将当前线程插入到队尾（当pred为null时，只会执行一次）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))<span class="comment">//尾节点为空，则初始化队列，new Node(),头节点是一个虚节点（哨兵节点）</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//尾节点不为空，再次尝试将当前线程设为尾节点（这一步其实在addWaiter中已经出现一次了，出现两次可能类似双重null校验）</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作用大概是检阅队列，设置节点状态</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取前节点，final修饰不可变</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//前节点是否为头节点，true则尝试当前线程占用窗口（因为头节点为虚节点，此时队列中实际只有当前线程），当占用线程释放锁时，唤醒此线程时才会进入if代码块</span></span><br><span class="line">                setHead(node);<span class="comment">//当前线程占用窗口后，将其设为头节点（由于节点线程已占用窗口，此头节点也可视为虚节点）</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC（帮助GC垃圾回收）</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)<span class="comment">//true，需要取消节点</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>shouldParkAfterFailedAcquire(p, node)</code>：修改队列中的节点及节点状态<br><code>parkAndCheckInterrupt()</code>：将当前线程挂起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简而言之，Node#waitStatus的值</span></span><br><span class="line"><span class="comment">//0：正常同步节点的值</span></span><br><span class="line"><span class="comment">//SIGNAL（-1）：表示此节点的后节点已被（或将要）被阻塞（通过`LockSupport.park()`方法），未完待续</span></span><br><span class="line"><span class="comment">//CANCELLED（1）：表示此节点被取消</span></span><br><span class="line"><span class="comment">//CONDITION（-2）：条件节点，目前不会作为被视作为同步节点，直到状态被改为`0`</span></span><br><span class="line"><span class="comment">//PROPAGATE（-3）：传播节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"><span class="comment">//该节点已经设置了状态，要求释放以发出信号，因此它可以安全地停放</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//前节点被取消，循环向前直至找到未取消的节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//waitStatus 必须为 0 或 PROPAGATE</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下以三个线程A、B、C具体举例说明</p><p>A线程尝试获取锁时，直接占用<code>执行窗口</code></p><p>B线程尝试获取锁：A线程正在执行，窗口被占用。<br>将B线程节点加入队列，队列初始化，头节点（虚节点，ws为0），B线程节点为尾节点。<br>开始第一次进入<code>shouldParkAfterFailedAcquire</code>方法，前节点（即头节点）<code>ws</code>为<code>0</code>，进入<code>else</code>代码块将前节点状态设<code>SIGNAL</code>，返回<code>false</code>，<code>&amp;&amp;</code>右边部分此次不执行<br>由于外部循环，第二次进入方法时，直接返回<code>true</code>，开始执行<code>&amp;&amp;</code>右边部分<code>parkAndCheckInterrupt()</code>，将当前线程B挂起</p><p>线程C尝试获取锁：A线程同样正在执行，窗口被占用<br>将线程C节点加入队列，线程节点C为尾节点，前节点为线程B节点。<br>同线程B，开始第一次进入<code>shouldParkAfterFailedAcquire</code>方法，前节点线程B的<code>ws</code>为<code>0</code>，进入<code>else</code>代码块将前节点状态设<code>SIGNAL</code>，返回<code>false</code>，<code>&amp;&amp;</code>右边部分此次不执行<br>由于外部循环，第二次进入方法时，直接返回<code>true</code>，开始执行<code>&amp;&amp;</code>右边部分<code>parkAndCheckInterrupt()</code>，将当前线程C挂起<br>PS：如果前节点的<code>ws&gt;0</code>则一直向前，直至遇到<code>ws&lt;=0</code>的节点</p><p>可见后一个线程进入队列，将前一个线程节点的<code>ws</code>设为<code>SIGNAL</code>，然后线程挂起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h3><p>同样以非公平锁NonfairSync举例</p><p>unlock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>release()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">Node h = head;</span><br><span class="line"><span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryRelease(arg)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unparkSuccessor(h)：唤醒挂起的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果头节点的后节点为空或者后节点的<code>ws&gt;0</code>，则从队列的尾节点开始向前唤醒挂起的线程，直至找到当前节点（占有窗口的头节点）后的第一个<code>ws&lt;=0</code>的线程节点，唤醒此线程。前面介绍<code>lock()</code>部分的<code>parkAndCheckInterrupt()</code>时，线程会在此处挂起。</p><h2 id="ReentrantRWLock读写锁"><a href="#ReentrantRWLock读写锁" class="headerlink" title="ReentrantRWLock读写锁"></a>ReentrantRWLock读写锁</h2><p>对读写操作进行分离，分为单独的读锁和写锁。允许多个线程进行读操作，只允许一个线程进行写操作。</p><p>读写锁ReentrantReadWriteLock并不是真正意义上的读写分离，它只允许读读共存，而读写和写写依然是互斥的， 大多实际场景是“读/读”线程间并不存在互斥关系，只有”读/写”线程或”写/写”线程间的操作需要互斥的。</p><p>应用场景：在读多写少情况下，读写锁有较高性能体验。</p><p>缺点：锁饥饿问题，大量读线程执行，造成写线程长期获取不到锁的情况。</p><p>锁降级<br>遵循获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。 如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。</p><p>写锁和读锁是互斥的（这里的互斥是指线程间的互斥）当前线程可以获取到写锁又获取到读锁（锁降级），但是获取到了读锁不能继续获取写锁。这是因为读写锁要保持写操作的可见性。因为，如果允许读锁在被获取的情况下对写锁的获取，那么正在运行的其他读线程无法感知到当前写线程的操作。</p><p>因此，分析读写锁ReentrantReadWriteLock，会发现它有个潜在的问题：读锁全完，写锁有望；写锁独占，读写全堵；如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，只有等待线程都释放了读锁，当前线程才能获取写锁，也就是写入必须等待，这是一种悲观的读锁，人家还在读着那，你先别去写，省的数据乱。</p><p>分析StampedLock，会发现它改进之处在于：读的过程中也允许获取写锁介入(相当牛B，读和写两个操作也让你“共享”(注意引号))，这样会导致我们读的数据就可能不一致！所以，需要额外的方法来判断读的过程中是否有写入，这是一种乐观的读锁，O(∩_∩)O哈哈~。 显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.rwlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoResource</span> //资源类，模拟一个简单的缓存</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//=====ReentrantLock 等价于 =====synchronized，之前讲解过</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//=====ReentrantReadWriteLock 一体两面，读写互斥，读读共享</span></span><br><span class="line">    ReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key ,String value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;正在写入&quot;</span>);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            <span class="comment">//暂停毫秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;完成写入&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;正在读取&quot;</span>);</span><br><span class="line">            String result = map.get(key);</span><br><span class="line">            <span class="comment">//暂停200毫秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;完成读取&quot;</span>+<span class="string">&quot;\t&quot;</span>+result);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-08 18:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CoResource coResource = <span class="keyword">new</span> CoResource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                coResource.write(finalI +<span class="string">&quot;&quot;</span>, finalI +<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                coResource.read(finalI +<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span>正在写入</span><br><span class="line"><span class="number">1</span>完成写入</span><br><span class="line"><span class="number">3</span>正在写入</span><br><span class="line"><span class="number">3</span>完成写入</span><br><span class="line"><span class="number">4</span>正在写入</span><br><span class="line"><span class="number">4</span>完成写入</span><br><span class="line"><span class="number">2</span>正在写入</span><br><span class="line"><span class="number">2</span>完成写入</span><br><span class="line"><span class="number">5</span>正在写入</span><br><span class="line"><span class="number">5</span>完成写入</span><br><span class="line"><span class="number">6</span>正在写入</span><br><span class="line"><span class="number">6</span>完成写入</span><br><span class="line"><span class="number">7</span>正在写入</span><br><span class="line"><span class="number">7</span>完成写入</span><br><span class="line"><span class="number">8</span>正在写入</span><br><span class="line"><span class="number">8</span>完成写入</span><br><span class="line"><span class="number">9</span>正在写入</span><br><span class="line"><span class="number">9</span>完成写入</span><br><span class="line"><span class="number">10</span>正在写入</span><br><span class="line"><span class="number">10</span>完成写入</span><br><span class="line"><span class="number">1</span>正在读取</span><br><span class="line"><span class="number">1</span>完成读取<span class="number">1</span></span><br><span class="line"><span class="number">2</span>正在读取</span><br><span class="line"><span class="number">2</span>完成读取<span class="number">2</span></span><br><span class="line"><span class="number">4</span>正在读取</span><br><span class="line"><span class="number">4</span>完成读取<span class="number">4</span></span><br><span class="line"><span class="number">6</span>正在读取</span><br><span class="line"><span class="number">6</span>完成读取<span class="number">6</span></span><br><span class="line"><span class="number">5</span>正在读取</span><br><span class="line"><span class="number">5</span>完成读取<span class="number">5</span></span><br><span class="line"><span class="number">3</span>正在读取</span><br><span class="line"><span class="number">3</span>完成读取<span class="number">3</span></span><br><span class="line"><span class="number">7</span>正在读取</span><br><span class="line"><span class="number">7</span>完成读取<span class="number">7</span></span><br><span class="line"><span class="number">8</span>正在读取</span><br><span class="line"><span class="number">8</span>完成读取<span class="number">8</span></span><br><span class="line"><span class="number">9</span>正在读取</span><br><span class="line"><span class="number">9</span>完成读取<span class="number">9</span></span><br><span class="line"><span class="number">10</span>正在读取</span><br><span class="line"><span class="number">10</span>完成读取<span class="number">10</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="StampeLock邮戳锁"><a href="#StampeLock邮戳锁" class="headerlink" title="StampeLock邮戳锁"></a>StampeLock邮戳锁</h2><p>如果解决读写锁的锁饥饿问题？</p><ul><li>使用公平锁：“公平”是以牺牲系统吞吐量为代价的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li><li>使用邮戳锁StampeLock</li></ul><p>邮戳锁的基本特点:</p><ol><li>所有获取锁的方法,都返回一个邮戳(Stamp),Stamp为零表示获取失败,其余都表示成功;<br>2．所有释放锁的方法,都需要一个邮戳(Stamp),这个Stamp必须是和成功获取锁时得到的Stamp一致;</li><li>StampedLock是不可重入的，没有Re开头。危险(如果一个线程已经持有了写锁再去获取写锁的话就会造成死锁)</li><li>StampedLock的悲观读锁和写锁都不支持条件变量(Condition),这个也需要注意。.ntes</li><li>使用StampedLock一定不要调用中断操作,即不要调用interrupt()方法</li></ol><p>StampedLock有三种访问模式:</p><ol><li>Reading(读模式悲观):功能和ReentrantReadWriteLock的读锁类似</li><li>Writing(写模式悲观):功能和ReentrantReadWriteLock的写锁类似</li><li>Optimistic reading(乐观读模式)∶无锁机制类似于数据库中的乐观锁.支持读写并发很乐观认为读取时没人修改假如被修改再实现升级为悲观读模式</li></ol><ul><li>乐观的阅读。仅当锁定当前未处于写入模式时,方法 tryOptimisticRead()才返回非零戳记。如果自获得给定标记以来没有在写入模式下获取锁定则方法validate(Jong)返回true。这种模式可以被认为是读锁的极弱版本,可以随时被作者破坏。对短的只读代码段使用乐观模式通常可以减少争用并提高吞吐量。但是,它的使用本质上是脆弱的。</li><li>乐观读取部分应该只读取字段并将它们保存在局部变量中以便以后在验证后使用。在乐观模式下读取的字段可能非常不一致因此仅在您熟悉数据表示以检查一致性和/或重复调用方法validate()例如,在首次读取对象或数组引用然后访问其中一个字段,元素或方法时,通常需要执行此类步骤。</li></ul><p>Demo<br>传统版读写锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.rwlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * StampedLock = ReentrantReadWriteLock + 读的过程中也允许获取写锁介入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">static</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;写线程准备修改&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            number = number + <span class="number">13</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;写线程结束修改&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//悲观读，读没有完成时候写锁无法获得锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.readLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; come in readlock code block，4 seconds continue...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; 正在读取中......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> result = number;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; 获得成员变量值result：&quot;</span>+result);</span><br><span class="line">            System.out.println(<span class="string">&quot;读锁的时候，写锁无法介入&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StampedLockDemo resource = <span class="keyword">new</span> StampedLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传统版</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            resource.read();</span><br><span class="line">        &#125;,<span class="string">&quot;readThread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">            resource.write();</span><br><span class="line">        &#125;,<span class="string">&quot;writeThread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">4</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;number:&quot;</span> +number);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">readThread come in readlock code block，<span class="number">4</span> seconds <span class="keyword">continue</span>...</span><br><span class="line">readThread 正在读取中......</span><br><span class="line">writeThread----come in</span><br><span class="line">readThread 正在读取中......</span><br><span class="line">readThread 正在读取中......</span><br><span class="line">readThread 正在读取中......</span><br><span class="line">readThread 获得成员变量值result：<span class="number">37</span></span><br><span class="line">读锁的时候，写锁无法介入</span><br><span class="line">writeThread写线程准备修改</span><br><span class="line">writeThread写线程结束修改</span><br><span class="line">mainnumber:<span class="number">50</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Dmeo<br>允许写线程接入<br>若写线程完成修改，则此后乐观读锁升级为悲观锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.rwlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * StampedLock = ReentrantReadWriteLock + 读的过程中也允许获取写锁介入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">static</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;写线程准备修改&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            number = number + <span class="number">13</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;写线程结束修改&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//乐观读，读的过程中也允许获取写锁介入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryOptimisticRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">int</span> result = number;</span><br><span class="line">        <span class="comment">//故意间隔4秒钟，很乐观认为读取中没有其它线程修改过number值，具体靠判断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4秒前stampedLock.validate方法值(true无修改，false有修改)&quot;</span>+<span class="string">&quot;\t&quot;</span>+stampedLock.validate(stamp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;正在读取... &quot;</span>+i+<span class="string">&quot; 秒&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;后stampedLock.validate方法值(true无修改，false有修改)&quot;</span>+<span class="string">&quot;\t&quot;</span>+stampedLock.validate(stamp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stampedLock.validate(stamp))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有人修改过------有写操作&quot;</span>);</span><br><span class="line">            stamp = stampedLock.readLock();<span class="comment">//从乐观读 升级为 悲观读</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;从乐观读 升级为 悲观读&quot;</span>);</span><br><span class="line">                result = number;</span><br><span class="line">                System.out.println(<span class="string">&quot;重新悲观读后result：&quot;</span>+result);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; finally value: &quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StampedLockDemo resource = <span class="keyword">new</span> StampedLockDemo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            resource.tryOptimisticRead();</span><br><span class="line">        &#125;,<span class="string">&quot;readThread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停2秒钟线程,读过程可以写介入，演示</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">            resource.write();</span><br><span class="line">        &#125;,<span class="string">&quot;writeThread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">4</span>秒前stampedLock.validate方法值(<span class="keyword">true</span>无修改，<span class="keyword">false</span>有修改)<span class="keyword">true</span></span><br><span class="line">readThread正在读取... <span class="number">0</span> 秒后stampedLock.validate方法值(<span class="keyword">true</span>无修改，<span class="keyword">false</span>有修改)<span class="keyword">true</span></span><br><span class="line">writeThread----come in</span><br><span class="line">writeThread写线程准备修改</span><br><span class="line">writeThread写线程结束修改</span><br><span class="line">readThread正在读取... <span class="number">1</span> 秒后stampedLock.validate方法值(<span class="keyword">true</span>无修改，<span class="keyword">false</span>有修改)<span class="keyword">false</span></span><br><span class="line">readThread正在读取... <span class="number">2</span> 秒后stampedLock.validate方法值(<span class="keyword">true</span>无修改，<span class="keyword">false</span>有修改)<span class="keyword">false</span></span><br><span class="line">readThread正在读取... <span class="number">3</span> 秒后stampedLock.validate方法值(<span class="keyword">true</span>无修改，<span class="keyword">false</span>有修改)<span class="keyword">false</span></span><br><span class="line">有人修改过------有写操作</span><br><span class="line">从乐观读 升级为 悲观读</span><br><span class="line">重新悲观读后result：<span class="number">50</span></span><br><span class="line">readThread <span class="keyword">finally</span> value: <span class="number">50</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若写线程没来得及完成修改，则乐观读锁无需升级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.rwlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * StampedLock = ReentrantReadWriteLock + 读的过程中也允许获取写锁介入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">static</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;写线程准备修改&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            number = number + <span class="number">13</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;写线程结束修改&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乐观读，读的过程中也允许获取写锁介入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryOptimisticRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">int</span> result = number;</span><br><span class="line">        <span class="comment">//故意间隔4秒钟，很乐观认为读取中没有其它线程修改过number值，具体靠判断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4秒前stampedLock.validate方法值(true无修改，false有修改)&quot;</span>+<span class="string">&quot;\t&quot;</span>+stampedLock.validate(stamp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;正在读取... &quot;</span>+i+<span class="string">&quot; 秒&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;后stampedLock.validate方法值(true无修改，false有修改)&quot;</span>+<span class="string">&quot;\t&quot;</span>+stampedLock.validate(stamp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stampedLock.validate(stamp))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有人修改过------有写操作&quot;</span>);</span><br><span class="line">            stamp = stampedLock.readLock();<span class="comment">//从乐观读 升级为 悲观读</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;从乐观读 升级为 悲观读&quot;</span>);</span><br><span class="line">                result = number;</span><br><span class="line">                System.out.println(<span class="string">&quot;重新悲观读后result：&quot;</span>+result);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; finally value: &quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StampedLockDemo resource = <span class="keyword">new</span> StampedLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            resource.tryOptimisticRead();</span><br><span class="line">        &#125;,<span class="string">&quot;readThread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停6秒钟线程，使得写线程不可介入</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">6</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">            resource.write();</span><br><span class="line">        &#125;,<span class="string">&quot;writeThread&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">4</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;number:&quot;</span> +number);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">4</span>秒前stampedLock.validate方法值(<span class="keyword">true</span>无修改，<span class="keyword">false</span>有修改)<span class="keyword">true</span></span><br><span class="line">readThread正在读取... <span class="number">0</span> 秒后stampedLock.validate方法值(<span class="keyword">true</span>无修改，<span class="keyword">false</span>有修改)<span class="keyword">true</span></span><br><span class="line">readThread正在读取... <span class="number">1</span> 秒后stampedLock.validate方法值(<span class="keyword">true</span>无修改，<span class="keyword">false</span>有修改)<span class="keyword">true</span></span><br><span class="line">readThread正在读取... <span class="number">2</span> 秒后stampedLock.validate方法值(<span class="keyword">true</span>无修改，<span class="keyword">false</span>有修改)<span class="keyword">true</span></span><br><span class="line">readThread正在读取... <span class="number">3</span> 秒后stampedLock.validate方法值(<span class="keyword">true</span>无修改，<span class="keyword">false</span>有修改)<span class="keyword">true</span></span><br><span class="line">readThread <span class="keyword">finally</span> value: <span class="number">37</span></span><br><span class="line">writeThread----come in</span><br><span class="line">writeThread写线程准备修改</span><br><span class="line">writeThread写线程结束修改</span><br><span class="line">mainnumber:<span class="number">50</span></span><br><span class="line">    </span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>与Lock配合实现<strong>等待/通知</strong>模式（生产者/消费者模式），实现线程精准唤醒。</p><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>  <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span>  <span class="keyword">boolean</span> noUse = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                buildData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                useData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();    <span class="comment">//synchronized key word  #moitor enter</span></span><br><span class="line">            <span class="keyword">while</span> (noUse)&#123;</span><br><span class="line">                condition.await();  <span class="comment">// monitor.wait()</span></span><br><span class="line">            &#125;</span><br><span class="line">            data++;</span><br><span class="line">            System.out.println(<span class="string">&quot;P:&quot;</span> + data);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            noUse = <span class="keyword">true</span>;</span><br><span class="line">            condition.signal();  <span class="comment">// monitor.notify()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();  <span class="comment">// synchronized  end  #moitor end</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();    <span class="comment">//synchronized key word  #moitor enter</span></span><br><span class="line">            <span class="keyword">while</span> (!noUse)&#123;</span><br><span class="line">                condition.await();  <span class="comment">// monitor.wait()</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;C:&quot;</span> + data);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            noUse = <span class="keyword">false</span>;</span><br><span class="line">            condition.signal();  <span class="comment">// monitor.notify()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();  <span class="comment">// synchronized  end  #moitor end</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Integer number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:AAAAAAAAAAAAA&quot;</span>);</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:BBB&quot;</span>);</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:CCC&quot;</span>);</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch计数器"><a href="#CountDownLatch计数器" class="headerlink" title="CountDownLatch计数器"></a>CountDownLatch计数器</h2><p>CountDownLatch：允许count个线程阻塞在一个地方，直至这count个线程的任务都执行完毕。</p><p>Demo<br>我们要读取处理6个文件，这6个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。<br>为此我们定义了一个线程地和count为6的CountDownlatch对象。使用线程池处理读取任务，每一个线程处理完之后就将count-1，调用CountDownLatch对象的await()方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>);</span><br></pre></td></tr></table></figure><p>优化二<br>使用集合添加任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件夹位置</span></span><br><span class="line">List&lt;String&gt; filePaths = Arrays.asList(...)</span><br><span class="line"><span class="comment">// 异步处理所有文件</span></span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; fileFutures = filePaths.stream()</span><br><span class="line">    .map(filePath -&gt; doSomeThing(filePath))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 将他们合并起来</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(</span><br><span class="line">    fileFutures.toArray(<span class="keyword">new</span> CompletableFuture[fileFutures.size()])</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>原理简介</strong><br>CountDownLatch两个方法:</p><ul><li>countDown()</li><li>await()</li></ul><p>CountDownLatch也是基于AQS实现的，它的实现机制很简单。</p><ul><li>在构建CountDownLatch对象时，传入的值其实就会赋值给AQS的关键变量state</li><li>执行CountDownLatch的countDown方法时，其实就是利用CAS将state 减一</li><li>执行await方法时，其实就是判断state是否为O，不为O则加入到阻塞队列中，将该线程阻塞掉（除了头结点)，因关头节点会一直自旋等待state为0，当state为0时，头节点把剩余的在队列中阻塞的节点也一并唤醒。</li></ul><h2 id="CyclicBarrier回环栅栏"><a href="#CyclicBarrier回环栅栏" class="headerlink" title="CyclicBarrier回环栅栏"></a>CyclicBarrier回环栅栏</h2><p>CyclicBarrier原理介绍</p><ul><li>CyclicBarrier没有像CountDownLatch和ReentrantLock使用AQS的state变量，而是使用CyclicBarrier内部维护的内部维护count变量</li><li>CyclicBarrier借助ReentrantLock加上Condition实现等待唤醒的功能。</li></ul><p>在构建CyclicBarrier时，传入的值是parties变量，同时也会赋值给CyclicBarrier内部维护count变量(这是可以复用的关键)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parties表示屏障拦截的线程数量，当屏障撤销时，先执行barrierAction，然后在释放所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br><span class="line"><span class="function"><span class="comment">//barrierAction默认为null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br></pre></td></tr></table></figure><p>每次调用await时，会将count-1，操作count值是直接使用ReentrantLock来保证线程安全性</p><ul><li>如果count不为0，则添加则condition队列中</li><li>如果count等于0时，则把节点从condition队列添加至AQS的队列中进行全部唤醒，并且将parties的值重新赋值为count的值(实现复用)</li></ul><p>CyclicBarrier的特点：阻塞任务线程而非主线程<br>CountDownLatch和CyclicBarrier都是线程同步的工具类。可以发现这两者的等待主体是不一样的</p><ul><li>CountDownLatch调用await()通常是主线程/调用线程</li><li>CyclicBarrier调用await()是在任务线程调用的，所以CyclicBarrier中的阻塞的是任务的线程，而主线程是不受影响的</li></ul><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//集齐7颗龙珠就能召唤神龙</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// public CyclicBarrier(int parties, Runnable barrierAction) &#123;&#125;</span></span><br><span class="line">        CyclicBarrier cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤龙珠&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp=i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t收集到了第&quot;</span>+temp+<span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共同抵达时的执行操作<br>屏障的抵达操作:每个线程执行时，都会碰到一个屏障，直到所有线程执行结束，然后屏障便会打开，使所有线程继续往下执行。</p><ul><li>CyclicBarrier支持一个可选的Runnable barrierAction命令，在一组线程中的最后一个线程到达之后，但在释放所有线程之前运行一次。</li><li>若在继续所有参与线程之前更新共享状态，此屏障操作很有用。、</li></ul><p>这里介绍CyclicBarrier的两个构造函数:</p><ul><li>CyclicBarrier(int parties)前者只需要声明需要拦截的线程数即可</li><li>CylicBarrier(int parties,Runnable barrierAction)后者还需要定义一个等待所有线程到达屏障优先执行的Runnable对象。</li></ul><p>如果一个寝室四个人约好了去球场打球，由于四个人准备工作不同，所以约好在楼下集合，并且四个人集合好之后一起出发去球场。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    <span class="comment">//当拦截线程数达到4时，便优先执行barrierAction，然后再执行被拦截的线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, () -&gt; System.out.println(<span class="string">&quot;寝室四兄弟一起出发去球场&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;开始从宿舍出发&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.await();</span><br><span class="line">                <span class="comment">//线程的具体业务操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;从楼底下出发&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;到达操场&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] str = &#123;<span class="string">&quot;李明&quot;</span>, <span class="string">&quot;王强&quot;</span>, <span class="string">&quot;刘凯&quot;</span>, <span class="string">&quot;赵杰&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> MyThread(str[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;四个人一起到达球场，现在开始打球&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">输出：</span><br><span class="line">王强开始从宿舍出发</span><br><span class="line">刘凯开始从宿舍出发</span><br><span class="line">李明开始从宿舍出发</span><br><span class="line">赵杰开始从宿舍出发</span><br><span class="line">寝室四兄弟一起出发去球场</span><br><span class="line">李明从楼底下出发</span><br><span class="line">刘凯从楼底下出发</span><br><span class="line">王强从楼底下出发</span><br><span class="line">赵杰从楼底下出发</span><br><span class="line">赵杰到达操场</span><br><span class="line">刘凯到达操场</span><br><span class="line">王强到达操场</span><br><span class="line">李明到达操场</span><br><span class="line">四个人一起到达球场，现在开始打球</span><br></pre></td></tr></table></figure><p>屏障复用<br>CyclicBarrier是可循环利用的屏障，顾名思义，这个名字也将这个类的特点给明确地表示出来了。可重复利用，说明该类创建的对象可以复用;CyclicBarrier是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点。与CountDownLatch不同的是该barrier在释放等待线程后可以重用，所以称它为循环(Cyclic)的屏障(Barrier)。<br>现在对CyclicBarrier进行复用…又来了一拨人，看看愿不愿意一起打:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    <span class="comment">//当拦截线程数达到4时，便优先执行barrierAction，然后再执行被拦截的线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, () -&gt; System.out.println(<span class="string">&quot;寝室四兄弟一起出发去球场&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;开始从宿舍出发&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.await();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;从楼底下出发&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;到达操场&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] str = &#123;<span class="string">&quot;李明&quot;</span>, <span class="string">&quot;王强&quot;</span>, <span class="string">&quot;刘凯&quot;</span>, <span class="string">&quot;赵杰&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> MyThread(str[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;四个人一起到达球场，现在开始打球&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;现在对CyclicBarrier进行复用.....&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;又来了一拨人，看看愿不愿意一起打：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] str1= &#123;<span class="string">&quot;王二&quot;</span>,<span class="string">&quot;洪光&quot;</span>,<span class="string">&quot;雷兵&quot;</span>,<span class="string">&quot;赵三&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> MyThread(str1[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;四个人一起到达球场，表示愿意一起打球，现在八个人开始打球&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">李明开始从宿舍出发</span><br><span class="line">刘凯开始从宿舍出发</span><br><span class="line">王强开始从宿舍出发</span><br><span class="line">赵杰开始从宿舍出发</span><br><span class="line">寝室四兄弟一起出发去球场</span><br><span class="line">李明从楼底下出发</span><br><span class="line">赵杰从楼底下出发</span><br><span class="line">刘凯从楼底下出发</span><br><span class="line">王强从楼底下出发</span><br><span class="line">李明到达操场</span><br><span class="line">赵杰到达操场</span><br><span class="line">刘凯到达操场</span><br><span class="line">王强到达操场</span><br><span class="line">四个人一起到达球场，现在开始打球</span><br><span class="line"></span><br><span class="line">现在对CyclicBarrier进行复用…</span><br><span class="line">又来了一拨人，看看愿不愿意一起打：</span><br><span class="line">王二开始从宿舍出发</span><br><span class="line">洪光开始从宿舍出发</span><br><span class="line">赵三开始从宿舍出发</span><br><span class="line">雷兵开始从宿舍出发</span><br><span class="line">寝室四兄弟一起出发去球场</span><br><span class="line">雷兵从楼底下出发</span><br><span class="line">赵三从楼底下出发</span><br><span class="line">王二从楼底下出发</span><br><span class="line">洪光从楼底下出发</span><br><span class="line">洪光到达操场</span><br><span class="line">赵三到达操场</span><br><span class="line">王二到达操场</span><br><span class="line">雷兵到达操场</span><br><span class="line">四个人一起到达球场，表示愿意一起打球，现在八个人开始打球</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore通常我们叫它信号量，可以用来控制同时访问特定资源的线程数量，通过协调各个线程<br>以保证合理的使用资源。</p><p>使用场景:<br>通常用于那些资源有明确访问数量限制的场景，常用于限流。</p><ul><li>数据库连接池，同时进行连接的线程有数量限制，连接不能超过一定的数量，当连接达到了限制数量后，后面的线程只能排队等前面的线程释放了数据库连接才能获得数据库连接。</li><li>停车场场景，车位数量有限，同时只能容纳多少台车，车位满了之后只有等里面的车离开停车场外面的车才可以进入。可以把它简单的理解成我们停车场入口立着的那个显示屏，每有一辆车进入停车场显尔屏就云亚尔T将示午A似，“感4停车场出去，显示屏上显示的剩余车辆就会加1，当显示屏上的剩余车位为O时，停车场入口的栏杆就不会再打开，车辆就无法进入停车场了，直到有一辆车从停车场出去为止。</li><li>接口限流,应用限流,商品限流…</li></ul><p>API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">acquire()  </span><br><span class="line">获取一个令牌，在获取到令牌、或者被其他线程调用中断之前线程一直处于阻塞状态。</span><br><span class="line"></span><br><span class="line">tryAcquire(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">尝试在指定时间内获得令牌,返回获取令牌成功或失败，不阻塞线程。</span><br><span class="line"></span><br><span class="line">release()</span><br><span class="line">释放一个令牌，唤醒一个获取令牌不成功的阻塞线程。</span><br><span class="line"></span><br><span class="line">hasQueuedThreads()</span><br><span class="line">等待队列里是否还存在等待线程。</span><br><span class="line"></span><br><span class="line">getQueueLength()</span><br><span class="line">获取等待队列里阻塞的线程数。</span><br><span class="line"></span><br><span class="line">drainPermits()</span><br><span class="line">清空令牌把可用令牌数置为<span class="number">0</span>，返回清空令牌的数量。</span><br><span class="line"></span><br><span class="line">availablePermits()</span><br><span class="line">返回可用的令牌数量。</span><br><span class="line"></span><br><span class="line"><span class="comment">// .....其他的自己看源码</span></span><br></pre></td></tr></table></figure><p>Demo<br>用semaphore 实现停车场提示牌功能<br>每个停车场入口都有一个提示牌，上面显示着停车场的剩余车位还有多少，当剩余车位为O时，不允许车辆进入停车场，直到停车场里面有车离开停车场，这时提示牌上会显示新的剩余车位数。<br>业务场景∶</p><ul><li>停车场容纳总停车量10</li><li>当一辆车进入停车场后，显示牌的剩余车位数响应的减1</li><li>每有一辆车驶出停车场后，显示牌的剩余车位数响应的加1</li><li>停车场剩余车位不足时，车辆只能在外面等待<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停车场同时容纳的车辆10</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟100辆车进入停车场</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;====&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;来到停车场&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span>(semaphore.availablePermits()==<span class="number">0</span>)&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;车位不足，请耐心等待&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        semaphore.acquire();<span class="comment">//获取令牌尝试进入停车场</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;成功进入停车场&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));<span class="comment">//模拟车辆在停车场停留的时间</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;驶出停车场&quot;</span>);</span><br><span class="line">                        semaphore.release();<span class="comment">//释放令牌，腾出停车场车位</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i+<span class="string">&quot;号车&quot;</span>);</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Demo<br>用semaphore实现防止商品超卖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.limiting.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 秒杀防止商品超卖现象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreCommodity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品池</span></span><br><span class="line">  <span class="keyword">private</span>   Map&lt;String, Semaphore&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化商品池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SemaphoreCommodity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//手机10部</span></span><br><span class="line">        map.put(<span class="string">&quot;phone&quot;</span>,<span class="keyword">new</span> Semaphore(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//电脑4台</span></span><br><span class="line">        map.put(<span class="string">&quot;computer&quot;</span>,<span class="keyword">new</span> Semaphore(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 商品名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 购买是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getbuy</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Semaphore semaphore = map.get(name);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> availablePermit = semaphore.availablePermits();</span><br><span class="line">            <span class="keyword">if</span> (availablePermit==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//商品售空</span></span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> b = semaphore.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;抢到商品了&quot;</span>);</span><br><span class="line">                <span class="comment">///处理逻辑</span></span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SemaphoreCommodity semaphoreCommodity=<span class="keyword">new</span> SemaphoreCommodity();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(semaphoreCommodity.getbuy(<span class="string">&quot;computer&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo<br>用semaphore 实现接口限流</p><ol><li><p>切面注解SemaphoreDoc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.limiting.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span><span class="comment">//作用:方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SemaphoreDoc &#123;</span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span></span>; <span class="comment">//建议设置不然可能发生,不同方法重复限流现象</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">blockingTime</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>切面类SemaphoreAop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.limiting.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里需要注意了，这个是将自己自定义注解作为切点的根据，路径一定要写正确了</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;@annotation(com.limiting.semaphore.SemaphoreDoc)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">semaphoreDoc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//限流池</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span>  Map&lt;String, Semaphore&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;semaphoreDoc()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object res = <span class="keyword">null</span>;</span><br><span class="line">        MethodSignature signature = (MethodSignature)joinPoint.getSignature();</span><br><span class="line">        SemaphoreDoc annotation  = signature.getMethod().getAnnotation(SemaphoreDoc.class);</span><br><span class="line">        <span class="keyword">int</span> blockingTime = annotation.blockingTime();</span><br><span class="line">        <span class="keyword">int</span> limit = annotation.limit();</span><br><span class="line">        String key = annotation.key();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StringBuilder name = <span class="keyword">new</span> StringBuilder(key+signature.getMethod().getName());<span class="comment">//方法名</span></span><br><span class="line">        <span class="keyword">for</span> (String parameterName : signature.getParameterNames()) &#123;</span><br><span class="line">            name.append(parameterName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Semaphore semaphore = map.get(name.toString());</span><br><span class="line">        <span class="keyword">if</span> (semaphore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Semaphore semaphore1 = <span class="keyword">new</span> Semaphore(limit);</span><br><span class="line">            map.put(name.toString(),semaphore1);</span><br><span class="line">            semaphore=semaphore1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取令牌</span></span><br><span class="line">            <span class="keyword">boolean</span> b = semaphore.tryAcquire(blockingTime, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (b) &#123;<span class="comment">//如果拿到令牌了那么执行方法</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res = joinPoint.proceed();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在一定时间内拿不到令牌那么就访问失败</span></span><br><span class="line">                <span class="keyword">throw</span>  <span class="keyword">new</span> Exception(<span class="string">&quot;访问超时,目前请求人数过多请稍后在试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放令牌，腾出位置</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>为什么使用线程池？<br>答：减少频繁创建和销毁的时间，提升性能。</p><p>使用线程池优点：</p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ol><h2 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h2><h3 id="newFixedThreadPool-int"><a href="#newFixedThreadPool-int" class="headerlink" title="newFixedThreadPool(int)"></a>newFixedThreadPool(int)</h3><p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h3><p>newSingleThreadExecutor 创建的线程池corePoolSize和maximumPoolSize值都是1，它使用的是LinkedBlockingQueue一个任务一个任务的执行，一池一线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h3><p>newCachedThreadPool创建的线程池将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，它使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p><p>执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> * Arrays</span></span><br><span class="line"><span class="comment"> * Collections</span></span><br><span class="line"><span class="comment"> * Executors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List list = new ArrayList();</span></span><br><span class="line">        <span class="comment">//List list = Arrays.asList(&quot;a&quot;,&quot;b&quot;);</span></span><br><span class="line">        <span class="comment">//固定数的线程池，一池五线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       ExecutorService threadPool =  Executors.newFixedThreadPool(5); //一个银行网点，5个受理业务的窗口</span></span><br><span class="line"><span class="comment">//       ExecutorService threadPool =  Executors.newSingleThreadExecutor(); //一个银行网点，1个受理业务的窗口</span></span><br><span class="line">       ExecutorService threadPool =  Executors.newCachedThreadPool(); <span class="comment">//一个银行网点，可扩展受理业务的窗口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>corePoolSize</strong>：核心线程大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使有其他空闲线程可以处理任务也会创新线程，等到工作的线程数大于核心线程数时就不会在创建了。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前把核心线程都创造好，并启动</li><li><strong>maximumPoolSize</strong>：线程池允许创建的最大线程数，此值必须大于等于1。如果队列满了，并且以创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果我们使用了无界队列，那么所有的任务会加入队列，这个参数就没有什么效果了</li><li><strong>keepAliveTime</strong>：多余的空闲线程的存活时间,当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止，如果任务很多，并且每个任务的执行时间比较短，避免线程重复创建和回收，可以调大这个时间，提高线程的利用率</li><li><strong>unit</strong>：keepAliveTIme的时间单位，可以选择的单位有天、小时、分钟、毫秒、微妙、千分之一毫秒和纳秒。类型是一个枚举java.util.concurrent.TimeUnit，这个枚举也经常使用</li><li><strong>workQueue</strong>：任务队列，被提交但尚未被执行的任务，用于缓存待处理任务的阻塞队列</li><li><strong>threadFactory</strong>：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</li><li><strong>handler</strong>：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略</li></ol><p>调用线程池的execute方法处理任务，执行execute方法的过程：</p><ol><li>判断线程池中运行的线程数是否小于corepoolsize，是：则创建新的线程来处理任务，否：执行下一步</li><li>试图将任务添加到workQueue指定的队列中，如果无法添加到队列，进入下一步</li><li>判断线程池中运行的线程数是否小于maximumPoolSize，是：则新增线程处理当前传入的任务，否：将任务传递给handler对象rejectedExecution方法处理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. z在创建了线程池后，开始等待请求。</span><br><span class="line">2. 当调用execute()方法添加一个请求任务时，线程池会做出如下判断：</span><br><span class="line">  - 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</span><br><span class="line">  - 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</span><br><span class="line">  - 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</span><br><span class="line">  - 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</span><br><span class="line">3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。</span><br><span class="line">4. 当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</span><br><span class="line">  - 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。</span><br><span class="line">  - 所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</span><br></pre></td></tr></table></figure></li></ol><p><strong>拒绝策略</strong><br>JDK内置拒绝策略</p><ul><li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li><li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</li><li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</li></ul><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;处理&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Task&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                (r, executors) -&gt; &#123;</span><br><span class="line">                    <span class="comment">//自定义饱和策略</span></span><br><span class="line">                    <span class="comment">//记录一下无法处理的任务</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;无法处理的任务：&quot;</span> + r.toString());</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Task(<span class="string">&quot;任务-&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">无法处理的任务：Task&#123;name=<span class="string">&#x27;任务-2&#x27;</span>&#125;</span><br><span class="line">无法处理的任务：Task&#123;name=<span class="string">&#x27;任务-3&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>处理任务-<span class="number">0</span></span><br><span class="line">无法处理的任务：Task&#123;name=<span class="string">&#x27;任务-4&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>处理任务-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>参数设置</strong><br>合理的配置线程池，需要先分析任务的特性，可以从以下几个角度分析：</p><ul><li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务</li><li>任务的优先级：高、中、低</li><li>任务的执行时间：长、中、短</li><li>任务的依赖性：是否依赖其他的系统资源，如数据库连接</li></ul><p>性质不同任务可以用不同规模的线程池分开处理。CPU密集型任务应该尽可能小的线程，如配置cpu数量+1个线程的线程池。由于IO密集型任务并不是一直在执行任务，不能让cpu闲着，则应配置尽可能多的线程，如：CPU数量<code>*</code>2。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这2个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。可以通过<code>Runtime.getRuntime().availableProcessors()</code>方法获取cpu数量。优先级不同任务可以对线程池采用优先级队列来处理，让优先级高的先执行</p><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> * Arrays</span></span><br><span class="line"><span class="comment"> * Collections</span></span><br><span class="line"><span class="comment"> * Executors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.AbortPolicy()</span></span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.CallerRunsPolicy()</span></span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.DiscardOldestPolicy()</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List list = new ArrayList();</span></span><br><span class="line">        <span class="comment">//List list = Arrays.asList(&quot;a&quot;,&quot;b&quot;);</span></span><br><span class="line">        <span class="comment">//固定数的线程池，一池五线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       ExecutorService threadPool =  Executors.newFixedThreadPool(5); //一个银行网点，5个受理业务的窗口</span></span><br><span class="line"><span class="comment">//       ExecutorService threadPool =  Executors.newSingleThreadExecutor(); //一个银行网点，1个受理业务的窗口</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool(); <span class="comment">//一个银行网点，可扩展受理业务的窗口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>线程池提供了2个关闭方法：shutdown和shutdownNow，当调用者两个方法之后，线程池会遍历内部的工作线程，然后调用每个工作线程的interrrupt方法给线程发送中断信号，内部如果无法响应中断信号的可能永远无法终止，所以如果内部有无线循环的，最好在循环内部检测一下线程的中断信号，合理的退出。调用者两个方法中任意一个，线程池的isShutdown方法就会返回true，当所有的任务线程都关闭之后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p><p>调用shutdown方法之后，线程池将不再接口新任务，内部会将所有已提交的任务处理完毕，处理完毕之后，工作线程自动退出。</p><p>而调用shutdownNow方法后，线程池会将还未处理的（在队里等待处理的任务）任务移除，将正在处理中的处理完毕之后，工作线程自动退出。</p><p>至于调用哪个方法来关闭线程，应该由提交到线程池的任务特性决定，多数情况下调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><ul><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按照先进先出原则对元素进行排序</li><li>LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列，此队列按照先进先出排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool使用了这个队列。</li><li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</li><li>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列,每个插入操作必须等到另外一个线程调用移除操作，否则插入操作一直处理阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用这个队列</li><li>LinkedTransferQueue：由链表组成的无界阻塞队列。</li><li>LinkedBlockingDeque：由链表组成的双向阻塞队列。</li></ul><p>使用Executors.newCachedThreadPool()创建线程池，看一下的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，系统创建了50个线程处理任务，代码中使用了SynchronousQueue同步队列，这种队列比较特殊，放入元素必须要有另外一个线程去获取这个元素，否则放入元素会失败或者一直阻塞在那里直到有线程取走，示例中任务处理休眠了指定的时间，导致已创建的工作线程都忙于处理任务，所以新来任务之后，将任务丢入同步队列会失败，丢入队列失败之后，会尝试新建线程处理任务。使用上面的方式创建线程池需要注意，如果需要处理的任务比较耗时，会导致新来的任务都会创建新的线程进行处理，可能会导致创建非常多的线程，最终耗尽系统资源，触发OOM。</p><p><strong>PriorityBlockingQueue优先级队列的线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span>&lt;<span class="title">Task</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> i, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;处理&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Task o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o.i, <span class="keyword">this</span>.i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> PriorityBlockingQueue());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String taskName = <span class="string">&quot;任务&quot;</span> + i;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Task(i, taskName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &gt;= <span class="number">90</span>; i--) &#123;</span><br><span class="line">            String taskName = <span class="string">&quot;任务&quot;</span> + i;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Task(i, taskName));</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出中，除了第一个任务，其他任务按照优先级高低按顺序处理。原因在于：创建线程池的时候使用了优先级队列，进入队列中的任务会进行排序，任务的先后顺序由Task中的i变量决定。向PriorityBlockingQueue加入元素的时候，内部会调用代码中Task的compareTo方法决定元素的先后顺序。</p><h2 id="拓展线程池"><a href="#拓展线程池" class="headerlink" title="拓展线程池"></a>拓展线程池</h2><p>虽然jdk提供了ThreadPoolExecutor这个高性能线程池，但是如果我们自己想在这个线程池上面做一些扩展，比如，监控每个任务执行的开始时间，结束时间，或者一些其他自定义的功能，我们应该怎么办？</p><p>这个jdk已经帮我们想到了，ThreadPoolExecutor内部提供了几个方法beforeExecute、afterExecute、terminated，可以由开发人员自己去这些方法。看一下线程池内部的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    beforeExecute(wt, task);<span class="comment">//任务执行之前调用的方法</span></span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">        thrown = x;</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">        thrown = x;</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        thrown = x;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterExecute(task, thrown);<span class="comment">//任务执行完毕之后调用的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    task = <span class="keyword">null</span>;</span><br><span class="line">    w.completedTasks++;</span><br><span class="line">    w.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>beforeExecute：任务执行之前调用的方法，有2个参数，第1个参数是执行任务的线程，第2个参数是任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>afterExecute：任务执行完成之后调用的方法，2个参数，第1个参数表示任务，第2个参数表示任务执行时的异常信息，如果无异常，第二个参数为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>terminated：线程池最终关闭之后调用的方法。所有的工作线程都退出了，最终线程池会退出，退出时调用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;处理&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Task&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                (r, executors) -&gt; &#123;</span><br><span class="line">                    <span class="comment">//自定义饱和策略</span></span><br><span class="line">                    <span class="comment">//记录一下无法处理的任务</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;无法处理的任务：&quot;</span> + r.toString());</span><br><span class="line">                &#125;) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + t.getName() + <span class="string">&quot;,开始执行任务:&quot;</span> + r.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,任务:&quot;</span> + r.toString() + <span class="string">&quot;，执行完毕!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，关闭线程池!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Task(<span class="string">&quot;任务-&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1564324574847</span>,pool-<span class="number">1</span>-thread-<span class="number">1</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-0&#x27;</span>&#125;</span><br><span class="line"><span class="number">1564324574850</span>,pool-<span class="number">1</span>-thread-<span class="number">3</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-2&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>处理任务-<span class="number">2</span></span><br><span class="line"><span class="number">1564324574849</span>,pool-<span class="number">1</span>-thread-<span class="number">2</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-1&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>处理任务-<span class="number">1</span></span><br><span class="line"><span class="number">1564324574848</span>,pool-<span class="number">1</span>-thread-<span class="number">5</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-4&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>处理任务-<span class="number">4</span></span><br><span class="line"><span class="number">1564324574848</span>,pool-<span class="number">1</span>-thread-<span class="number">4</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-3&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>处理任务-<span class="number">3</span></span><br><span class="line"><span class="number">1564324574850</span>,pool-<span class="number">1</span>-thread-<span class="number">7</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-6&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>处理任务-<span class="number">6</span></span><br><span class="line"><span class="number">1564324574850</span>,pool-<span class="number">1</span>-thread-<span class="number">6</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-5&#x27;</span>&#125;</span><br><span class="line"><span class="number">1564324574851</span>,pool-<span class="number">1</span>-thread-<span class="number">8</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-7&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>处理任务-<span class="number">7</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>处理任务-<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>处理任务-<span class="number">5</span></span><br><span class="line"><span class="number">1564324574851</span>,pool-<span class="number">1</span>-thread-<span class="number">10</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-9&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span>处理任务-<span class="number">9</span></span><br><span class="line"><span class="number">1564324574852</span>,pool-<span class="number">1</span>-thread-<span class="number">9</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-8&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span>处理任务-<span class="number">8</span></span><br><span class="line"><span class="number">1564324576851</span>,pool-<span class="number">1</span>-thread-<span class="number">2</span>,任务:Task&#123;name=<span class="string">&#x27;任务-1&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576851</span>,pool-<span class="number">1</span>-thread-<span class="number">3</span>,任务:Task&#123;name=<span class="string">&#x27;任务-2&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576852</span>,pool-<span class="number">1</span>-thread-<span class="number">1</span>,任务:Task&#123;name=<span class="string">&#x27;任务-0&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576852</span>,pool-<span class="number">1</span>-thread-<span class="number">4</span>,任务:Task&#123;name=<span class="string">&#x27;任务-3&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576852</span>,pool-<span class="number">1</span>-thread-<span class="number">8</span>,任务:Task&#123;name=<span class="string">&#x27;任务-7&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576852</span>,pool-<span class="number">1</span>-thread-<span class="number">7</span>,任务:Task&#123;name=<span class="string">&#x27;任务-6&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576852</span>,pool-<span class="number">1</span>-thread-<span class="number">5</span>,任务:Task&#123;name=<span class="string">&#x27;任务-4&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576853</span>,pool-<span class="number">1</span>-thread-<span class="number">6</span>,任务:Task&#123;name=<span class="string">&#x27;任务-5&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576853</span>,pool-<span class="number">1</span>-thread-<span class="number">10</span>,任务:Task&#123;name=<span class="string">&#x27;任务-9&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576853</span>,pool-<span class="number">1</span>-thread-<span class="number">9</span>,任务:Task&#123;name=<span class="string">&#x27;任务-8&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576853</span>,pool-<span class="number">1</span>-thread-<span class="number">9</span>，关闭线程池!</span><br></pre></td></tr></table></figure><p>从输出结果中可以看到，每个需要执行的任务打印了3行日志，执行前由线程池的beforeExecute打印，执行时会调用任务的run方法，任务执行完毕之后，会调用线程池的afterExecute方法，从每个任务的首尾2条日志中可以看到每个任务耗时2秒左右。线程池最终关闭之后调用了terminated方法。</p><h1 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h1><h2 id="基本原子类"><a href="#基本原子类" class="headerlink" title="基本原子类"></a>基本原子类</h2><ul><li>AtomicInteger：整型原子类</li><li>AtomicBoolean：布尔原子类</li><li>AtomicLong：长整型原子类  </li></ul><h2 id="数组原子类"><a href="#数组原子类" class="headerlink" title="数组原子类"></a>数组原子类</h2><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray： 引用类型数组原子类</li></ul><h2 id="引用原子类"><a href="#引用原子类" class="headerlink" title="引用原子类"></a>引用原子类</h2><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题</li><li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li></ul><h2 id="对象属性修改原子类"><a href="#对象属性修改原子类" class="headerlink" title="对象属性修改原子类"></a>对象属性修改原子类</h2><ul><li>AtomicIntegerFieldUpdater：原子更新对象中int类型字段的值</li><li>AtomicLongFieldUpdater：原子更新对象中Long类型字段的值</li><li>AtomicReferenceFieldUpdater：原子更新引用类型字段的值</li></ul><h2 id="原子操作增强原子类"><a href="#原子操作增强原子类" class="headerlink" title="原子操作增强原子类"></a>原子操作增强原子类</h2><ul><li>LongAdder</li><li>LongAccumulator</li><li>DoubleAdder</li><li>DoubleAccumulator</li></ul><h2 id="原子基本类型示例"><a href="#原子基本类型示例" class="headerlink" title="原子基本类型示例"></a>原子基本类型示例</h2><ol><li><p>AtomicInteger保证i++在多线程情况下的安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CountDownLatch保证i++在多线程情况下的安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.atomics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumber</span> </span>&#123;</span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-02-25 21:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyNumber myNumber = <span class="keyword">new</span> MyNumber();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                        myNumber.addPlusPlus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//暂停几秒钟线程，等待上面50个线程全部计算完成后，再去获得最终值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(2). 使用CountDownLatch去解决等待时间的问题</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(1). 如果不加上下面的停顿3秒的时间,会导致还没有进行i++ 50000次main线程就已经结束了</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;result: &quot;</span> + myNumber.atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="原子类型引用示例"><a href="#原子类型引用示例" class="headerlink" title="原子类型引用示例"></a>原子类型引用示例</h2><p>上面的普通原子类仅仅只能保证一个共享变量的原子操作，对于对象的原子操作有两种解决方案:</p><ol><li>使用JDK1.5开始就提供的AtomicReference类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作</li><li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li></ol><p><strong>AtomicReference对象封装</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.cas;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="keyword">int</span>    age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-02-24 14:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        User z3 = <span class="keyword">new</span> User(<span class="string">&quot;z3&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        User li4 = <span class="keyword">new</span> User(<span class="string">&quot;li4&quot;</span>,<span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, li4)+<span class="string">&quot;\t&quot;</span>+atomicReference.get().toString());</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, li4)+<span class="string">&quot;\t&quot;</span>+atomicReference.get().toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用AtomicReference，手写自旋锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：实现一个自旋锁</span></span><br><span class="line"><span class="comment"> * 自旋锁好处：循环比较获取没有类似wait的阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现</span></span><br><span class="line"><span class="comment"> * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="keyword">null</span>,thread))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t myUnLock over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="comment">//暂停一会儿线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">5</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="comment">//暂停一会儿线程，保证A线程先于B线程启动并完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">1</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicStampedReference</p><p><strong>ABA问题</strong><br>比如说一个线程1从内存位置V中取出A，这时候另一个线程2也从内存中取出A，并且线程2进行了一些操作将值变成了B，然后线程2又将V位置的数据变成A放回去这时候线程1进行CAS操作发现内存中仍然是A，预期OK，然后线程1操作成功<br>尽管线程1的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p>解决CAS的ABA问题:ABA问题的解决思路是在变量前面追加上版本号时间戳戳记流水，择其一。从JDK 1.5开始，JDK的atomic包里提供了一个类AtomicstampedReference类来解决ABA[问题。</p><p>ABADemo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        abaProblem();</span><br><span class="line">        abaResolve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">abaResolve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;t3 ----第1次stamp  &quot;</span>+stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t3 ----第2次stamp  &quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t3 ----第3次stamp  &quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;t4 ----第1次stamp  &quot;</span>+stamp);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">20210308</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+result+<span class="string">&quot;\t&quot;</span>+atomicStampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">abaProblem</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">20210308</span>);</span><br><span class="line">            System.out.println(atomicInteger.get());</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象属性修改原子类示例"><a href="#对象属性修改原子类示例" class="headerlink" title="对象属性修改原子类示例"></a>对象属性修改原子类示例</h2><ol><li><p>使用目的:<br>以一种线程安全的方式操作非线程安全对象内的某些字段，是否可以不要锁定整个对象减少锁定的范围只关注长期、敏感性变化的某一个字段而不是整个对象以达到精确加锁+节约内存的目的</p></li><li><p>使用要求<br>更新的对象属性必须使用public volatile修饰符<br>这种原子类型，是抽象类所以每次使用都必须使用静态方法newUpdater()创建一个更新器,并且需要设置想要更新的类和属性</p></li></ol><p><strong>AtomicIntegerFieldUpdater</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bilibili.juc.atomics;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span>//资源类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String bankName = <span class="string">&quot;CCB&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新的对象属性必须使用 public volatile 修饰符。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> money = <span class="number">0</span>;<span class="comment">//钱数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        money++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须</span></span><br><span class="line">    <span class="comment">// 使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</span></span><br><span class="line"></span><br><span class="line">    AtomicIntegerFieldUpdater&lt;BankAccount&gt; fieldUpdater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不加synchronized，保证高性能原子性，局部微创小手术</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transMoney</span><span class="params">(BankAccount bankAccount)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fieldUpdater.getAndIncrement(bankAccount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * 以一种线程安全的方式操作非线程安全对象的某些字段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需求：</span></span><br><span class="line"><span class="comment"> * 10个线程，</span></span><br><span class="line"><span class="comment"> * 每个线程转账1000，</span></span><br><span class="line"><span class="comment"> * 不使用synchronized,尝试使用AtomicIntegerFieldUpdater来实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BankAccount bankAccount = <span class="keyword">new</span> BankAccount();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=<span class="number">1000</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">//bankAccount.add();</span></span><br><span class="line">                        bankAccount.transMoney(bankAccount);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;result: &quot;</span>+bankAccount.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AtomicReferenceFieldUpdater</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.bilibili.juc.atomics;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line">import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line">class MyVar //资源类</span><br><span class="line">&#123;</span><br><span class="line">    public volatile Boolean isInit = Boolean.FALSE;</span><br><span class="line"></span><br><span class="line">    AtomicReferenceFieldUpdater&lt;MyVar,Boolean&gt; referenceFieldUpdater =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,&quot;isInit&quot;);</span><br><span class="line"></span><br><span class="line">    public void init(MyVar myVar)</span><br><span class="line">    &#123;</span><br><span class="line">        if (referenceFieldUpdater.compareAndSet(myVar,Boolean.FALSE,Boolean.TRUE))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+&quot;----- start init,need 2 seconds&quot;);</span><br><span class="line">            //暂停几秒钟线程</span><br><span class="line">            try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+&quot;----- over init&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+&quot;----- 已经有线程在进行初始化工作。。。。。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @auther zzyy</span><br><span class="line"> * 需求：</span><br><span class="line"> * 多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，</span><br><span class="line"> * 要求只能被初始化一次，只有一个线程操作成功</span><br><span class="line"> */</span><br><span class="line">public class AtomicReferenceFieldUpdaterDemo</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        MyVar myVar = new MyVar();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;=5; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myVar.init(myVar);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//打印：</span><br><span class="line">D:\App\java1.8\jdk\bin\java.exe &quot;-javaagent:D:\App\IntelliJ IDEA 2020.3.1\lib\idea_rt.jar=57957:D:\App\IntelliJ IDEA 2020.3.1\bin&quot; -Dfile.encoding=GBK -classpath ...... com.bilibili.juc.atomics.AtomicReferenceFieldUpdaterDemo</span><br><span class="line">1----- start init,need 2 seconds</span><br><span class="line">3----- 已经有线程在进行初始化工作。。。。。</span><br><span class="line">2----- 已经有线程在进行初始化工作。。。。。</span><br><span class="line">4----- 已经有线程在进行初始化工作。。。。。</span><br><span class="line">5----- 已经有线程在进行初始化工作。。。。。</span><br><span class="line">1----- over init</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="增强原子类示例"><a href="#增强原子类示例" class="headerlink" title="增强原子类示例"></a>增强原子类示例</h2><p><strong>为什么引入<code>LongAdder</code>?</strong><br>AtomicLong是利用底层的CAS操作来提供并发性的，逻辑是采用自旋的方式不断更新目标值，直到更新成功，也即乐观锁的实现模式。<br>在并发量比较低的情况下,线程冲突的概率比较小,自旋的次数不会很多。但是,高并发情况下,N个线程同时进行自旋操作,N-1个线程失败,导致CPU打满场景,此时AtomicLong的自旋会成为瓶颈。这就是<code>LongAdder</code>引入的初衷——解决高并发环境下AtomictLong的自旋瓶颈问题</p><p><strong>LongAdder和LongAccumulator区别</strong></p><ul><li>LongAdder只能用来计算加法，且从零开始计算</li><li>LongAccumulator提供了自定义的函数操作</li></ul><p>LongAccumulator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAccumulator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"><span class="keyword">import</span> java.util.function.LongBinaryOperator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAccumulatorDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add_LongAdder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        longAdder.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LongAccumulator longAccumulator = new LongAccumulator((x, y) -&gt; x + y,0);</span></span><br><span class="line">    LongAccumulator longAccumulator = <span class="keyword">new</span> LongAccumulator(<span class="keyword">new</span> LongBinaryOperator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> left - right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add_LongAccumulator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LongAccumulatorDemo demo = <span class="keyword">new</span> LongAccumulatorDemo();</span><br><span class="line"></span><br><span class="line">        demo.add_LongAccumulator();</span><br><span class="line">        demo.add_LongAccumulator();</span><br><span class="line">        System.out.println(demo.longAccumulator.longValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LongAdder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderAPIDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">        longAdder.increment();</span><br><span class="line">        longAdder.increment();</span><br><span class="line">        longAdder.increment();</span><br><span class="line"></span><br><span class="line">        System.out.println(longAdder.longValue());</span><br><span class="line"></span><br><span class="line">        LongAccumulator longAccumulator = <span class="keyword">new</span> LongAccumulator((x,y) -&gt; x * y,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);</span><br><span class="line">        longAccumulator.accumulate(<span class="number">2</span>);</span><br><span class="line">        longAccumulator.accumulate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(longAccumulator.longValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LongAdder高性能对比</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickNumberNet</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clickBySync</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickByAtomicLong</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickByLongAdder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        longAdder.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LongAccumulator longAccumulator = <span class="keyword">new</span> LongAccumulator((x,y) -&gt; x + y,<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickByLongAccumulator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-21 22:23</span></span><br><span class="line"><span class="comment"> * 50个线程，每个线程100W次，总点赞数出来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderDemo2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ClickNumberNet clickNumberNet = <span class="keyword">new</span> ClickNumberNet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime;</span><br><span class="line">        <span class="keyword">long</span> endTime;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">50</span>);</span><br><span class="line">        CountDownLatch countDownLatch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">50</span>);</span><br><span class="line">        CountDownLatch countDownLatch3 = <span class="keyword">new</span> CountDownLatch(<span class="number">50</span>);</span><br><span class="line">        CountDownLatch countDownLatch4 = <span class="keyword">new</span> CountDownLatch(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=<span class="number">100</span> * <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        clickNumberNet.clickBySync();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickBySync result: &quot;</span>+clickNumberNet.number);</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=<span class="number">100</span> * <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        clickNumberNet.clickByAtomicLong();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch2.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickByAtomicLong result: &quot;</span>+clickNumberNet.atomicLong);</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=<span class="number">100</span> * <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        clickNumberNet.clickByLongAdder();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch3.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickByLongAdder result: &quot;</span>+clickNumberNet.longAdder.sum());</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=<span class="number">100</span> * <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        clickNumberNet.clickByLongAccumulator();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch4.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch4.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickByLongAccumulator result: &quot;</span>+clickNumberNet.longAccumulator.longValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LongAdder原理分析"><a href="#LongAdder原理分析" class="headerlink" title="LongAdder原理分析"></a>LongAdder原理分析</h3><p><strong>继承关系</strong></p><img src="/2022/08/11/juc-xue-xi-bi-ji/024.png" class=""><p>继承Striped64类</p><h4 id="Striped64全局变量分析"><a href="#Striped64全局变量分析" class="headerlink" title="Striped64全局变量分析"></a>Striped64全局变量分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Number of CPUS, to place bound on table size </span></span><br><span class="line"><span class="comment">当前计算机CPU数量,Cell数组扩容时会使用到</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table of cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base value, used mainly when there is no contention, but also as</span></span><br><span class="line"><span class="comment"> * a fallback during table initialization races. Updated via CAS.</span></span><br><span class="line"><span class="comment"> 类似于AtomicLong中全局的value值。再没有竞争情况下数据直接累加到base上,或者cells扩容时,也需要将数据写入到base上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spinlock (locked via CAS) used when resizing and/or creating Cells.</span></span><br><span class="line"><span class="comment"> 初始化cells或者扩容cells需要获取锁,0表示无锁状态,1表示其他线程已经持有了锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><h4 id="Striped64内部类Cell"><a href="#Striped64内部类Cell" class="headerlink" title="Striped64内部类Cell"></a>Striped64内部类Cell</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Padded variant of AtomicLong supporting only raw accesses plus CAS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * JVM intrinsics note: It would be possible to use a release-only</span></span><br><span class="line"><span class="comment"> * form of CAS here, if it were provided.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分散热点技术"><a href="#分散热点技术" class="headerlink" title="分散热点技术"></a>分散热点技术</h4><img src="/2022/08/11/juc-xue-xi-bi-ji/025.png" class=""><p><strong>LongAdder#add</strong></p><ol><li>最初无竞争时,直接通过casBase进行更新base的处理，跳过if，当casBase比较激烈，则进入if判断</li><li>调用longAccumulate:如果更新base失败后,首次新建一个Cell[]数组(默认长度是2)</li><li>调用longAccumulate:如果Cell数组当中的某一个槽位为空</li><li>调用longAccumulate:当多个线程竞争同一个cell比较激烈时,可能就要对Cell[]扩容<img src="/2022/08/11/juc-xue-xi-bi-ji/026.png" class=""></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   LongAdder.<span class="function">java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//as是striped64中的cells数组</span></span><br><span class="line"><span class="comment">//b是striped64中的base</span></span><br><span class="line"><span class="comment">//v是当前线程hash到的cell中存储的值</span></span><br><span class="line"><span class="comment">//m是cells的长度减1,hash时作为掩码使用</span></span><br><span class="line"><span class="comment">//a时当前线程hash到的cell</span></span><br><span class="line">       Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">首次首线程(as = cells) != null)一定是false,此时走casBase方法,以CAS的方式更新base值,</span></span><br><span class="line"><span class="comment">且只有当cas失败时,才会走到if中</span></span><br><span class="line"><span class="comment">条件1:cells不为空,说明出现过竞争,cell[]已创建</span></span><br><span class="line"><span class="comment">条件2:cas操作base失败,说明其他线程先一步修改了base正在出现竞争</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line"><span class="comment">//true无竞争 fasle表示竞争激烈,多个线程hash到同一个cell,可能要扩容</span></span><br><span class="line">           <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">条件1:cells为空,说明正在出现竞争,上面是从条件2过来的,说明!casBase(b = base, b + x))=true</span></span><br><span class="line"><span class="comment">  会通过调用longAccumulate(x, null, uncontended)新建一个数组,默认长度是2</span></span><br><span class="line"><span class="comment">条件2:默认会新建一个数组长度为2的数组,m = as.length - 1) &lt; 0 应该不会出现,</span></span><br><span class="line"><span class="comment">条件3:当前线程所在的cell为空,说明当前线程还没有更新过cell,应初始化一个cell。</span></span><br><span class="line"><span class="comment">  a = as[getProbe() &amp; m]) == null,如果cell为空,进行一个初始化的处理</span></span><br><span class="line"><span class="comment">条件4:更新当前线程所在的cell失败,说明现在竞争很激烈,多个线程hash到同一个Cell,应扩容</span></span><br><span class="line"><span class="comment">  (如果是cell中有一个线程操作,这个时候,通过a.cas(v = a.value, v + x)可以进行处理,返回的结果是true)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">           <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">    <span class="comment">//getProbe( )方法返回的时线程中的threadLocalRandomProbe字段</span></span><br><span class="line"><span class="comment">//它是通过随机数生成的一个值,对于一个确定的线程这个值是固定的(除非刻意修改它)</span></span><br><span class="line">               (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">               !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line"><span class="comment">//调用Striped64中的方法处理</span></span><br><span class="line">               longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>Striped64#longAccumulate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line"><span class="comment">//存储线程的probe值</span></span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">//如果getProbe()方法返回0,说明随机数未初始化</span></span><br><span class="line"><span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123; <span class="comment">//这个if相当于给当前线程生成一个非0的hash值</span></span><br><span class="line"><span class="comment">//使用ThreadLocalRandom为当前线程重新计算一个hash值,强制初始化</span></span><br><span class="line">ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line"><span class="comment">//重新获取probe值,hash值被重置就好比一个全新的线程一样,所以设置了wasUncontended竞争状态为true</span></span><br><span class="line">h = getProbe();</span><br><span class="line"><span class="comment">//重新计算了当前线程的hash后认为此次不算是一次竞争,都未初始化,肯定还不存在竞争激烈</span></span><br><span class="line"><span class="comment">//wasUncontended竞争状态为true</span></span><br><span class="line">wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/11/juc-xue-xi-bi-ji/027.png" class=""><p><strong>CASE2：刚刚初始化Cell[]数组（首次新建）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CASE2:cells没有加锁且没有初始化,则尝试对它进行加锁,并初始化cells数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cellsBusy:初始化cells或者扩容cells需要获取锁,0表示无锁状态,1表示其他线程已经持有了锁</span></span><br><span class="line"><span class="comment">cells == as == null  是成立的</span></span><br><span class="line"><span class="comment">casCellsBusy:通过CAS操作修改cellsBusy的值,CAS成功代表获取锁,</span></span><br><span class="line"><span class="comment">返回true,第一次进来没人抢占cell单元格,肯定返回true</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123; </span><br><span class="line">    <span class="comment">//是否初始化的标记</span></span><br><span class="line"><span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table(新建cells)</span></span><br><span class="line"><span class="comment">// 前面else if中进行了判断,这里再次判断,采用双端检索的机制</span></span><br><span class="line"><span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line"><span class="comment">//如果上面条件都执行成功就会执行数组的初始化及赋值操作,Cell[] rs = new Cell[2]标识数组的长度为2</span></span><br><span class="line">Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//rs[h &amp; 1] = new Cell(x)表示创建一个新的cell元素,value是x值,默认为1</span></span><br><span class="line"><span class="comment">//h &amp; 1 类似于我们之前hashmap常用到的计算散列桶index的算法,</span></span><br><span class="line"><span class="comment">//通常都是hash&amp;(table.len-1),同hashmap一个意思</span></span><br><span class="line"><span class="comment">//看这次的value是落在0还是1</span></span><br><span class="line">rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">cells = rs;</span><br><span class="line">init = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">cellsBusy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (init)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CASE3:兜底(多个线程尝试CAS修改失败的线程会走这个分支)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CASE3:cells正在进行初始化,则尝试直接在基数base上进行累加操作</span></span><br><span class="line"><span class="comment">//这种情况是cell中都CAS失败了,有一个兜底的方法</span></span><br><span class="line"><span class="comment">//该分支实现直接操作base基数,将值累加到base上,</span></span><br><span class="line"><span class="comment">//也即其他线程正在初始化,多个线程正在更新base的值</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">fn.applyAsLong(v, x))))</span><br><span class="line"><span class="keyword">break</span>;     </span><br></pre></td></tr></table></figure><p><strong>CASE1 : Cell数组不再为空且可能存在Cell数组扩容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line"><span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123; <span class="comment">// CASE1:cells已经初始化了</span></span><br><span class="line">    <span class="comment">// 当前线程的hash值运算后映射得到的Cell单元为null,说明该Cell没有被使用</span></span><br><span class="line"><span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//Cell[]数组没有正在扩容</span></span><br><span class="line"><span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line"><span class="comment">//先创建一个Cell</span></span><br><span class="line">Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line"><span class="comment">//尝试加锁,加锁后cellsBusy=1</span></span><br><span class="line"><span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; </span><br><span class="line"><span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">Cell[] rs; <span class="keyword">int</span> m, j; <span class="comment">//将cell单元赋值到Cell[]数组上</span></span><br><span class="line"><span class="comment">//在有锁的情况下再检测一遍之前的判断 </span></span><br><span class="line"><span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">(m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">rs[j] = r;</span><br><span class="line">created = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">cellsBusy = <span class="number">0</span>;<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (created)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">collide = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">wasUncontended表示cells初始化后,当前线程竞争修改失败</span></span><br><span class="line"><span class="comment">wasUncontended=false,表示竞争激烈,需要扩容,这里只是重新设置了这个值为true,</span></span><br><span class="line"><span class="comment">紧接着执行advanceProbe(h)重置当前线程的hash,重新循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line"><span class="comment">//说明当前线程对应的数组中有了数据,也重置过hash值</span></span><br><span class="line"><span class="comment">//这时通过CAS操作尝试对当前数中的value值进行累加x操作,x默认为1,如果CAS成功则直接跳出循环</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line"> fn.applyAsLong(v, x))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//如果n大于CPU最大数量,不可扩容,并通过下面的h=advanceProbe(h)方法修改线程的probe再重新尝试</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">collide = <span class="keyword">false</span>;    <span class="comment">//扩容标识设置为false,标识永远不会再扩容</span></span><br><span class="line"><span class="comment">//如果扩容意向collide是false则修改它为true,然后重新计算当前线程的hash值继续循环</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!collide) </span><br><span class="line">collide = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//锁状态为0并且将锁状态修改为1(持有锁) </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line"><span class="comment">//按位左移1位来操作,扩容大小为之前容量的两倍</span></span><br><span class="line">Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="comment">//扩容后将之前数组的元素拷贝到新数组中</span></span><br><span class="line">rs[i] = as[i];</span><br><span class="line">cells = rs; </span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//释放锁设置cellsBusy=0,设置扩容状态,然后进行循环执行</span></span><br><span class="line">cellsBusy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">collide = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">&#125;</span><br><span class="line">h = advanceProbe(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>LongAdder#sum</strong><br>LongAdder# sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去,从而降级更新热点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为啥高并发下sum的值不精确? sum执行时,并没有限制对base和cells的更新(一句要命的话)。所以LongAdder不是强一致性,它是最终—致性的</p><ul><li>首先最终返回的sum局部变量,初始被赋值为base,而最终返回时,很可能base已经被更新了而此时局部变量sum不会更新,造成不—致</li><li>其次这里对cell的读取也无法保证是最后一次写入的值。所以,sum方法只是在没有并发的情况下,可以获得正确的结果</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>JUC并发编程目录—— <a class="link"   href="https://blog.csdn.net/TZ845195485/article/details/109210095" >https://blog.csdn.net/TZ845195485/article/details/109210095<i class="fas fa-external-link-alt"></i></a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="https://up-bear.github.io/2022/08/06/redis-xue-xi-bi-ji/"/>
    <id>https://up-bear.github.io/2022/08/06/redis-xue-xi-bi-ji/</id>
    <published>2022-08-06T15:16:52.000Z</published>
    <updated>2022-08-11T15:11:48.843Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><p><strong>1. String</strong></p><ul><li><p>Json格式：将Java对象转换为Json格式字符串，然后再进行存储。</p><ul><li>优点：占用空间较小（string类型数据优化较好）</li><li>缺点：不适合对象频繁修改的场景。需要修改时，首先从redis中获取Json字符串，然后利用工具类例如FastJson、JackJson等转换为Java对象，进行修改后再转化为Json字符串存储到redis中。</li></ul></li><li><p>序列化方式：将Java对象序列化后存入redis string类型中。</p></li></ul><p><strong>2. Hash</strong><br>将Java对象的每个属性转换为Hash的每个filed，属性值转换为value。</p><ul><li>优点：可以对对象的每个属性单独操作。</li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p><strong>目的</strong>：减少数据库的IO压力，提高响应速度。</p><p><strong>流程</strong>：请求数据时，首先到缓存中查找数据，若有则直接返回数据；若没有则去查询数据库，将数据返回并将数据写入缓存。</p><p><strong>缓存淘汰</strong>：当内存占用过多时，需要对缓存进行淘汰。<br>内存淘汰和超时剔除都是由redis提供的，主动更新需要自己手动维护缓存。</p><ul><li>内存淘汰：redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</li><li>超时剔除：当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</li><li>主动更新：手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</li></ul><p><strong>缓存更新</strong>：若数据库中的数据发生更改时，此时缓存中的数据便和数据库不一致，需要更新缓存，与数据库进行同步。</p><ul><li>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</li><li>Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</li><li>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</li></ul><p>采用人工编码方式时，更新缓存有两种方式：</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul><p>删除缓存的优点：如果数据库发生多次修改，而此期间没有数据访问请求，则缓存进行了多次的无效更新操作。相比之下，删除缓存则只有请求进入时进行更新，只进行一次更新操作。</p><p><strong>删除缓存：是先操作数据库再删缓存，还是先删缓存再操作数据库？</strong></p><ul><li>先操作数据库再删缓存：首先<strong>线程1</strong>进入，删除缓存后，<strong>线程2</strong>进入。此时线程2查询缓存失败，操作数据库后更新缓存，然后<strong>线程1</strong>操作数据库，最终数据库中的数据为<strong>线程1</strong>的数据，缓存中为<strong>线程2</strong>的数据，造成不一致。</li><li>先删缓存再操作数据库：首先<strong>线程1</strong>查询缓存，缓存失效，开始操作数据库，在<strong>线程1</strong>完成数据库操作后，写入缓存之前，<strong>线程2</strong>进入，由于此时缓存仍是失效的，开始操作数据库，然后删缓存。<strong>线程2</strong>删缓存后线程1执行写缓存，最终数据库中的数据为<strong>线程2</strong>的数据，缓存中为<strong>线程1</strong>的数据，造成不一致。<ul><li>此情况发生的条件是，<strong>线程1</strong>查缓存时缓存失效，而且由于<strong>线程1完成操作数据库到开始写入缓存之前的间隔</strong>远小于<strong>线程2执行操作数据库加删缓存所需时间（操作数据库耗时较大）</strong>。因此这种情况发生的概率远小于<strong>先操作数据库再删缓存</strong>。<img src="/2022/08/06/redis-xue-xi-bi-ji/003.png" class=""></li></ul></li></ul><p><strong>如何保证缓存与数据库的操作的同时成功或失败？</strong></p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>缓存穿透</strong>：客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当客户端访问不存在的数据时，先请求redis，redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库。简单的解决方案就是哪怕这个数据在数据库中也不存在，也把这个数据存入到redis中去，这样下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到数据库了。</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，假设布隆过滤器判断这个数据不存在，则直接返回。这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><img src="/2022/08/06/redis-xue-xi-bi-ji/004.png" class=""><p>缓存穿透的解决方案有哪些？</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩</strong>：在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>缓存击穿</strong>：也称热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p><strong>逻辑分析</strong>：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大。</p><img src="/2022/08/06/redis-xue-xi-bi-ji/005.png" class=""><p>解决方案一：使用锁来解决<br>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。<br>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><img src="/2022/08/06/redis-xue-xi-bi-ji/006.png" class=""><p>解决方案二：逻辑过期方案<br>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。<br>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。<br>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><img src="/2022/08/06/redis-xue-xi-bi-ji/007.png" class=""><p><strong>两种方案对比：</strong><br><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响<br><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><img src="/2022/08/06/redis-xue-xi-bi-ji/008.png" class=""><p> 悲观锁：可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等<br>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如CAS（将数据本身视为版本号）</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><img src="/2022/08/06/redis-xue-xi-bi-ji/009.png" class=""><p><strong>分布式锁满足特性</strong>：</p><ul><li>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li><li>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</li><li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li><li>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全也是程序中必不可少的一环</li></ul><p><strong>常见三种分布式锁</strong>：</p><ul><li>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</li><li>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</li><li>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</li></ul><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li>获取锁：<ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li>释放锁：<ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul></li></ul><p><strong>核心思路</strong>：<br>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><p><strong>分布式锁要点</strong>：</p><ol><li><p>死锁<br>场景：拥有锁的线程阻塞或宕机，导致锁无法释放<br>解决方案：通过对锁添加过期时间，防止出现死锁</p></li><li><p>误删锁<br>场景：线程1在业务过程中出现阻塞，导致锁释放。线程2拿到锁，进行业务操作，但是在操作过程中线程1恢复运行，释放了线程2的锁，这便是锁误删问题。<br>解决方案：在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，不属于则不进行锁的删除。<br>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p></li></ol><p><strong>代码实现</strong>（非最终版，还未引入Lua脚本解决原子性问题）</p><ul><li>加锁：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID_PREFIX = UUID.randomUUID().toString(<span class="keyword">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeoutSec)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   String threadId = ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   Boolean success = stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>释放锁：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    String threadId = ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>原子性问题<br>场景：线程1持有锁后，在执行业务逻辑过程中，正准备删除锁，而且已经走到了条件判断的过程中，正准备删除锁，但是此时锁已经到期了，同时线程2进来并获取到锁。但线程1接着往后执行删除锁操作，相当于条件判断并没有起到作用，这就是删锁时的原子性问题。此问题是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的。<br>解决方案：使用Lua脚本保证拿锁、比锁、删锁是一个原子性动作。</li></ol><p>操作redis的拿锁比锁删锁的lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>释放锁（引入Lua脚本）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        <span class="comment">//加载Lua脚本文件</span></span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>锁续期（见Redisson）</li><li>可重入（见Redisson）</li></ol><h1 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h1><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>于setnx实现的分布式锁存在下面的问题：</p><ul><li><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</li><li><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</li><li><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</li><li><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用Redission的分布式锁，注入对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br></pre></td></tr></table></figure></li></ol><h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><p>在Lock锁中，是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有锁，那么state=0，假如有人持有这把锁，那么state=1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。 </p><p>在redission中，我们的也支持支持可重入锁</p><p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式<br>这个地方一共有3个参数</p><ul><li><strong>KEYS[1] ： 锁名称</strong></li><li><strong>ARGV[1]：  锁失效时间</strong></li><li><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></li></ul><p>exists: 判断数据是否存在  name：是lock是否存在,如果==0，就表示当前这把锁不存在<br>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构<br>Lock{<br>    id + <strong>“:”</strong> + threadId :  1<br>}<br>如果当前这把锁存在，则第一个条件不满足，再判断<br>redis.call(‘hexists’, KEYS[1], ARGV[2]) == 1<br>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行<br>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)<br>将当前这个锁的value进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间<br>如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure><h2 id="锁重试与WatchDog"><a href="#锁重试与WatchDog" class="headerlink" title="锁重试与WatchDog"></a>锁重试与WatchDog</h2><h1 id="实践优化"><a href="#实践优化" class="headerlink" title="实践优化"></a>实践优化</h1><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><h3 id="key命名规范"><a href="#key命名规范" class="headerlink" title="key命名规范"></a>key命名规范</h3><ul><li>建议遵循：<code>[业务名称]:[数据名]:[id]</code>的层级结构</li><li>key的长度不建议超过44字节<br>  redis对字符串的编码方式有<code>int</code>，<code>embstr</code>，<code>raw</code>三种，key是纯数字时选择<code>int</code>编码，当<code>key</code>的长度超过44字节时会使用<code>raw</code>编码，小于44字节时会使用<code>embstr</code> 编码。</li><li>避免包含特殊字符</li></ul><h3 id="Bigkey"><a href="#Bigkey" class="headerlink" title="Bigkey"></a>Bigkey</h3><p><code>Bigkey</code>：占用空间较大的<code>key:value</code></p><p>查看<code>key</code>占用空间：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MEMORY USAGE keyName<span class="comment">#对CPU的消耗较大，不建议使用</span></span><br></pre></td></tr></table></figure><p>查看字符串长度：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN keyName<span class="comment">#推荐使用</span></span><br></pre></td></tr></table></figure><p>查看key中元素数量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN keyName<span class="comment">#查看列表中元素数量，推荐使用</span></span><br></pre></td></tr></table></figure><p>黑马推荐值：</p><ul><li>单个key的value小于10KB</li><li>对于集合类型的key，建议元素数量小于1000</li></ul><p><strong>Bigkey问题</strong>：</p><ul><li>网络阻塞：对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li><li>Redis阻塞：对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</li><li>CPU压力：BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</li></ul><p><strong>发现Bigkey</strong></p><ol><li><p>redis命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 密码 --bigkeys<span class="comment">#需要新开一个cmd窗口，不是在redis客户端里</span></span><br></pre></td></tr></table></figure></li><li><p>scan扫描：利用scan命令，编程扫描key</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure></li></ol><p>参数：<br>    - cursor：游标<br>    - pattern：匹配的模式<br>    - count：指定从数据集里返回多少元素，默认值为 10</p><p>scan 命令调用完后每次会返回2个元素，第一个是下一次迭代的光标，第一次光标会设置为0，当最后一次scan 返回的光标等于0时，表示整个scan遍历结束了，第二个返回的是List，一个匹配的key的数组</p><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> STR_MAX_LEN = <span class="number">10</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> HASH_MAX_LEN = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        String cursor = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 扫描并获取一部分key</span></span><br><span class="line">            ScanResult&lt;String&gt; result = jedis.scan(cursor);</span><br><span class="line">            <span class="comment">// 记录cursor</span></span><br><span class="line">            cursor = result.getCursor();</span><br><span class="line">            List&lt;String&gt; list = result.getResult();</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">                <span class="comment">// 判断key的类型</span></span><br><span class="line">                String type = jedis.type(key);</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">                        len = jedis.strlen(key);</span><br><span class="line">                        maxLen = STR_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;hash&quot;</span>:</span><br><span class="line">                        len = jedis.hlen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                        len = jedis.llen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;set&quot;</span>:</span><br><span class="line">                        len = jedis.scard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;zset&quot;</span>:</span><br><span class="line">                        len = jedis.zcard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &gt;= maxLen) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;Found big key : %s, type: %s, length or size: %d %n&quot;</span>, key, type, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!cursor.equals(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>第三方工具<br>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况<a class="link"   href="https://github.com/sripathikrishnan/redis-rdb-tools" >https://github.com/sripathikrishnan/redis-rdb-tools<i class="fas fa-external-link-alt"></i></a></p></li><li><p>网络监控</p></li></ol><ul><li>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</li><li>一般阿里云搭建的云服务器就有相关监控页面</li></ul><p><strong>删除Bigkey</strong><br>BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。<br>Redis 4.0以后：提供了异步删除的命令：unlink</p><h2 id="合适的数据类型"><a href="#合适的数据类型" class="headerlink" title="合适的数据类型"></a>合适的数据类型</h2><p>eg：存储一个User对象，有三种存储方式<br><strong>方式一：json字符串</strong><br>| user:1 | {“name”: “Jack”, “age”: 21} |<br>| :—-: | :————————-: |</p><p>优点：实现简单粗暴<br>缺点：数据耦合，不够灵活</p><p><strong>方式二：字段打散</strong></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><table><thead><tr><th align="center">user:1:name</th><th align="center">Jack</th></tr></thead><tbody><tr><td align="center">user:1:age</td><td align="center">21</td></tr></tbody></table><p>优点：可以灵活访问对象任意字段<br>缺点：占用空间大、没办法做统一控制</p><p><strong>方式三：hash（推荐）</strong></p><table>    <tr>        <td rowspan="2">user:1</td>        <td>name</td>        <td>jack</td>    </tr>    <tr>        <td>age</td>        <td>21</td>    </tr></table><p>优点：底层使用ziplist，空间占用小，可以灵活访问对象的任意字段<br>缺点：代码相对复杂</p><p>eg：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？</p><table>    <tr style="color:red">        <td>key</td>        <td>field</td>        <td>value</td>    </tr>    <tr>        <td rowspan="3">someKey</td>        <td>id:0</td>        <td>value0</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:999999</td>        <td>value999999</td>    </tr></table><p>存在的问题：hash的entry数量超过512时，会使用哈希表而不是ZipList，内存占用较多</p><p>redis hash类型底层有两种编码方式：<code>ziplist（压缩列表）</code>和<code>hashtable（哈希表）</code>。<br>可以通过修改配置文件来改变<code>ziplist</code>和<code>hashtable</code>的转换条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 配置当field-value超过512时(合起来1024),使用hashtable编码,至于为什么是1024,与ziplist有关,后面会讲述</span><br><span class="line">hash-max-ziplist-entries 512  </span><br><span class="line"># 配置当key的单个field或value长度超过64时,使用hashtable编码</span><br><span class="line">hash-max-ziplist-value 64  </span><br></pre></td></tr></table></figure><p><strong>方案一</strong><br>拆分为string类型</p><table>    <tr style="color:red">        <td>key</td>        <td>value</td>    </tr>    <tr>        <td>id:0</td>        <td>value0</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:999999</td>        <td>value999999</td>    </tr></table><p>存在的问题：</p><ul><li>string结构底层没有太多内存优化，内存占用较多</li><li>想要批量获取这些数据比较麻烦</li></ul><p><strong>方案二</strong><br>拆分为小的hash，将 id / 100 作为key， 将id % 100 作为field，这样每100个元素为一个Hash</p><table>    <tr style="color:red">        <td>key</td>        <td>field</td>        <td>value</td>    </tr>    <tr>        <td rowspan="3">key:0</td>        <td>id:00</td>        <td>value0</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:99</td>        <td>value99</td>    </tr>    <tr>        <td rowspan="3">key:1</td>        <td>id:00</td>        <td>value100</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:99</td>        <td>value199</td>    </tr>    <tr>        <td colspan="3">....</td>    </tr>    <tr>        <td rowspan="3">key:9999</td>        <td>id:00</td>        <td>value999900</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:99</td>        <td>value999999</td>    </tr></table><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSetBigKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">650</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;hello_&quot;</span> + i, <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;m2&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个hash进行存储</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testBigHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;test:big:hash&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用10000个string进行存储</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testBigString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;test:str:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用100个小hash进行存储</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSmallHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashSize = <span class="number">100</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(hashSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (i - <span class="number">1</span>) / hashSize;</span><br><span class="line">            <span class="keyword">int</span> v = i % hashSize;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + v, <span class="string">&quot;value_&quot;</span> + v);</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">                jedis.hmset(<span class="string">&quot;test:small:hash_&quot;</span> + k, map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h3 id="批量插入命令"><a href="#批量插入命令" class="headerlink" title="批量插入命令"></a>批量插入命令</h3><p>Redis提供了很多Mxxx这样的命令，可以实现批量插入数据，例如：</p><ul><li>mset</li><li>hmset</li></ul><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> String[<span class="number">2000</span>];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">long</span> b = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        j = (i % <span class="number">1000</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        arr[j] = <span class="string">&quot;test:key_&quot;</span> + i;</span><br><span class="line">        arr[j + <span class="number">1</span>] = <span class="string">&quot;value_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            jedis.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道Pipeline"><a href="#管道Pipeline" class="headerlink" title="管道Pipeline"></a>管道Pipeline</h3><p>MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用Pipeline</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    Pipeline pipeline = jedis.pipelined();</span><br><span class="line">    <span class="keyword">long</span> b = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 放入命令到管道</span></span><br><span class="line">        pipeline.set(<span class="string">&quot;test:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 每放入1000条命令，批量执行</span></span><br><span class="line">            pipeline.sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集群批处理"><a href="#集群批处理" class="headerlink" title="集群批处理"></a>集群批处理</h3><p>如MSET或Pipeline这样的批处理需要在一次请求中携带多条命令，而此时如果Redis是一个集群，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。大家可以想一想这样的要求其实很难实现，因为我们在批处理时，可能一次要插入很多条数据，这些数据很有可能不会都落在相同的节点上，这就会导致报错了。<br>4种解决方案</p><img src="/2022/08/06/redis-xue-xi-bi-ji/001.png" class=""><p>第一种方案：串行执行，所以这种方式没有什么意义，当然，执行起来就很简单了，缺点就是耗时过久。</p><p>第二种方案：串行slot，简单来说，就是执行前，客户端先计算一下对应的key的slot，一样slot的key就放到一个组里边，不同的，就放到不同的组里边，然后对每个组执行pipeline的批处理，他就能串行执行各个组的命令，这种做法比第一种方法耗时要少，但是缺点呢，相对来说复杂一点，所以这种方案还需要优化一下</p><p>第三种方案：并行slot，相较于第二种方案，在分组完成后串行执行，第三种方案，就变成了并行执行各个命令，所以他的耗时就非常短，但是实现呢，也更加复杂。</p><p>第四种：hash_tag，redis计算key的slot的时候，其实是根据key的有效部分来计算的，通过这种方式就能一次处理所有的key，这种方式耗时最短，实现也简单，但是如果通过操作key的有效部分，那么就会导致所有的key都落在一个节点上，产生数据倾斜的问题，所以我们推荐使用第三种方式。</p><p><strong>串行化执行代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        HashSet&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">7002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">7003</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">8001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">8002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">8003</span>));</span><br><span class="line">        jedisCluster = <span class="keyword">new</span> JedisCluster(nodes, poolConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testMSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jedisCluster.mset(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testMSet2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Male&quot;</span>);</span><br><span class="line">        <span class="comment">//对Map数据进行分组。根据相同的slot放在一个分组</span></span><br><span class="line">        <span class="comment">//key就是slot，value就是一个组</span></span><br><span class="line">        Map&lt;Integer, List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; result = map.entrySet()</span><br><span class="line">                .stream()</span><br><span class="line">                .collect(Collectors.groupingBy(</span><br><span class="line">                        entry -&gt; ClusterSlotHashUtil.calculateSlot(entry.getKey()))</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">//串行的去执行mset的逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Map.Entry&lt;String, String&gt;&gt; list : result.values()) &#123;</span><br><span class="line">            String[] arr = <span class="keyword">new</span> String[list.size() * <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                j = i&lt;&lt;<span class="number">2</span>;</span><br><span class="line">                Map.Entry&lt;String, String&gt; e = list.get(<span class="number">0</span>);</span><br><span class="line">                arr[j] = e.getKey();</span><br><span class="line">                arr[j + <span class="number">1</span>] = e.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            jedisCluster.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedisCluster != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedisCluster.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Spring集群批处理代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">testMSetInCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">     map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Female&quot;</span>);</span><br><span class="line">     stringRedisTemplate.opsForValue().multiSet(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; strings = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>));</span><br><span class="line">     strings.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在RedisAdvancedClusterAsyncCommandsImpl中，首先根据slotHash算出来一个partitioned的map，map中的key就是slot，而他的value就是对应的对应相同slot的key对应的数据通过 <code>RedisFuture&lt;String&gt; mset = super.mset(op)</code>进行异步的消息发送。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisFuture&lt;String&gt; <span class="title">mset</span><span class="params">(Map&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;K&gt;&gt; partitioned = SlotHash.partition(codec, map.keySet());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partitioned.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.mset(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, RedisFuture&lt;String&gt;&gt; executions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;K&gt;&gt; entry : partitioned.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;K, V&gt; op = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        entry.getValue().forEach(k -&gt; op.put(k, map.get(k)));</span><br><span class="line"></span><br><span class="line">        RedisFuture&lt;String&gt; mset = <span class="keyword">super</span>.mset(op);</span><br><span class="line">        executions.put(entry.getKey(), mset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MultiNodeExecution.firstOfAsync(executions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h2><p>Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：</p><ul><li>用来做缓存的Redis实例尽量不要开启持久化功能</li><li>建议关闭RDB持久化功能，使用AOF持久化</li><li>利用脚本定期在slave节点做RDB，实现数据备份</li><li>设置合理的rewrite阈值，避免频繁的bgrewrite</li><li>配置no-appendfsync-on-rewrite = yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</li><li>部署有关建议：<ul><li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li><li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li><li>不要与CPU密集型应用部署在一起</li><li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li></ul></li></ul><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>Redis执行时耗时超过某个阈值的命令，称为慢查询。</p><p>慢查询的危害：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的queue来执行，如果此时有一些慢查询的数据，就会导致大量请求阻塞，从而引起报错，所以我们需要解决慢查询问题。</p><p>慢查询的阈值可以通过配置指定：</p><ul><li>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</li></ul><p>慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：</p><ul><li>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</li></ul><p>使用<code>config set</code>修改配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> slowlog-log-slower-than 1000</span><br></pre></td></tr></table></figure><p><strong>查看慢查询：</strong></p><ul><li>slowlog len：查询慢查询日志长度</li><li>slowlog get [n]：读取n条慢查询日志</li><li>slowlog reset：清空慢查询列表</li></ul><h2 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h2><p>漏洞出现的核心的原因有以下几点：</p><ul><li>Redis未设置密码</li><li>利用了Redis的config set命令动态修改Redis配置</li><li>使用了Root账号权限启动Redis</li></ul><p>为了避免这样的漏洞，可以采用如下几种方案：</p><ul><li>Redis一定要设置密码</li><li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li><li>bind：限制网卡，禁止外网网卡访问</li><li>开启防火墙</li><li>不要使用Root账户启动Redis</li><li>尽量不是有默认的端口</li></ul><h2 id="内存划分与配置"><a href="#内存划分与配置" class="headerlink" title="内存划分与配置"></a>内存划分与配置</h2><p>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</p><p><strong>有关碎片问题分析</strong><br>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</p><p><strong>进程内存问题分析：</strong><br>这片内存，通常我们都可以忽略不计</p><p><strong>缓冲区内存问题分析：</strong><br>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，所以这片内存也是我们需要重点分析的内存问题。</p><table><thead><tr><th><strong>内存占用</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>数据内存</td><td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td></tr><tr><td>进程内存</td><td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td></tr><tr><td>缓冲区内存</td><td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td></tr></tbody></table><p>通过一些命令查看到Redis目前的内存分配状态：</p><ul><li>info memory：查看内存分配的情况</li><li>memory xxx：查看key的主要占用情况</li></ul><p>内存缓冲区常见的有三种：</p><ul><li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li><li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li><li>客户端缓冲区：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li></ul><p>以上复制缓冲区和AOF缓冲区 不会有问题，最关键就是客户端缓冲区的问题</p><p>客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，输入缓冲区最大1G且不能设置，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p><img src="/2022/08/06/redis-xue-xi-bi-ji/002.png" class=""><p>我们在使用redis过程中，处理大量的big value，那么会导致我们的输出结果过多，如果输出缓存区过大，会导致redis直接断开，而默认配置的情况下， 其实他是没有大小的，这就比较坑了，内存可能一下子被占满，会直接导致咱们的redis断开，所以解决方案有两个<br>1、设置一个大小<br>2、增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力</p><h2 id="集群与主从"><a href="#集群与主从" class="headerlink" title="集群与主从"></a>集群与主从</h2><p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p><ul><li><p>集群完整性问题</p></li><li><p>集群带宽问题</p></li><li><p>数据倾斜问题</p></li><li><p>客户端性能问题</p></li><li><p>命令的集群兼容性问题</p></li><li><p>lua和事务问题</p></li><li><p><em>问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：</em>*<br>大家可以设想一下，如果有几个slot不能使用，那么此时整个集群都不能用了，我们在开发中，其实最重要的是可用性，所以需要把如下配置修改成no，即有slot不能使用时，我们的redis集群还是可以对外提供服务</p></li></ul><p><strong>问题2、集群带宽问题</strong><br>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p><ul><li>插槽信息</li><li>集群状态信息</li></ul><p>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用，这是一个非常可怕的问题，所以我们需要去解决这样的问题</p><p><strong>解决途径：</strong></p><ul><li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。</li><li>避免在单个物理机中运行太多Redis实例</li><li>配置合适的cluster-node-timeout值</li></ul><p><strong>问题3、命令的集群兼容性问题</strong><br>有关这个问题咱们已经探讨过了，当我们使用批处理的命令时，redis要求我们的key必须落在相同的slot上，然后大量的key同时操作时，是无法完成的，所以客户端必须要对这样的数据进行处理，这些方案我们之前已经探讨过了，所以不再这个地方赘述了。</p><p><strong>问题4、lua和事务的问题</strong><br>lua和事务都是要保证原子性问题，如果你的key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的</p><p><strong>那我们到底是集群还是主从</strong></p><p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Redis数据类型及编码格式——Hash篇：<a class="link"   href="https://blog.csdn.net/qq_33983753/article/details/123063712" >https://blog.csdn.net/qq_33983753/article/details/123063712<i class="fas fa-external-link-alt"></i></a></li></ol><h1 id="待办"><a href="#待办" class="headerlink" title="待办"></a>待办</h1><ol><li>redis实战.md——全局ID</li><li>redis实战.md——一人一单：事务</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mybatis-Plus学习笔记</title>
    <link href="https://up-bear.github.io/2022/08/02/mybatis-plus-xue-xi-bi-ji/"/>
    <id>https://up-bear.github.io/2022/08/02/mybatis-plus-xue-xi-bi-ji/</id>
    <published>2022-08-02T12:24:31.000Z</published>
    <updated>2022-08-02T13:01:35.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><ol><li><p>引入依赖<br>Mybatis-Plus、数据库依赖（eg：Mysql）、Lombok（生成set、get、构造器等）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：3.5.2 版本中@TableName、@MapperScan注解似乎没有了</p></li><li><p>构造实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>   <span class="comment">//get、set方法</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_user&quot;)</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>  <span class="comment">//无参构造器</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">//有参构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId(&quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;USER_NAME&quot;)</span> <span class="keyword">private</span> String userName; <span class="comment">//驼峰命名,则无需注解</span></span><br><span class="line">    <span class="meta">@TableField(&quot;PASSWORD&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Mapper，集成BaseMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>扫描mapper所在包<br>在启动类或测试类上添加<code>@MapperScan(&quot;包名&quot;)</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringCloud学习笔记</title>
    <link href="https://up-bear.github.io/2022/07/15/springcloud-xue-xi-bi-ji/"/>
    <id>https://up-bear.github.io/2022/07/15/springcloud-xue-xi-bi-ji/</id>
    <published>2022-07-15T05:39:43.000Z</published>
    <updated>2022-08-01T13:59:17.492Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="EureKa"><a href="#EureKa" class="headerlink" title="EureKa"></a>EureKa</h1><h2 id="EureKa注册中心"><a href="#EureKa注册中心" class="headerlink" title="EureKa注册中心"></a>EureKa注册中心</h2><ol><li>maven依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>使用注解@EnableEureKa编写Application启动类</li><li>添加配置信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">port: 10086</span><br><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">name: eurekaserver</span><br><span class="line">eureka:</span><br><span class="line">client:</span><br><span class="line">service-url:</span><br><span class="line">defaultZone: http://127.0.0.1:10086/eureka/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="EureKa服务者注册"><a href="#EureKa服务者注册" class="headerlink" title="EureKa服务者注册"></a>EureKa服务者注册</h3></li><li>maven依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>添加配置信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">port: 10086</span><br><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">name: client1</span><br><span class="line">eureka:</span><br><span class="line">client:</span><br><span class="line">service-url:</span><br><span class="line">defaultZone: http://127.0.0.1:10086/client1/</span><br></pre></td></tr></table></figure><h3 id="EureKa消费者注册"><a href="#EureKa消费者注册" class="headerlink" title="EureKa消费者注册"></a>EureKa消费者注册</h3>步骤同服务者注册。但需添加http请求模块，以便于向其他微服务模块发送请求。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced//一个微服务模块有多个实例时，开启负载均衡</span><br><span class="line">public RestTemplate restTemplate()&#123;</span><br><span class="line">return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>发送请求时，使用注册时的服务名代替 ip 和端口，eg<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;http://servicename/user/&quot; + order.getUserId();</span><br></pre></td></tr></table></figure><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2>EureKa的负载均衡组件。<h3 id="选择负载均衡策略"><a href="#选择负载均衡策略" class="headerlink" title="选择负载均衡策略"></a>选择负载均衡策略</h3>方式一：手动添加负载均衡组件 IRule。这种配置方式是全局的，无论调用哪一个微服务都会采用该策略。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//选择随机策略的组件</span><br><span class="line">@Bean</span><br><span class="line">public IRule randomRule()&#123;</span><br><span class="line">return new RandomRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>方式二：配置文件方式。该方式只对被配置的微服务生效。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice:</span><br><span class="line">ribbon:</span><br><span class="line">NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure><h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3>Ribbon默认采用懒加载方式，即接受到第一次请求后才开始加载。<br>开启饥饿加载，即启动时加载。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">eager-load:</span><br><span class="line">enabled: true #开启饥饿加载</span><br><span class="line">clients: userservice #指定劝userservice这个服务饥饿加载</span><br></pre></td></tr></table></figure><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1></li><li>下载Nacos</li><li>项目父工程引入依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>微服务引入Nacos依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>微服务配置Nacos<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">nacos:</span><br><span class="line">server-addr: localhost:8848</span><br></pre></td></tr></table></figure>PS：微服务需要有<code>资源</code>启动后在控制台才能看到注册的微服务，<code>资源</code>是可以被访问的方法等，踩大坑！</li></ol><h2 id="Nacos集群"><a href="#Nacos集群" class="headerlink" title="Nacos集群"></a>Nacos集群</h2><p>Nacos默认优先访问同一集群下的微服务，多个微服务实例间是随机访问。当本地微服务不可用时会发生跨集群访问。<br>集群配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">nacos:</span><br><span class="line">server-addr: localhost:8848</span><br><span class="line">discovery:</span><br><span class="line">cluster-name: HZ #集群名称</span><br></pre></td></tr></table></figure><p>设置负载均衡方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice:</span><br><span class="line">ribbon:</span><br><span class="line">NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule</span><br></pre></td></tr></table></figure><h2 id="Nacos环境隔离"><a href="#Nacos环境隔离" class="headerlink" title="Nacos环境隔离"></a>Nacos环境隔离</h2><p>在Nacos控制台进行环境管理，不同环境下的微服务之间是相互隔离的，无法访问。<br>配置临时实例为true，开启注册中心主动询问微服务实例状态，频率较高，对服务器的开销比较大。临时实例为false，微服务实例主动向注册中心发送心跳信息，频率较低，开销较小。<br>与EureKa不同，如果Nacos注册中心发现有一个微服务实例不可用，则会主动向消费者推送信息，更新微服务实例列表。</p><h2 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h2><h3 id="远程环境配置"><a href="#远程环境配置" class="headerlink" title="远程环境配置"></a>远程环境配置</h3><ol><li>在Nacos控制台创建配置文件 eg：userservice-dev.yml</li><li>在微服务实例中添加bootstrap.yml文件，将需要从 application.yml 剥离的配置信息改到 bootstrap.yml ，例如Nacos地址，微服务名称等（SpringCloud负责加载 bootstrap.yml，会先于SpringBoot加载application.yml）</li><li>配置热更新<br>方式一：使用 @Value 和 @RefreshScope 刷新<br>方式二：使用 @ConfigurationProperties 实现<h3 id="远程共享配置"><a href="#远程共享配置" class="headerlink" title="远程共享配置"></a>远程共享配置</h3>多个实例间共享设置，eg：userservice.yml<br>配置生效优先级：远程环境配置 &gt; 远程共享配置 &gt; 本地配置<img src="/2022/07/15/springcloud-xue-xi-bi-ji/001.jpg" class=""><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3></li><li>搭建MySQL集群并初始化数据库表</li><li>下载解压nacos</li><li>修改集群配置（节点信息）、数据库配置</li><li>分别启动多个nacos节点</li><li>nginx反向代理<h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2>较RestTemplate更为强大的http客户端。<br>使用步骤：</li><li>引入 maven 依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>启动类添加 @EnableFeignClients 注解</li><li>编写 FeignClient 接口<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(&quot;userservice&quot;)</span><br><span class="line">public interface UserClient &#123;</span><br><span class="line">@GetMapping(&quot;/user/&#123;id&#125;&quot;) </span><br><span class="line">User findById(@PathVariable(&quot;id&quot;) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 FeginClient<h3 id="Feign日志级别"><a href="#Feign日志级别" class="headerlink" title="Feign日志级别"></a>Feign日志级别</h3>方式一：配置文件方式</li><li>全局生效<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">client:</span><br><span class="line">config:</span><br><span class="line">default: #对所有微服务生效</span><br><span class="line">loggerLevel: FULL #  日志级别 </span><br></pre></td></tr></table></figure></li><li>局部生效<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">client:</span><br><span class="line">config:</span><br><span class="line">userservice: #只对userservice生效</span><br><span class="line">loggerLevel: FULL #  日志级别 </span><br></pre></td></tr></table></figure>方式二：代码方式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FeignClientConfiguration &#123;</span><br><span class="line">@Bean</span><br><span class="line">public Logger.Level feignLogLevel()&#123;</span><br><span class="line">return Logger.Level.BASIC;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>全局配置，则把它放到@EnableFeignClients这个注解中：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)</span><br></pre></td></tr></table></figure></li><li>局部配置，则把它放到@FeignClient这个注解中：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value = &quot;userservice&quot;, configuration = FeignClientConfiguration.class) </span><br></pre></td></tr></table></figure><h3 id="设置Feign底层Http客户端"><a href="#设置Feign底层Http客户端" class="headerlink" title="设置Feign底层Http客户端"></a>设置Feign底层Http客户端</h3>Feign底层的客户端实现：<br> URLConnection：默认实现，不支持连接池<br> Apache HttpClient ：支持连接池<br> OKHttp：支持连接池<br>配置HttpClient</li><li>引入maven依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--httpClient的依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>配置连接池<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">client:</span><br><span class="line">config:</span><br><span class="line">default: # default全局的配置</span><br><span class="line">loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息</span><br><span class="line">httpclient:</span><br><span class="line">enabled: true # 开启feign对HttpClient的支持</span><br><span class="line">max-connections: 200 # 最大的连接数</span><br><span class="line">max-connections-per-route: 50 # 每个路径的最大连接数</span><br></pre></td></tr></table></figure><h3 id="抽取FeignClient模块"><a href="#抽取FeignClient模块" class="headerlink" title="抽取FeignClient模块"></a>抽取FeignClient模块</h3>ps：也可以选择继承父接口的方式。</li><li>首先创建一个module，命名为feign-api，然后引入feign的starter依赖</li><li>将order-service中编写的UserClient、User等要抽取的内容都复制到feign-api项目中</li><li>在order-service（需要使用feign-api）中引入feign-api的依赖</li><li>修改order-service，改成导入feign-api中的包</li><li>指定加载FeignClient类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方式一</span><br><span class="line">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)//扫描FeignClient所在整个模块</span><br><span class="line">//方式二</span><br><span class="line">@EnableFeignClients(clients = &#123;UserClient.class&#125;)//直接指定加载FeignClient</span><br></pre></td></tr></table></figure></li><li>重启测试<h2 id="网关Gateway"><a href="#网关Gateway" class="headerlink" title="网关Gateway"></a>网关Gateway</h2>使用步骤：</li><li>创建项目，引入依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--网关依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--nacos服务发现依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>编写路由配置及nacos地址<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10010 # 网关端口</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway # 服务名称</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848 # nacos地址</span><br><span class="line">    gateway:</span><br><span class="line">      routes: # 网关路由配置</span><br><span class="line">        - id: user-service # 路由id，自定义，只要唯一即可</span><br><span class="line">          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></pre></td></tr></table></figure><h3 id="Gateway路由断言工厂"><a href="#Gateway路由断言工厂" class="headerlink" title="Gateway路由断言工厂"></a>Gateway路由断言工厂</h3>Gateway提供多种断言工厂——Route Predicate Factory，对进入的请求进行判断。<img src="/2022/07/15/springcloud-xue-xi-bi-ji/002.jpg" class=""><h3 id="路由过滤器GatewayFilter"><a href="#路由过滤器GatewayFilter" class="headerlink" title="路由过滤器GatewayFilter"></a>路由过滤器GatewayFilter</h3>对进入网关的请求和微服务返回的响应做处理。<img src="/2022/07/15/springcloud-xue-xi-bi-ji/003.jpg" class="">eg: 给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes: # 网关路由配置</span><br><span class="line">                - id: user-service</span><br><span class="line">                  uri: lb://userservice</span><br><span class="line">                  predicates:</span><br><span class="line">                    - Path=/user/**</span><br><span class="line">                  filters: # 过滤器</span><br><span class="line">                    - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头</span><br></pre></td></tr></table></figure>默认过滤器：对所有的路由都生效，将过滤器工厂写到default下。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">name: gateway # 服务名称</span><br><span class="line">cloud:</span><br><span class="line">nacos:</span><br><span class="line">server-addr: localhost:8848 # nacos地址</span><br><span class="line">gateway:</span><br><span class="line">routes: # 网关路由配置</span><br><span class="line">                    - id: user-service </span><br><span class="line">                      uri: lb://userservice</span><br><span class="line">                      predicates:</span><br><span class="line">                        - Path=/user/**</span><br><span class="line">                    - id: order-service</span><br><span class="line">                      uri: lb://orderservice</span><br><span class="line">                      predicates:</span><br><span class="line">                        - Path=/order/**</span><br><span class="line">default-filters: # 默认过滤器，会对所有的路由请求都生效- AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头</span><br></pre></td></tr></table></figure><h3 id="自定义全局过滤器GlobalFilter"><a href="#自定义全局过滤器GlobalFilter" class="headerlink" title="自定义全局过滤器GlobalFilter"></a>自定义全局过滤器GlobalFilter</h3>处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。自定义过滤器的代码处理逻辑，需要实现GlobalFilter接口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public interface GlobalFilter &#123;</span><br><span class="line">/**</span><br><span class="line">*  处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理</span><br><span class="line">    *</span><br><span class="line">    * @param exchange 请求上下文，里面可以获取Request、Response等信息</span><br><span class="line">    * @param chain 用来把请求委托给下一个过滤器 </span><br><span class="line">    * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span><br><span class="line">    */</span><br><span class="line">    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件</span><br><span class="line">* 参数中是否有authorization</span><br><span class="line">* authorization参数值是否为admin,如果同时满足则放行，否则拦截</span><br><span class="line">*/</span><br><span class="line">@Order(-1)//让类实现Ordered接口，实现接口方法与使用注解效果是一样的</span><br><span class="line">@Component</span><br><span class="line">public class AuthorizeFilter implements GlobalFilter &#123;</span><br><span class="line">@Override</span><br><span class="line">public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        // 1.获取请求参数</span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        // 2.获取authorization参数</span><br><span class="line">        String auth = params.getFirst(&quot;authorization&quot;);</span><br><span class="line">        // 3.校验</span><br><span class="line">        if (&quot;admin&quot;.equals(auth)) &#123;</span><br><span class="line">        // 放行</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        // 4.拦截</span><br><span class="line">        // 4.1.禁止访问 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        // 4.2.结束处理</span><br><span class="line">        return exchange.getResponse().setComplete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h3></li><li>order值越小，优先级越高</li><li>当order值一样时，顺序是defaultFilter最先，然后是局部的路由过滤器，最后是全局过滤器<h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3>浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题。<br>解决方案：CORS<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">globalcors: # 全局的跨域处理</span><br><span class="line">add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题</span><br><span class="line">corsConfigurations:</span><br><span class="line">&#x27;[/**]&#x27;:</span><br><span class="line">allowedOrigins: # 允许哪些网站的跨域请求</span><br><span class="line">- &quot;http://localhost:8090&quot;</span><br><span class="line">- &quot;http://www.leyou.com&quot;</span><br><span class="line">allowedMethods: # 允许的跨域ajax的请求方式</span><br><span class="line">                        - &quot;GET&quot;           </span><br><span class="line">                        - &quot;POST&quot;</span><br><span class="line">                        - &quot;DELETE&quot;</span><br><span class="line">                        - &quot;PUT&quot;</span><br><span class="line">                        - &quot;OPTIONS&quot;</span><br><span class="line">allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息</span><br><span class="line">allowCredentials: true # 是否允许携带cookie     maxAge: 360000 # 这次跨域检测的有效期</span><br></pre></td></tr></table></figure><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2></li><li>拉取镜像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx//不写版本号默认拉取最新版</span><br></pre></td></tr></table></figure></li><li>查看镜像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li><li>删除镜像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure></li><li>保存、导入镜像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br><span class="line">eg: </span><br><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure></li><li>加载镜像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><img src="/2022/07/15/springcloud-xue-xi-bi-ji/004.jpg" class=""></li></ol><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><ol><li>创建容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br><span class="line">ps:</span><br><span class="line">containName 为容器所取名称</span><br><span class="line">-p 映射端口，左侧为主机端口，右侧为容器端口</span><br><span class="line">-d 后台运行容器</span><br><span class="line">nginx 要运行的镜像名称</span><br></pre></td></tr></table></figure><img src="/2022/07/15/springcloud-xue-xi-bi-ji/005.jpg" class=""></li><li>暂停容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause containerName</span><br></pre></td></tr></table></figure></li><li>容器取消暂停状态，恢复运行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause containerName</span><br></pre></td></tr></table></figure></li><li>停止容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop containerName</span><br></pre></td></tr></table></figure></li><li>容器取消停止，再次运行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start containerName</span><br></pre></td></tr></table></figure></li><li>删除容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm containerName</span><br></pre></td></tr></table></figure></li><li>进入容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mn bash</span><br><span class="line">ps:</span><br><span class="line">-it 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</span><br><span class="line">mn 进入的容器的名称</span><br><span class="line">bash 进入容器后执行的命令，bash是一个linux终端交互命令</span><br></pre></td></tr></table></figure></li><li>查看容器日志<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br><span class="line">ps:</span><br><span class="line">-f 持续查看日志</span><br></pre></td></tr></table></figure></li><li>查看容器状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">ps:</span><br><span class="line">-a 查看所有容器（包括已停止）</span><br></pre></td></tr></table></figure><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2></li></ol><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/006.jpg" class=""><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p><ol><li>创建数据卷<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure></li><li>查看所有数据卷<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure></li><li>查看数据卷详细信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure></li><li>删除数据卷<br>删除未使用的数据卷<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune </span><br></pre></td></tr></table></figure>删除指定数据卷<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm html</span><br></pre></td></tr></table></figure></li><li>挂载数据卷<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80 \</span><br><span class="line">  nginx \</span><br><span class="line">ps:</span><br><span class="line">-v html:/root/htm 把html数据卷挂载到容器内的/root/html这个目录中</span><br></pre></td></tr></table></figure></li><li>容器直接挂载主机目录<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v [宿主机目录]:[容器内目录] \</span><br><span class="line">  -p 8080:80 \</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure><img src="/2022/07/15/springcloud-xue-xi-bi-ji/007.jpg" class=""><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2></li></ol><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/008.jpg" class=""><p>Dockerfile文件告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/009.jpg" class=""><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>新建文件夹及准备好相关文件。</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/010.jpg" class=""><p>Dockerfile内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">  FROM ubuntu:16.04</span><br><span class="line">  # 配置环境变量，JDK的安装目录</span><br><span class="line">  ENV JAVA_DIR=/usr/local</span><br><span class="line">  </span><br><span class="line">  # 拷贝jdk和java项目的包</span><br><span class="line">  COPY ./jdk8.tar.gz $JAVA_DIR/</span><br><span class="line">  COPY ./docker-demo.jar /tmp/app.jar</span><br><span class="line">  </span><br><span class="line">  # 安装JDK</span><br><span class="line">  RUN cd $JAVA_DIR \</span><br><span class="line">   &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="line">   &amp;&amp; mv ./jdk1.8.0_144 ./java8</span><br><span class="line">  </span><br><span class="line">  # 配置环境变量</span><br><span class="line">  ENV JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line">  ENV PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">  </span><br><span class="line">  # 暴露端口</span><br><span class="line">  EXPOSE 8090</span><br><span class="line">  # 入口，java项目的启动命令</span><br><span class="line">  ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure><h3 id="基于镜像构建镜像"><a href="#基于镜像构建镜像" class="headerlink" title="基于镜像构建镜像"></a>基于镜像构建镜像</h3><p>由于Docker的分层结构，因此我们可以在别人镜像的基础上制作自己的镜像。<br>基于java:8-alpine镜像，将一个Java项目构建为镜像。</p><ul><li>新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</li><li>拷贝课前资料提供的docker-demo.jar到这个目录中</li><li>编写Dockerfile文件：<ul><li>基于java:8-alpine作为基础镜像</li><li>将app.jar拷贝到镜像中</li><li>暴露端口</li><li>编写入口ENTRYPOINT<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8-alpine</span><br><span class="line">COPY ./app.jar /tmp/app.jar</span><br><span class="line">EXPOSE 8090</span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！<h3 id="DockerCompose下载安装"><a href="#DockerCompose下载安装" class="headerlink" title="DockerCompose下载安装"></a>DockerCompose下载安装</h3>详细见官网<a class="link"   href="https://docs.docker.com/compose/" >https://docs.docker.com/compose/<i class="fas fa-external-link-alt"></i></a><h3 id="部署集群案例"><a href="#部署集群案例" class="headerlink" title="部署集群案例"></a>部署集群案例</h3>eg：将之前学习的cloud-demo微服务集群利用DockerCompose部署</li></ul></li><li>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</li><li>修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</li><li>使用maven打包工具，将项目中的每个微服务都打包为app.jar</li><li>将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</li><li>将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署<h4 id="1-compose文件"><a href="#1-compose文件" class="headerlink" title="1. compose文件"></a>1. compose文件</h4>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：<img src="/2022/07/15/springcloud-xue-xi-bi-ji/011.jpg" class=""><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MODE:</span> <span class="string">standalone</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.25</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span></span><br><span class="line">  <span class="attr">userservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./user-service</span></span><br><span class="line">  <span class="attr">orderservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./order-service</span></span><br><span class="line">  <span class="attr">gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./gateway</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10010:10010&quot;</span></span><br></pre></td></tr></table></figure>共有5个service服务：</li><li><code>nacos</code>：作为注册中心和配置中心<ul><li><code>image: nacos/nacos-server</code>： 基于nacos/nacos-server镜像构建</li><li><code>environment</code>：环境变量<ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><code>mysql</code>：数据库<ul><li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li><li><code>environment</code>：环境变量<ul><li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li></ul></li><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的<br>mysql目录中可已经准备好了cloud_order、cloud_user表。<br>查看微服务目录，可以看到都包含Dockerfile文件：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure><h4 id="2-修改微服务配置"><a href="#2-修改微服务配置" class="headerlink" title="2. 修改微服务配置"></a>2. 修改微服务配置</h4>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">nacos:8848</span> <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure><h4 id="3-打包"><a href="#3-打包" class="headerlink" title="3. 打包"></a>3. 打包</h4>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 服务打包的最终名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2022/07/15/springcloud-xue-xi-bi-ji/012.jpg" class=""><h4 id="4-拷贝jar包到部署目录"><a href="#4-拷贝jar包到部署目录" class="headerlink" title="4. 拷贝jar包到部署目录"></a>4. 拷贝jar包到部署目录</h4>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，不要搞错。<br>eg：order-service<img src="/2022/07/15/springcloud-xue-xi-bi-ji/013.jpg" class=""><h4 id="5-部署"><a href="#5-部署" class="headerlink" title="5. 部署"></a>5. 部署</h4>最后将文件整个cloud-demo文件夹上传到虚拟机中，由DockerCompose部署。可上传到任意目录。<br>部署：进入cloud-demo目录，然后运行下面的命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="Docker镜像仓库"><a href="#Docker镜像仓库" class="headerlink" title="Docker镜像仓库"></a>Docker镜像仓库</h2><h3 id="简化版镜像仓库"><a href="#简化版镜像仓库" class="headerlink" title="简化版镜像仓库"></a>简化版镜像仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。访问<a class="link"   href="http://yourip:5000/v2/_catalog" >http://YourIp:5000/v2/_catalog<i class="fas fa-external-link-alt"></i></a> 可以查看当前私有镜像服务中包含的镜像。</li></ul><h3 id="图形界面镜像仓库"><a href="#图形界面镜像仓库" class="headerlink" title="图形界面镜像仓库"></a>图形界面镜像仓库</h3><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.0&#x27;</span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    volumes:</span><br><span class="line">      - ./registry-data:/var/lib/registry</span><br><span class="line">  ui:</span><br><span class="line">    image: joxit/docker-registry-ui:static</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      - REGISTRY_TITLE=传智教育私有仓库</span><br><span class="line">      - REGISTRY_URL=http://registry:5000</span><br><span class="line">    depends_on:</span><br><span class="line">      - registry</span><br></pre></td></tr></table></figure><h3 id="配置Docker信任地址"><a href="#配置Docker信任地址" class="headerlink" title="配置Docker信任地址"></a>配置Docker信任地址</h3><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 打开要修改的文件</span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"># 添加内容：</span><br><span class="line">&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]</span><br><span class="line"># 重加载</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"># 重启docker</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>详情请参考官方网站<a class="link"   href="https://www.rabbitmq.com/" >https://www.rabbitmq.com/<i class="fas fa-external-link-alt"></i></a></p><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><p>方式一：镜像安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>方式二：本地文件<br>下载文件后上传到虚拟机，使用以下命令加载镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mq.tar</span><br></pre></td></tr></table></figure><h3 id="运行MQ容器"><a href="#运行MQ容器" class="headerlink" title="运行MQ容器"></a>运行MQ容器</h3><p>安装成功后，可使用以下命令来运行容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq1 \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3-management</span><br></pre></td></tr></table></figure><h3 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h3><p>在RabbitMQ的官方文档中，讲述了两种集群的配置方式：</p><ol><li>普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。</li><li>镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。<br>详细信息请参考参考官方网站<a class="link"   href="https://www.rabbitmq.com/" >https://www.rabbitmq.com/<i class="fas fa-external-link-alt"></i></a><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2>RabbitMQ角色：</li></ol><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离<br>RabbitMQ基本模型：<img src="/2022/07/15/springcloud-xue-xi-bi-ji/014.jpg" class=""><h2 id="消息队列基本使用"><a href="#消息队列基本使用" class="headerlink" title="消息队列基本使用"></a>消息队列基本使用</h2><h3 id="消息发送publisher"><a href="#消息发送publisher" class="headerlink" title="消息发送publisher"></a>消息发送publisher</h3></li></ul><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>利用channel向队列发送消息<br>eg：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublisherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息接收consumer"><a href="#消息接收consumer" class="headerlink" title="消息接收consumer"></a>消息接收consumer</h3></li><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>定义consumer的消费行为handleDelivery()</li><li>利用channel将消费者与队列绑定<br>eg：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                String message = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h2>SpringAMQP是基于RabbitMQ封装的模板，利用SpringBoot对其实现了自动装配。<br>SpringAMQP提供了三个功能：</li></ol><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息 <h3 id="基本使用流程"><a href="#基本使用流程" class="headerlink" title="基本使用流程"></a>基本使用流程</h3></li></ul><ol><li>在父工程中引入spring-amqp的依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>消息发送<br>配置MQ信息<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>使用RestTemplate实现消息发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAmqpTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用RabbitTemplate消息接收<br>配置MQ：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>消息接收：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRabbitListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h3>也被称为（Task queues），<strong>让多个消费者绑定到一个消息队列，共同消费队列中的消息</strong>，能够大大提高消息处理的速度。<h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多消费者接收消息"><a href="#多消费者接收消息" class="headerlink" title="多消费者接收消息"></a>多消费者接收消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多个消费者间消息分配策略"><a href="#多个消费者间消息分配策略" class="headerlink" title="多个消费者间消息分配策略"></a>多个消费者间消息分配策略</h4>多个消费者之间的分配的消息默认是平均分配，与消费者处理消息的能力无关。eg：上文中的两个消费者，消费者1每20ms处理一个消息，而消费者2则每200ms处理一个消息，但是消息队列中的消息会平均分配给两个消费者，原因是RabbieMQ会预先将消息队列中的消息分配给每一个消费者，可以通过设置prefetch来控制消费者预取的消息数量。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3>发布订阅模型：<img src="/2022/07/15/springcloud-xue-xi-bi-ji/015.jpg" class=""></li></ol><ul><li>Publisher：生产者发送的消息不再发送到队列中，而是发给交换机</li><li>Exchange：交换机。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息</li></ul><p>ps：<br><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h4 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h4><p>生产者将消息发送给交换机，交换机会将消息发送给与之绑定的所有队列，最后订阅队列的消费者拿到消息。要点如下：</p><ol><li>队列绑定交换机</li><li>消费者订阅队列<br>ps：该模式下，生产者的消息只能发送给交换机。<h5 id="声明队列和交换机"><a href="#声明队列和交换机" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;itcast.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h4>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br>每个队列会绑定不同的关键词——bingkey，交换机发送消息时，会根据消息的key将消息发送到绑定该key的队列。<img src="/2022/07/15/springcloud-xue-xi-bi-ji/016.jpg" class=""><h5 id="声明队列和交换机（基于注解）"><a href="#声明队列和交换机（基于注解）" class="headerlink" title="声明队列和交换机（基于注解）"></a>声明队列和交换机（基于注解）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。但是<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！<br>RoutingKey通配符规则：多个词之间以<code>.</code>分割。</li></ol><ul><li><code>#</code>匹配一个或多个词</li><li><code>*</code>匹配一个词<img src="/2022/07/15/springcloud-xue-xi-bi-ji/017.jpg" class=""></li><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news<h5 id="消息发送-2"><a href="#消息发送-2" class="headerlink" title="消息发送"></a>消息发送</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * topicExchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息接收-1"><a href="#消息接收-1" class="headerlink" title="消息接收"></a>消息接收</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h2>Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<img src="/2022/07/15/springcloud-xue-xi-bi-ji/018.jpg" class="">默认情况下Spring采用的序列化方式是JDK序列化，但是JDK序列化存在下列问题：</li><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><h3 id="配置Json转换器"><a href="#配置Json转换器" class="headerlink" title="配置Json转换器"></a>配置Json转换器</h3><ol><li>微服务引入依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>添加组件Bean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会替换Spring默认的转换器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><p>消息从发送，到消费者接收，会经理多个过程，其中的每一步都可能导致消息丢失，常见的丢失原因包括：</p><ul><li>发送时丢失：<ul><li>生产者发送的消息未送达exchange</li><li>消息到达exchange后未到达queue</li></ul></li><li>MQ宕机，queue将消息丢失</li><li>consumer接收到消息后未消费就宕机</li></ul><p>针对这些问题，RabbitMQ分别给出了解决方案：</p><ul><li>生产者确认机制</li><li>mq持久化</li><li>消费者确认机制</li><li>失败重试机制</li></ul><h3 id="生产者消息确认"><a href="#生产者消息确认" class="headerlink" title="生产者消息确认"></a>生产者消息确认</h3><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。返回结果有两种方式：</p><ul><li>publisher-confirm，发送者确认<ul><li>消息成功投递到交换机，返回ack</li><li>消息未投递到交换机，返回nack</li></ul></li><li>publisher-return，发送者回执<ul><li>消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。</li></ul></li></ul><p>PS：确认机制发送消息时，需要给每个消息设置一个全局唯一id，以区分不同消息，避免ack冲突</p><ol><li>修改配置</li></ol><p>修改publisher服务中的application.yml文件，添加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><code>publish-confirm-type</code>：开启publisher-confirm，这里支持两种类型：<ul><li><code>simple</code>：同步等待confirm结果，直到超时</li><li><code>correlated</code>：异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback</li></ul></li><li><code>publish-returns</code>：开启publish-return功能，同样是基于callback机制，不过是定义ReturnCallback</li><li><code>template.mandatory</code>：定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息</li></ul><ol start="2"><li>定义Return回调</li></ol><p>每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目加载时配置。修改publisher服务，添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonConfig</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取RabbitTemplate</span></span><br><span class="line">        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        <span class="comment">// 设置ReturnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 投递失败，记录日志</span></span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由键&#123;&#125;,消息&#123;&#125;&quot;</span>,</span><br><span class="line">                     replyCode, replyText, exchange, routingKey, message.toString());</span><br><span class="line">            <span class="comment">// 如果有业务需要，可以重发消息</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：Spring容器加载成功之后会通知实现<code>ApplicationContextAware</code>接口的类，接着调用 <code>setApplicationContext</code>方法。</p><h3 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h3><p>ConfirmCallback可以在发送消息时指定，因为每个业务处理confirm成功或失败的逻辑不一定相同。在publisher服务的cn.itcast.mq.spring.SpringAmqpTest类中，定义一个单元测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMessage2SimpleQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.消息体</span></span><br><span class="line">    String message = <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.全局唯一的消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 3.添加callback</span></span><br><span class="line">    correlationData.getFuture().addCallback(</span><br><span class="line">        result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123;</span><br><span class="line">                <span class="comment">// 3.1.ack，消息成功</span></span><br><span class="line">                log.debug(<span class="string">&quot;消息发送成功, ID:&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 3.2.nack，消息失败</span></span><br><span class="line">                log.error(<span class="string">&quot;消息发送失败, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>,correlationData.getId(), result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ex -&gt; log.error(<span class="string">&quot;消息发送异常, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>,correlationData.getId(),ex.getMessage())</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 4.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;task.direct&quot;</span>, <span class="string">&quot;task&quot;</span>, message, correlationData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 休眠一会儿，等待ack回执</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>生产者确认可以确保消息投递到RabbitMQ的队列中，但是消息发送到RabbitMQ以后，如果突然宕机，也可能导致消息丢失。要想确保消息在RabbitMQ中安全保存，必须开启消息持久化机制。</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><h4 id="交换价持久化"><a href="#交换价持久化" class="headerlink" title="交换价持久化"></a>交换价持久化</h4><p>RabbitMQ中交换机默认是非持久化的，mq重启后就丢失。SpringAMQP中可以通过代码指定交换机持久化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">simpleExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;simple.direct&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，默认情况下，由SpringAMQP声明的交换机都是持久化的。</p><p>PS：持久化的交换机在RabbitMQ控制台上会显示<code>D</code>标示</p><h4 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h4><p>RabbitMQ中队列默认是非持久化的，mq重启后就丢失。SpringAMQP中可以通过代码指定交换机持久化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">simpleQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用QueueBuilder构建队列，durable就是持久化的</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，由SpringAMQP声明的队列都是持久化的。</p><p>PS：持久化的队列在RabbitMQ控制台会显示<code>D</code>标示</p><h4 id="消息持久化-1"><a href="#消息持久化-1" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>利用SpringAMQP发送消息时，可以设置消息的属性（MessageProperties），指定delivery-mode：</p><ul><li>非持久化</li><li>持久化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Message message = MessageBuilder.withBody(<span class="string">&quot;hello,ttl queue&quot;</span></span><br><span class="line">.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">.setDeliveryMode (MessageDeliveryMode.PERSISTENT)</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><p>默认情况下，SpringAMQP发出的任何消息都是持久化的，不用特意指定。</p><h3 id="消费者消息确认"><a href="#消费者消息确认" class="headerlink" title="消费者消息确认"></a>消费者消息确认</h3><p>RabbitMQ是<strong>阅后即焚</strong>机制，RabbitMQ确认消息被消费者消费后会立刻删除。</p><p>abbitMQ是通过消费者回执来确认消费者是否成功处理消息的：消费者获取消息后，应该向RabbitMQ发送ACK回执，表明自己已经处理消息。</p><p>eg：设想这样的场景：</p><ul><li>1）RabbitMQ投递消息给消费者</li><li>2）消费者获取消息后，返回ACK给RabbitMQ</li><li>3）RabbitMQ删除消息</li><li>4）消费者宕机，消息尚未处理</li></ul><p>这样，消息就丢失了。因此消费者返回ACK的时机非常重要。</p><p>SpringAMQP则允许配置三种确认模式：</p><ul><li>manual：手动ack，需要在业务代码结束后，调用api发送ack。</li><li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</li><li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li></ul><h4 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 关闭ack</span></span><br></pre></td></tr></table></figure><p>PS：即使消息处理中出现异常，消息任然会被删除</p><h4 id="auto模式"><a href="#auto模式" class="headerlink" title="auto模式"></a>auto模式</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 关闭ack</span></span><br></pre></td></tr></table></figure><p>PS：消息处理中出现异常后，消息会被恢复为Ready状态，不会删除</p><h3 id="消息失败重试"><a href="#消息失败重试" class="headerlink" title="消息失败重试"></a>消息失败重试</h3><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力。<br>解决方案：</p><ol><li>本地重试</li></ol><p>利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。修改consumer服务的application.yml文件，添加内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><p>重启consumer服务，进行测试：</p><ul><li>在重试3次后，SpringAMQP会抛出异常AmqpRejectAndDontRequeueException，说明本地重试触发了</li><li>查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是ack，mq删除消息了</li></ul><p>说明：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回ack，消息会被丢弃</li></ul><ol start="2"><li>失败策略</li></ol><p>在本地重试中，达到最大重试次数后，消息会被丢弃，这是由Spring内部机制决定的。在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecovery接口来处理，它包含三种不同的实现：</p><ul><li>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</li><li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队</li><li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p><strong>RepublishMessageRecoverer</strong>：失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理</p><ol><li>在consumer服务中定义处理失败消息的交换机和队列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">errorMessageExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">errorQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;error.queue&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义一个RepublishMessageRecoverer，关联队列和交换机</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageRecoverer <span class="title">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RepublishMessageRecoverer(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h2><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果这个包含死信的队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>（Dead Letter Exchange，检查DLX）。如果死信交换机也绑定了队列，则消息最终会进入这个存放死信的队列。</p><p>队列将死信投递给死信交换机时，必须知道两个信息：</p><ul><li>死信交换机名称</li><li>死信交换机与死信队列绑定的RoutingKey</li></ul><p>在失败重试策略中，默认的RejectAndDontRequeueRecoverer会在本地重试次数耗尽后，发送reject给RabbitMQ，消息变成死信，被丢弃。<br>我们可以给simple.queue添加一个死信交换机，给死信交换机绑定一个队列。这样消息变成死信后也不会丢弃，而是最终投递到死信交换机，路由到与死信交换机绑定的队列。</p><p>consumer服务中，定义一组死信交换机、死信队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明普通的 simple.queue队列，并且为其指定死信交换机：dl.direct</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">simpleQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>) <span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">        .deadLetterExchange(<span class="string">&quot;dl.direct&quot;</span>) <span class="comment">// 指定死信交换机</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明死信交换机 dl.direct</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">dlExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;dl.direct&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明存储死信的队列 dl.queue</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">dlQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;dl.queue&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将死信队列 与 死信交换机绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">dlBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(dlQueue()).to(dlExchange()).with(<span class="string">&quot;simple&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>一个队列中的消息如果超时未消费，则会变为死信，超时分为两种情况：</p><ul><li>消息所在的队列设置了超时时间</li><li>消息本身设置了超时时间</li></ul><ol><li>接收超时死信的死信交换机</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;dl.ttl.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;dl.ttl.direct&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;ttl&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDlQueue</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 dl.ttl.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明一个队列，并且指定TTL </li></ol><p>队列设置超时时间，需要在声明队列时配置x-message-ttl属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">ttlQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;ttl.queue&quot;</span>) <span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">        .ttl(<span class="number">10000</span>) <span class="comment">// 设置队列的超时时间，10秒</span></span><br><span class="line">        .deadLetterExchange(<span class="string">&quot;dl.ttl.direct&quot;</span>) <span class="comment">// 指定死信交换机</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列设定了死信交换机为<code>dl.ttl.direct</code></p><p>声明交换机，将ttl与交换机绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DirectExchange ttlExchange()&#123;</span><br><span class="line">    return new DirectExchange(&quot;ttl.direct&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public Binding ttlBinding()&#123;</span><br><span class="line">    return BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with(&quot;ttl&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>发送消息时，设定TTL：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTTLMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建消息</span></span><br><span class="line">    Message message = MessageBuilder</span><br><span class="line">        .withBody(<span class="string">&quot;hello, ttl message&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        .setExpiration(<span class="string">&quot;5000&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>, <span class="string">&quot;ttl&quot;</span>, message, correlationData);</span><br><span class="line">    log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>PS：当队列、消息都设置了TTL时，任意一个到期就会成为死信</li></ol><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>利用TTL结合死信交换机，我们实现了消息发出后，消费者延迟收到消息的效果。这种消息模式就称为延迟队列（Delay Queue）模式。</p><p>RabbitMQ官方推出了<code>DelayExchange</code>插件，原生支持延迟队列效果，参考RabbitMQ的插件列表页面：<a class="link"   href="https://www.rabbitmq.com/community-plugins.html" >https://www.rabbitmq.com/community-plugins.html<i class="fas fa-external-link-alt"></i></a></p><h3 id="安装DelayExchange"><a href="#安装DelayExchange" class="headerlink" title="安装DelayExchange"></a>安装DelayExchange</h3><p>略</p><h3 id="DelayExchange原理"><a href="#DelayExchange原理" class="headerlink" title="DelayExchange原理"></a>DelayExchange原理</h3><p>DelayExchange需要将一个交换机声明为delayed类型。当我们发送消息到delayExchange时，流程如下：</p><ul><li>接收消息</li><li>判断消息是否具备x-delay属性</li><li>如果有x-delay属性，说明是延迟消息，持久化到硬盘，读取x-delay值，作为延迟时间</li><li>返回routing not found结果给消息发送者</li><li>x-delay时间到期后，重新投递消息到指定队列</li></ul><h3 id="DelayExchange使用"><a href="#DelayExchange使用" class="headerlink" title="DelayExchange使用"></a>DelayExchange使用</h3><ol><li>声明DelayExchange交换机</li></ol><ul><li><p>注解方式</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/076.png" class=""></li><li><p>代码注册@Bean</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/077.png" class=""></li></ul><ol start="2"><li>发送消息，设置x-delay</li></ol><p>发送消息时，一定要携带x-delay属性，指定延迟的时间：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/078.png" class=""><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><p>Lazy Queues（惰性队列）：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存</li><li>支持数百万条的消息存储</li></ul><ol><li>基于命令行设置lazy-queue</li></ol><p>置一个队列为惰性队列，只需要在声明队列时，指定x-queue-mode属性为lazy即可。可以通过命令行将一个运行中的队列修改为惰性队列：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy <span class="string">&quot;^lazy-queue$&quot;</span> <span class="string">&#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27;</span> --apply-to queues  </span><br></pre></td></tr></table></figure><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues  </code>：策略的作用对象，是所有的队列</li></ul><ol start="2"><li>基于@Bean声明lazy-queue</li></ol><img src="/2022/07/15/springcloud-xue-xi-bi-ji/079.png" class=""><ol start="3"><li>基于@RabbitListener声明LazyQueue</li></ol><img src="/2022/07/15/springcloud-xue-xi-bi-ji/080.png" class=""><p><strong>小结</strong>：<br>消息堆积问题的解决方案？</p><ul><li>队列上绑定多个消费者，提高消费速度</li><li>使用惰性队列，可以再mq中保存更多消息</li></ul><p>惰性队列的优点有哪些？</p><ul><li>基于磁盘存储，消息上限高</li><li>没有间歇性的page-out，性能比较稳定</li></ul><p>惰性队列的缺点有哪些？</p><ul><li>基于磁盘存储，消息时效性会降低</li><li>性能受限于磁盘的IO</li></ul><h2 id="MQ集群"><a href="#MQ集群" class="headerlink" title="MQ集群"></a>MQ集群</h2><p>在RabbitMQ的官方文档中，讲述了两种集群的配置方式：</p><ul><li>普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。</li><li>镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。</li><li>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：、<ul><li>与镜像队列一样，都是主从模式，支持主从数据同步</li><li>使用非常简单，没有复杂的配置</li><li>主从同步基于Raft协议，强一致</li></ul></li></ul><h3 id="普通模式部署"><a href="#普通模式部署" class="headerlink" title="普通模式部署"></a>普通模式部署</h3><p>三节点MQ集群<br>| 主机名 | 控制台端口      | amqp通信端口    |<br>| —— | ————— | ————— |<br>| mq1    | 8081 —&gt; 15672 | 8071 —&gt; 5672  |<br>| mq2    | 8082 —&gt; 15672 | 8072 —&gt; 5672  |<br>| mq3    | 8083 —&gt; 15672 | 8073  —&gt; 5672 |</p><p>集群中的节点标示默认都是：<code>rabbit@[hostname]</code>，因此以上三个节点的名称分别为：</p><ul><li>rabbit@mq1</li><li>rabbit@mq2</li><li>rabbit@mq3</li></ul><ol><li>获取cookie</li></ol><p>集群模式中的每个RabbitMQ 节点使用 cookie 来确定它们是否被允许相互通信。要使两个节点能够通信，它们必须具有相同的共享秘密，称为<strong>Erlang cookie</strong>。cookie 只是一串最多 255 个字符的字母数字字符。</p><p>每个集群节点必须具有<strong>相同的 cookie</strong>。实例之间也需要它来相互通信。从mq容器中获取一个cookie值，作为集群的cookie。执行下面的命令便可以获取到Cookie：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mq cat /var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件</li></ol><p>新建rabbitmq.conf，内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loopback_users.<span class="attribute">guest</span> = <span class="literal">false</span></span><br><span class="line">listeners.tcp.default = <span class="number">5672</span></span><br><span class="line">cluster_formation.peer_discovery_backend = rabbit_peer_discovery_classic_config</span><br><span class="line">cluster_formation.classic_config.nodes.<span class="number">1</span> = rabbit@mq1</span><br><span class="line">cluster_formation.classic_config.nodes.<span class="number">2</span> = rabbit@mq2</span><br><span class="line">cluster_formation.classic_config.nodes.<span class="number">3</span> = rabbit@mq3</span><br></pre></td></tr></table></figure><p>另新建文件，记录cookie</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 创建cookie文件</span></span><br><span class="line">touch .erlang.cookie</span><br><span class="line"><span class="comment"># 写入cookie</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;FXZMCVGLBIXZCDEMMVZQ&quot;</span> &gt; .erlang.cookie</span><br><span class="line"><span class="comment"># 修改cookie文件的权限</span></span><br><span class="line">chmod 600 .erlang.cookie</span><br></pre></td></tr></table></figure><ol start="3"><li>准备MQ节点目录</li></ol><p>准备三个目录，mq1、mq2、mq3</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir mq1 mq2 mq3</span><br></pre></td></tr></table></figure><p>拷贝rabbitmq.conf、cookie文件到mq1、mq2、mq3：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 拷贝</span></span><br><span class="line">cp rabbitmq.conf mq1</span><br><span class="line">cp rabbitmq.conf mq2</span><br><span class="line">cp rabbitmq.conf mq3</span><br><span class="line">cp .erlang.cookie mq1</span><br><span class="line">cp .erlang.cookie mq2</span><br><span class="line">cp .erlang.cookie mq3</span><br></pre></td></tr></table></figure><ol start="4"><li>启动集群</li></ol><p><strong>创建网络</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create mq-net</span><br></pre></td></tr></table></figure><p>运行三个节点MQ容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net mq-net \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/mq1/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line">--name mq1 \</span><br><span class="line">--hostname mq1 \</span><br><span class="line">-p 8071:5672 \</span><br><span class="line">-p 8081:15672 \</span><br><span class="line">rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net mq-net \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/mq2/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line">--name mq2 \</span><br><span class="line">--hostname mq2 \</span><br><span class="line">-p 8072:5672 \</span><br><span class="line">-p 8082:15672 \</span><br><span class="line">rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net mq-net \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/mq3/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class="line">-v <span class="variable">$&#123;PWD&#125;</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line">--name mq3 \</span><br><span class="line">--hostname mq3 \</span><br><span class="line">-p 8073:5672 \</span><br><span class="line">-p 8083:15672 \</span><br><span class="line">rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><h3 id="镜像模式部署"><a href="#镜像模式部署" class="headerlink" title="镜像模式部署"></a>镜像模式部署</h3><p>镜像模式下，创建队列的节点被称为该队列的<strong>主节点</strong>，队列还会拷贝到集群中的其它节点，为该队列的<strong>镜像</strong>节点。</p><p>不同队列可以在集群中的任意节点上创建，因此不同队列的主节点可以不同。甚至，<strong>一个队列的主节点可能是另一个队列的镜像节点</strong>。</p><p>用户发送给队列的一切请求，例如发送消息、消息回执默认都会在主节点完成，如果是从节点接收到请求，也会路由到主节点去完成。<strong>镜像节点仅仅起到备份数据作用</strong>。</p><p>当主节点接收到消费者的ACK时，所有镜像都会删除节点中的数据。</p><p>小结：</p><ul><li>镜像队列结构是一主多从（从就是镜像）</li><li>所有操作都是主节点完成，然后同步给镜像节点</li><li>主宕机后，镜像节点会替代成新的主（如果在主从同步完成前，主就已经宕机，可能出现数据丢失）</li><li>不具备负载均衡功能，因为所有操作都会有主节点完成（但是不同队列，其主节点可以不同，可以利用这个提高吞吐量）</li></ul><p>镜像模式的配置有3种模式：<br>| ha-mode         | ha-params         | 效果                                                         |<br>| :————– | :—————- | :———————————————————– |<br>| 准确模式exactly | 队列的副本量count | 集群中队列副本（主服务器和镜像服务器之和）的数量。count如果为1意味着单个副本：即队列主节点。count值为2表示2个副本：1个队列主和1个队列镜像。换句话说：count = 镜像数量 + 1。如果群集中的节点数少于count，则该队列将镜像到所有节点。如果有集群总数大于count+1，并且包含镜像的节点出现故障，则将在另一个节点上创建一个新的镜像。 |<br>| all             | (none)            | 队列在群集中的所有节点之间进行镜像。队列将镜像到任何新加入的节点。镜像到所有节点将对所有群集节点施加额外的压力，包括网络I / O，磁盘I / O和磁盘空间使用情况。推荐使用exactly，设置副本数为（N / 2 +1）。 |<br>| nodes           | <em>node names</em>      | 指定队列创建到哪些节点，如果指定的节点全部不存在，则会出现异常。如果指定的节点在集群中存在，但是暂时不可用，会创建节点到当前客户端连接到的节点。 |</p><p>以rabbitmqctl命令作为案例来讲解配置语法：</p><ol><li>exactly模式</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-two <span class="string">&quot;^two\.&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>rabbitmqctl set_policy</code>：固定写法</li><li><code>ha-two</code>：策略名称，自定义</li><li><code>&quot;^two\.&quot;</code>：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>two.</code>开头的队列名称</li><li><code>&#39;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#39;</code>: 策略内容<ul><li><code>&quot;ha-mode&quot;:&quot;exactly&quot;</code>：策略模式，此处是exactly模式，指定副本数量</li><li><code>&quot;ha-params&quot;:2</code>：策略参数，这里是2，就是副本数量为2，1主1镜像</li><li><code>&quot;ha-sync-mode&quot;:&quot;automatic&quot;</code>：同步策略，默认是manual，即新加入的镜像节点不会同步旧的消息。如果设置为automatic，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销</li></ul></li></ul><ol start="2"><li>all模式</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all <span class="string">&quot;^all\.&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>ha-all</code>：策略名称，自定义</li><li><code>&quot;^all\.&quot;</code>：匹配所有以<code>all.</code>开头的队列名</li><li><code>&#39;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#39;</code>：策略内容<ul><li><code>&quot;ha-mode&quot;:&quot;all&quot;</code>：策略模式，此处是all模式，即所有节点都会称为镜像节点</li></ul></li></ul><ol start="3"><li>nodes模式</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-nodes <span class="string">&quot;^nodes\.&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]&#125;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>rabbitmqctl set_policy</code>：固定写法</li><li><code>ha-nodes</code>：策略名称，自定义</li><li><code>&quot;^nodes\.&quot;</code>：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>nodes.</code>开头的队列名称</li><li><code>&#39;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]&#125;&#39;</code>: 策略内容<ul><li><code>&quot;ha-mode&quot;:&quot;nodes&quot;</code>：策略模式，此处是nodes模式</li><li><code>&quot;ha-params&quot;:[&quot;rabbit@mq1&quot;, &quot;rabbit@mq2&quot;]</code>：策略参数，这里指定副本所在节点名称</li></ul></li></ul><h3 id="仲裁队列部署"><a href="#仲裁队列部署" class="headerlink" title="仲裁队列部署"></a>仲裁队列部署</h3><p>在任意RabbitMQ控制台添加一个队列，选择队列类型为Quorum类型。仲裁队列默认的镜像数为5。如果你的集群有7个节点，那么镜像数肯定是5；而我们集群只有3个节点，因此镜像数量就是3。</p><p>Java中创建仲裁队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">quorumQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .durable(<span class="string">&quot;quorum.queue&quot;</span>) <span class="comment">// 持久化</span></span><br><span class="line">        .quorum() <span class="comment">// 仲裁队列</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringAMQP连接集群"><a href="#SpringAMQP连接集群" class="headerlink" title="SpringAMQP连接集群"></a>SpringAMQP连接集群</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8071,</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8072,</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span><span class="string">:8073</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><p>略。</p><h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><p>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能。</p><h2 id="安装部署-1"><a href="#安装部署-1" class="headerlink" title="安装部署"></a>安装部署</h2><p>因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create es-net</span><br></pre></td></tr></table></figure><h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><p>安装方式一：从DockerHub中pull到虚拟机<br>安装方式二：下载好文件上传到虚拟机，然后加载文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">docker load -i es.tar</span><br></pre></td></tr></table></figure><p>运行ES容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name es \</span><br><span class="line">    -e <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \</span><br><span class="line">    -e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">    -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">    -v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">    --privileged \</span><br><span class="line">    --network es-net \</span><br><span class="line">    -p 9200:9200 \</span><br><span class="line">    -p 9300:9300 \</span><br><span class="line">elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><p>命令解释：</p><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><p>在浏览器中输入：<a class="link"   href="http://192.168.150.101:9200/" >http://192.168.150.101:9200<i class="fas fa-external-link-alt"></i></a> 即可看到elasticsearch的响应结果(192.168.150.101为虚拟机ip)：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/023.jpg" class=""><h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><p>kibana提供了一个elasticsearch的可视化界面，可以运行DSL语句，而且具有自动补全功能，方便学习ES。<br>kibana安装同ES。<br>运行kibana容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=es-net \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure><ul><li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul><p>查看kibana日志，出现以下结果则kibana运行成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f kibana</span><br></pre></td></tr></table></figure><img src="/2022/07/15/springcloud-xue-xi-bi-ji/024.jpg" class=""><h2 id="ES基础"><a href="#ES基础" class="headerlink" title="ES基础"></a>ES基础</h2><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>重要概念：</p><ul><li>文档（document）：用来搜索的数据，每一条数据就是一个文档。例如一个网页、一个商品信息</li><li>词条（term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p>倒排索引是相对正向索引而言的。传统的正向索引在面对模糊查询时，通常需要逐行扫描数据判断是否符合查询条件，效率不高。<br>创建倒排索引流程如下：</p><ul><li>将每一个文档的数据利用算法分词，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引<img src="/2022/07/15/springcloud-xue-xi-bi-ji/019.jpg" class=""></li></ul><p>搜索流程如下：</p><ul><li>用户输入条件<code>&quot;华为手机&quot;</code>进行搜索</li><li>对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</li><li>拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</li><li>拿着文档id到正向索引中查找具体文档。<img src="/2022/07/15/springcloud-xue-xi-bi-ji/020.jpg" class=""></li></ul><h3 id="文档和字段"><a href="#文档和字段" class="headerlink" title="文档和字段"></a>文档和字段</h3><p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中。Json文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/021.jpg" class=""><h3 id="索引和映射"><a href="#索引和映射" class="headerlink" title="索引和映射"></a>索引和映射</h3><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/022.jpg" class=""><p>索引库中有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。<br>常见mapping属性：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li><li>地址（地理坐标，包含经纬度）：geo_point</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><p>eg:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">&quot;weight&quot;</span>: <span class="number">52.1</span>,</span><br><span class="line">    <span class="attr">&quot;isMarried&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;黑马程序员Java讲师&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;zy@itcast.cn&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;score&quot;</span>: [<span class="number">99.1</span>, <span class="number">99.5</span>, <span class="number">98.9</span>],</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span>: <span class="string">&quot;云&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span>: <span class="string">&quot;赵&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的每个字段映射（mapping）：</p><ul><li>age：类型为 integer；参与搜索，因此需要index为true；无需分词器</li><li>weight：类型为float；参与搜索，因此需要index为true；无需分词器</li><li>isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器</li><li>info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart</li><li>email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器</li><li>score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器</li><li>name：类型为object，需要定义多个子属性<ul><li>name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li><li>name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li></ul></li></ul><h3 id="ES与Mysql概念对比"><a href="#ES与Mysql概念对比" class="headerlink" title="ES与Mysql概念对比"></a>ES与Mysql概念对比</h3><table><thead><tr><th align="left">ES</th><th align="left">Mysql</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Table</td><td align="left">Index</td><td align="left">索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td align="left">Row</td><td align="left">Document</td><td align="left">文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td align="left">Column</td><td align="left">Field</td><td align="left">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td align="left">Schema</td><td align="left">Mapping</td><td align="left">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td align="left">SQL</td><td align="left">DSL</td><td align="left">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><h3 id="ik分词器"><a href="#ik分词器" class="headerlink" title="ik分词器"></a>ik分词器</h3><h4 id="安装配置ik分词器"><a href="#安装配置ik分词器" class="headerlink" title="安装配置ik分词器"></a>安装配置ik分词器</h4><p>方式一：在线安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it elasticsearch /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在线下载并安装</span></span><br><span class="line">./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><p>方式二：离线安装ik插件</p><ol><li>查看ES数据卷目录<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect es-plugins</span><br></pre></td></tr></table></figure>结果如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2022-05-06T10:06:34+08:00&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/es-plugins/_data&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;es-plugins&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Options&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code>目录</li><li>将ik分词器文件上传到<code>/var/lib/docker/volumes/es-plugins/_data </code></li><li>重启ES<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><h4 id="分词模式"><a href="#分词模式" class="headerlink" title="分词模式"></a>分词模式</h4></li></ol><ul><li>ik_smart：最少切分</li><li>ik_max_word：最细切分</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;黑马程序员学习java太棒了&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;黑马&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;程序员&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;程序&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;员&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;学习&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;java&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">11</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;ENGLISH&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;太棒了&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">11</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">14</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">6</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;太棒&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">11</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">13</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">7</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;了&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">13</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">14</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展词词典"><a href="#拓展词词典" class="headerlink" title="拓展词词典"></a>拓展词词典</h4><ol><li>进入ikbana的config目录，修改IKAnalyzer.cfg.xml文件，添加<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">properties</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>在config目录下新建 ext.dic文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">拿来吧你</span><br><span class="line">永远的神</span><br></pre></td></tr></table></figure></li><li>重启ES<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure><h4 id="停用词词典"><a href="#停用词词典" class="headerlink" title="停用词词典"></a>停用词词典</h4></li><li>在IKAnalyzer.cfg.xml文件添加如下内容：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">properties</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>stopword.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>在stopword.dic文件中添加停用词<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">黄赌毒</span><br></pre></td></tr></table></figure></li><li>重启ES<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">docker restart elasticsearch</span><br><span class="line">docker restart kibana</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><h3 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h3><h4 id="创建索引库和映射"><a href="#创建索引库和映射" class="headerlink" title="创建索引库和映射"></a>创建索引库和映射</h4></li></ol><ul><li>请求方式：PUT</li><li>请求路径：/索引库名，可以自定义</li><li>请求参数：mapping映射</li></ul><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名称</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;字段名&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;字段名2&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: &quot;false&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;字段名3&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">          &quot;子字段&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      // ...略</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT /heima</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;info&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;email&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;falsae&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;firstName&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ... 略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h4><ul><li>请求方式：GET</li><li>请求路径：/索引库名</li><li>请求参数：无</li></ul><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><h4 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h4><p>倒排索引一旦数据结构改变，需要重新创建倒排索引。因此ES索引库<strong>一旦创建，无法修改mapping</strong>。虽然无法修改，但是ES允许添加新的字段到mapping中，因为不会对倒排索引产生影响。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h4><ul><li>请求方式：DELETE</li><li>请求路径：/索引库名</li><li>请求参数：无</li></ul><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure><h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><h4 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h4><p>格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span>: <span class="string">&quot;值1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span>: <span class="string">&quot;值2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span>: <span class="string">&quot;值3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span>: <span class="string">&quot;值4&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /heima/_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;黑马程序员Java讲师&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;zy@itcast.cn&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span>: <span class="string">&quot;云&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span>: <span class="string">&quot;赵&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p>格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /&#123;索引库名称&#125;/_doc/&#123;id&#125;</span><br></pre></td></tr></table></figure><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><p>格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /&#123;索引库名&#125;/_doc/id值</span><br></pre></td></tr></table></figure><h4 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h4><p>全量修改：直接覆盖原有文档（如果文档不存在则会新建文档）<br>格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /&#123;索引库名&#125;/_doc/文档id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span>: <span class="string">&quot;值1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span>: <span class="string">&quot;值2&quot;</span>,</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增量修改：修改文档中的部分字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /&#123;索引库名&#125;/_update/文档id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span>: <span class="string">&quot;新的值&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h3><p><strong>ES copy_to</strong>参数：将多个字段合并为一个字段进行查询，可以避免由于多字段查询时的效率低问题。在创建映射时可以设置该属性，但是该字段仅在查询时起作用，并不会直接作为数据存在ES中。<br>PS：搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。</p><p>常见的查询类型包括：</p><ul><li><p>查询所有：查询出所有数据，一般测试用。例如：match_all</p></li><li><p>全文检索（full text）查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p><ul><li>match_query</li><li>multi_match_query</li></ul></li><li><p>精确查询：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：</p><ul><li>ids</li><li>range</li><li>term</li></ul></li><li><p>地理（geo）查询：根据经纬度查询。例如：</p><ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><p>复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p><ul><li>bool</li><li>function_score</li></ul></li></ul><p>基本语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;查询条件&quot;</span>: <span class="string">&quot;条件值&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg：查询所有</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询</h4><p>参与搜索的字段也必须是可分词的text类型的字段</p><ul><li>match查询：单字段查询</li><li>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</li></ul><p>match查询格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mulit_match查询格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;TEXT&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;</span>: [<span class="string">&quot;FIELD1&quot;</span>, <span class="string">&quot; FIELD12&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="精准查询"><a href="#精准查询" class="headerlink" title="精准查询"></a>精准查询</h4><p>一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。</p><ul><li>term：根据词条精确值查询</li><li>range：根据值的范围查询</li></ul><p>term查询：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// term查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;VALUE&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>range查询：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;gte&quot;</span>: <span class="number">10</span>, <span class="comment">// 这里的gte代表大于等于，gt则代表大于</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="number">20</span> <span class="comment">// lte代表小于等于，lt则代表小于</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="地理坐标查询"><a href="#地理坐标查询" class="headerlink" title="地理坐标查询"></a>地理坐标查询</h4><ol><li>矩形范围查询<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geo_bounding_box查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;geo_bounding_box&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;top_left&quot;</span>: &#123; <span class="comment">// 左上点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span>: <span class="number">31.1</span>,</span><br><span class="line">          <span class="attr">&quot;lon&quot;</span>: <span class="number">121.5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;bottom_right&quot;</span>: &#123; <span class="comment">// 右下点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span>: <span class="number">30.9</span>,</span><br><span class="line">          <span class="attr">&quot;lon&quot;</span>: <span class="number">121.7</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>距离查询<br>也称附近查询<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geo_distance 查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;geo_distance&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;distance&quot;</span>: <span class="string">&quot;15km&quot;</span>, <span class="comment">// 半径</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;31.21,121.5&quot;</span> <span class="comment">// 圆心</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h4><h5 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h5>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。ES会根据词条和文档的相关度做打分，算法由两种：</li></ol><ul><li>TF-IDF算法</li><li>BM25算法，elasticsearch5.1版本后采用的算法<img src="/2022/07/15/springcloud-xue-xi-bi-ji/027.jpg" class=""><img src="/2022/07/15/springcloud-xue-xi-bi-ji/028.jpg" class=""></li></ul><p>TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑。</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/029.jpg" class=""><h5 id="算分函数查询"><a href="#算分函数查询" class="headerlink" title="算分函数查询"></a>算分函数查询</h5><p>通过控制算分函数调整最终的查询相关性得分。<br><strong>function score</strong></p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/030.jpg" class=""><p>function score 查询中包含四部分内容：</p><ul><li>原始查询条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，原始算分（query score)</li><li>过滤条件：filter部分，符合该条件的文档才会重新算分</li><li>算分函数：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li>运算模式：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul><li>multiply：相乘</li><li>replace：用function score替换query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score的运行流程如下：</p><ul><li>根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score）</li><li>根据过滤条件，过滤文档</li><li>符合过滤条件的文档，基于算分函数运算，得到函数算分（function score）</li><li>将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。</li></ul><p>eg：使“如家”这个品牌的酒店排名靠前一些</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: &#123;  .... &#125;, <span class="comment">// 原始查询，可以是任意条件</span></span><br><span class="line">      <span class="attr">&quot;functions&quot;</span>: [ <span class="comment">// 算分函数</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: &#123; <span class="comment">// 满足的条件，品牌必须是如家</span></span><br><span class="line">            <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;如家&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;weight&quot;</span>: <span class="number">2</span> <span class="comment">// 算分权重为2</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;boost_mode&quot;</span>: <span class="string">&quot;sum&quot;</span> <span class="comment">// 加权模式，求和</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h4><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>PS：需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议：</p><ul><li>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</li><li>其它过滤条件，采用filter查询。不参与算分</li></ul><p>eg：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;<span class="attr">&quot;term&quot;</span>: &#123;<span class="attr">&quot;city&quot;</span>: <span class="string">&quot;上海&quot;</span> &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">        &#123;<span class="attr">&quot;term&quot;</span>: &#123;<span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;皇冠假日&quot;</span> &#125;&#125;,</span><br><span class="line">        &#123;<span class="attr">&quot;term&quot;</span>: &#123;<span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;华美达&quot;</span> &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;range&quot;</span>: &#123; <span class="attr">&quot;price&quot;</span>: &#123; <span class="attr">&quot;lte&quot;</span>: <span class="number">500</span> &#125; &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;range&quot;</span>: &#123;<span class="attr">&quot;score&quot;</span>: &#123; <span class="attr">&quot;gte&quot;</span>: <span class="number">45</span> &#125; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="搜索结果"><a href="#搜索结果" class="headerlink" title="搜索结果"></a>搜索结果</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>ES默认根据相关度算分（_score）排序，但是也支持自定义方式对搜索排序。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。</p><ol><li>普通字段排序</li></ol><p>keyword、数值、日期类型排序的语法基本一致。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;desc&quot;</span>  <span class="comment">// 排序字段、排序方式ASC、DESC</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推。<br>2. 地理坐标排序</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> : <span class="string">&quot;纬度，经度&quot;</span>, <span class="comment">// 文档中geo_point类型的字段名、目标坐标点</span></span><br><span class="line">          <span class="attr">&quot;order&quot;</span> : <span class="string">&quot;asc&quot;</span>, <span class="comment">// 排序方式</span></span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> : <span class="string">&quot;km&quot;</span> <span class="comment">// 排序的距离单位</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指定一个坐标，作为目标点</li><li>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</li><li>根据距离排序</li></ul><h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><p>ES默认情况下只返回top10的数据。查询更多数据可以通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><h6 id="基本分页"><a href="#基本分页" class="headerlink" title="基本分页"></a>基本分页</h6><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>, <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>, <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;<span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h6><ol><li>单点ES分页过程<br> 例如查询990<del>1000的数据，ES会将查询排序0</del>1000条数据，然后截取990~1000的10条数据。</li><li>集群模式分页<br> 集群模式下有N个ES节点，查询990<del>1000的数据，此时要对每个ES节点进行990</del>1000的数据查询过程，最后将所有节点的数据（注意是每个节点的0<del>1000数据，而不是每个节点的990</del>1000数据）进行汇总排序，最终得到正确的990~1000的数据。<br> 可见，集群模式下ES的数据查询的消耗是十分巨大的，会对内存和CPU造成巨大压力，因此ES禁止form+size超过10000的查询请求。<br> 针对深度分页问题，ES提供两种解决方案：<ul><li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li>原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li></ul></li></ol><h5 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h5><p>搜索结果中的高亮显示:</p><ul><li>给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li><li>页面给<code>&lt;em&gt;</code>标签编写CSS样式</li></ul><p>高亮语法:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;TEXT&quot;</span> <span class="comment">// 查询条件，高亮一定要使用全文检索查询</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123; <span class="comment">// 指定要高亮的字段</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;em&gt;&quot;</span>,  <span class="comment">// 用来标记高亮字段的前置标签</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/em&gt;&quot;</span> <span class="comment">// 用来标记高亮字段的后置标签</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:</p><ul><li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li><li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false</li></ul><h3 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h3><p>根据文档的属性值对文档进行分组。<br>三类聚合：</p><ul><li><strong>桶（Bucket）</strong>聚合：用来对文档做分组<ul><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li><strong>度量（Metric）</strong>聚合：用以计算一些值，比如：最大值、最小值、平均值等<ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum等</li></ul></li><li><strong>管道（pipeline）</strong>聚合：其它聚合的结果为基础做聚合</li></ul><p>PS：参加聚合的字段必须是keyword、日期、数值、布尔类型</p><h4 id="Bucket聚合"><a href="#Bucket聚合" class="headerlink" title="Bucket聚合"></a>Bucket聚合</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,  <span class="comment">// 设置size为0，结果中不包含文档，只包含聚合结果</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123; <span class="comment">// 定义聚合</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123; <span class="comment">//给聚合起个名字</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123; <span class="comment">// 聚合的类型，按照品牌值聚合，所以选择term</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brand&quot;</span>, <span class="comment">// 参与聚合的字段</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">20</span> <span class="comment">// 希望获取的聚合结果数量</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聚合结果排序：Bucket聚合会统计Bucket内的文档数量记为_count，并且按照_count降序排序。可以指定order属性，自定义聚合的排序方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>, </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brand&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;_count&quot;</span>: <span class="string">&quot;asc&quot;</span> <span class="comment">// 按照_count升序排列</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限定聚合范围：限定要聚合的文档范围，只要添加query条件即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="number">200</span> <span class="comment">// 只对200元以下的文档聚合</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>, </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brand&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Metric聚合语法"><a href="#Metric聚合语法" class="headerlink" title="Metric聚合语法"></a>Metric聚合语法</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>, </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123; </span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123; </span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brand&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">20</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123; <span class="comment">// 是brands聚合的子聚合，也就是分组后对每组分别计算</span></span><br><span class="line">        <span class="attr">&quot;score_stats&quot;</span>: &#123; <span class="comment">// 聚合名称</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span>: &#123; <span class="comment">// 聚合类型，这里stats可以计算min、max、avg等</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;score&quot;</span> <span class="comment">// 聚合字段，这里是score</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器</h2><p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。<br>elasticsearch中分词器（analyzer）的组成包含三部分：</p><ul><li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</li><li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等<h3 id="拼音分词器"><a href="#拼音分词器" class="headerlink" title="拼音分词器"></a>拼音分词器</h3>拼音分词插件，地址：<a class="link"   href="https://github.com/medcl/elasticsearch-analysis-pinyin" >https://github.com/medcl/elasticsearch-analysis-pinyin<i class="fas fa-external-link-alt"></i></a><br>安装同IK分词器<br>安装后测试：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;如家酒店还不错&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;pinyin&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明自定义分词器"><a href="#声明自定义分词器" class="headerlink" title="声明自定义分词器"></a>声明自定义分词器</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PUT /test</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: &#123; <span class="comment">// 自定义分词器</span></span><br><span class="line">        <span class="attr">&quot;my_analyzer&quot;</span>: &#123;  <span class="comment">// 分词器名称</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: <span class="string">&quot;py&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123; <span class="comment">// 自定义tokenizer filter</span></span><br><span class="line">        <span class="attr">&quot;py&quot;</span>: &#123; <span class="comment">// 过滤器名称</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;pinyin&quot;</span>, <span class="comment">// 过滤器类型，这里是pinyin</span></span><br><span class="line">  <span class="attr">&quot;keep_full_pinyin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;keep_joined_full_pinyin&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;keep_original&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;limit_first_letter_length&quot;</span>: <span class="number">16</span>,</span><br><span class="line">          <span class="attr">&quot;remove_duplicated_term&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;none_chinese_pinyin_tokenize&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;my_analyzer&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动补全查询"><a href="#自动补全查询" class="headerlink" title="自动补全查询"></a>自动补全查询</h3>elasticsearch提供了<strong>Completion Suggester</strong>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</li><li>参与补全查询的字段必须是completion类型。</li><li>字段的内容一般是用来补全的多个词条形成的数组。</li></ul><p>eg：</p><ol><li>创建索引库<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建索引库</span></span><br><span class="line">PUT test</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;completion&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>插入数据<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">POST test/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: [<span class="string">&quot;Sony&quot;</span>, <span class="string">&quot;WH-1000XM3&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">POST test/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: [<span class="string">&quot;SK-II&quot;</span>, <span class="string">&quot;PITERA&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">POST test/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: [<span class="string">&quot;Nintendo&quot;</span>, <span class="string">&quot;switch&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试自动补全<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动补全查询</span></span><br><span class="line">GET /test/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;suggest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;title_suggest&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;s&quot;</span>, <span class="comment">// 关键字</span></span><br><span class="line">      <span class="attr">&quot;completion&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;title&quot;</span>, <span class="comment">// 补全查询的字段</span></span><br><span class="line">        <span class="attr">&quot;skip_duplicates&quot;</span>: <span class="literal">true</span>, <span class="comment">// 跳过重复的</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span> <span class="comment">// 获取前10条结果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="RestAPI"><a href="#RestAPI" class="headerlink" title="RestAPI"></a>RestAPI</h2><p>操作ES的客户端，官方文档：<a class="link"   href="https://www.elastic.co/guide/en/elasticsearch/client/index.html" >https://www.elastic.co/guide/en/elasticsearch/client/index.html<i class="fas fa-external-link-alt"></i></a></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>引入ES RestHighLevelClient依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>覆盖SpringBoot的默认版本<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>初始化RestHighLevelClient<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure>单元测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelIndexTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作索引库"><a href="#操作索引库" class="headerlink" title="操作索引库"></a>操作索引库</h3><h4 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h4>使用Java代码操作ES时，操作步骤可以仿照DSL语句来编写代码，逻辑会比较清晰<img src="/2022/07/15/springcloud-xue-xi-bi-ji/025.jpg" class="">准备DSL语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.constants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPING_TEMPLATE = <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;address\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;score\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;city\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;starName\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;business\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;location\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;geo_point\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;pic\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;all\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向ES发送请求创建索引库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求的参数：DSL语句</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。</li><li>添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li><li>发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</li></ul><h4 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h4><ul><li>创建Request对象。这次是DeleteIndexRequest对象</li><li>准备参数。这里是无参</li><li>发送请求。改用delete方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDeleteHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询索引库是否存在"><a href="#查询索引库是否存在" class="headerlink" title="查询索引库是否存在"></a>查询索引库是否存在</h4><ul><li>创建Request对象。这次是GetIndexRequest对象</li><li>准备参数。这里是无参</li><li>发送请求。改用exists方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testExistsHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="keyword">boolean</span> exists = client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    System.err.println(exists ? <span class="string">&quot;索引库已经存在！&quot;</span> : <span class="string">&quot;索引库不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Java操作索引库的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxIndexRequest。XXX是Create、Get、Delete</li><li>准备DSL（ Create时需要，其它是无参）</li><li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li></ul><h3 id="操作文档"><a href="#操作文档" class="headerlink" title="操作文档"></a>操作文档</h3><h4 id="索引库实体类"><a href="#索引库实体类" class="headerlink" title="索引库实体类"></a>索引库实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelDoc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;<span class="comment">//对应ES中的坐标类型，geo_point</span></span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotelDoc</span><span class="params">(Hotel hotel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="keyword">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="keyword">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="keyword">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="keyword">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="keyword">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="keyword">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="keyword">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="keyword">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="keyword">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="keyword">this</span>.pic = hotel.getPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h4><img src="/2022/07/15/springcloud-xue-xi-bi-ji/026.jpg" class=""><ul><li>创建Request对象</li><li>准备请求参数，也就是DSL中的JSON文档</li><li>发送请求</li></ul><p>从数据库中查询数据，再将数据转换成JSON文档存储在ES中</p><ul><li>根据id查询酒店数据Hotel</li><li>将Hotel封装为HotelDoc</li><li>将HotelDoc序列化为JSON</li><li>创建IndexRequest，指定索引库名和id</li><li>准备请求参数，也就是JSON文档</li><li>发送请求</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.根据id查询酒店数据</span></span><br><span class="line">    Hotel hotel = hotelService.getById(<span class="number">61083L</span>);</span><br><span class="line">    <span class="comment">// 2.转换为文档类型</span></span><br><span class="line">    HotelDoc hotelDoc = <span class="keyword">new</span> HotelDoc(hotel);</span><br><span class="line">    <span class="comment">// 3.将HotelDoc转json</span></span><br><span class="line">    String json = JSON.toJSONString(hotelDoc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;hotel&quot;</span>).id(hotelDoc.getId().toString());</span><br><span class="line">    <span class="comment">// 2.准备Json文档</span></span><br><span class="line">    request.source(json, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询文档-2"><a href="#查询文档-2" class="headerlink" title="查询文档"></a>查询文档</h4><ul><li>准备Request对象。这次是查询，所以是GetRequest</li><li>发送请求，得到结果。因为是查询，这里调用client.get()方法</li><li>解析结果，就是对JSON做反序列化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    GetRequest request = <span class="keyword">new</span> GetRequest(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61082&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求，得到响应</span></span><br><span class="line">    GetResponse response = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.解析响应结果</span></span><br><span class="line">    String json = response.getSourceAsString();</span><br><span class="line"></span><br><span class="line">    HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">    System.out.println(hotelDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h4><ul><li>准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id</li><li>准备参数，无参</li><li>发送请求。因为是删除，所以是client.delete()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    DeleteRequest request = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h4><p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p><ul><li>如果新增时，ID已经存在，则修改</li><li>如果新增时，ID不存在，则新增</li></ul><p>以下是增量修改代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    UpdateRequest request = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">        <span class="string">&quot;price&quot;</span>, <span class="string">&quot;952&quot;</span>,</span><br><span class="line">        <span class="string">&quot;starName&quot;</span>, <span class="string">&quot;四钻&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>文档操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li><li>准备参数（Index、Update、Bulk时需要）</li><li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li><li>解析结果（Get时需要）</li></ul><h3 id="查询文档-3"><a href="#查询文档-3" class="headerlink" title="查询文档"></a>查询文档</h3><p>基本步骤:</p><ul><li>准备Request对象</li><li>准备请求参数</li><li>发起请求</li><li>解析响应</li></ul><h4 id="match-all查询"><a href="#match-all查询" class="headerlink" title="match_all查询"></a>match_all查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;hotelDoc = &quot;</span> + hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建SearchRequest对象</li><li>准备Request.source()，也就是DSL。<ul><li>QueryBuilders来构建查询条件</li><li>传入Request.source() 的 query() 方法</li></ul></li><li>发送请求，得到结果</li><li>解析结果（参考JSON结果，从外到内，逐层解析）</li></ol><p>API:</p><ul><li>request.soure()，包含了查询、分页、排序高亮等功能</li><li>QueryBuilders，包含match、term、function_score、bool等各种查询</li></ul><img src="/2022/07/15/springcloud-xue-xi-bi-ji/031.jpg" class=""><p>解析响应：逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<ul><li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组<ul><li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据</li></ul></li></ul></li></ul><h4 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h4><p>查询流程同上，差异是使用到的API：</p><ul><li>QueryBuilders.termQuery()</li><li>QueryBuilders.rangeQuery().gte().lte()</li></ul><h4 id="布尔查询-1"><a href="#布尔查询-1" class="headerlink" title="布尔查询"></a>布尔查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.准备BooleanQuery</span></span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.添加term</span></span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;杭州&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.3.添加range</span></span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序、分页、高亮"><a href="#排序、分页、高亮" class="headerlink" title="排序、分页、高亮"></a>排序、分页、高亮</h4><ol><li>排序分页<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 页码，每页大小</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">1</span>, size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 2.2.排序 sort</span></span><br><span class="line">    request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页 from、size</span></span><br><span class="line">    request.source().from((page - <span class="number">1</span>) * size).size(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>高亮<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;</span><br><span class="line">            <span class="comment">// 根据字段名获取高亮结果</span></span><br><span class="line">            HighlightField highlightField = highlightFields.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (highlightField != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取高亮值</span></span><br><span class="line">                String name = highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">                hotelDoc.setName(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hotelDoc = &quot;</span> + hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</li><li>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</li><li>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</li><li>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li><li>第五步：用高亮的结果替换HotelDoc中的非高亮结果</li></ul><h3 id="数据聚合-1"><a href="#数据聚合-1" class="headerlink" title="数据聚合"></a>数据聚合</h3><p>请求API：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/032.jpg" class=""><p>返回结果解析：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/033.jpg" class=""><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>数据库中的数据和ES中的数据保持一致。</p><ul><li>同步调用：依次更新数据库和ES，实现简单，但是业务会耗时较长，业务耦合度高。</li><li>异步调用：数据库写入完成后使用异步消息队列来通知ES更新数据，响应时间短，但实现复杂，而且依赖消息队列的可靠性。</li><li>监听binlog：Mysql主从模式下，主服务器会将数据操作记录到binlog中，通过binlog实现主从数据库的数据一致，因此我们可以通过监听binlog的方式来实现Mysql和ES的数据一致。</li></ul><h2 id="ES集群"><a href="#ES集群" class="headerlink" title="ES集群"></a>ES集群</h2><h3 id="部署集群"><a href="#部署集群" class="headerlink" title="部署集群"></a>部署集群</h3><p>使用虚拟机利用docker模拟ES集群，docker-compose文件如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  es01:</span><br><span class="line">    image: elasticsearch:7.12.1</span><br><span class="line">    container_name: es01</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es01</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es02,es03</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02,es03</span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - data01:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line">  es02:</span><br><span class="line">    image: elasticsearch:7.12.1</span><br><span class="line">    container_name: es02</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es02</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es01,es03</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02,es03</span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - data02:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - 9201:9200</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line">  es03:</span><br><span class="line">    image: elasticsearch:7.12.1</span><br><span class="line">    container_name: es03</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es03</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es01,es02</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02,es03</span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - data03:/usr/share/elasticsearch/data</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line">    ports:</span><br><span class="line">      - 9202:9200</span><br><span class="line">volumes:</span><br><span class="line">  data01:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line">  data02:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line">  data03:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  elastic:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><ol><li>修改linux系统权限，修改 /etc/sysctl.conf 文件，添加：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></table></figure></li><li>执行命令，使配置生效<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li>重启ES集群<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ol><h3 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h3><p>推荐使用cerebro来监控es集群状态，官方网址：<a class="link"   href="https://github.com/lmenezes/cerebro" >https://github.com/lmenezes/cerebro<i class="fas fa-external-link-alt"></i></a><br>安装成功后，进入bin目录双击 cerebro.bat 文件启动cerebro，访问 <a class="link"   href="http://localhost:9000/" >http://localhost:9000<i class="fas fa-external-link-alt"></i></a> 进入控制台</p><h3 id="集群脑裂问题"><a href="#集群脑裂问题" class="headerlink" title="集群脑裂问题"></a>集群脑裂问题</h3><p>集群ES节点的职责划分：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/034.jpg" class=""><p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。将集群职责分离有利于提高集群工作效率：</p><ul><li>master节点：对CPU要求高，但是内存要求第</li><li>data节点：对CPU和内存要求都高</li><li>coordinating节点：对网络带宽、CPU要求高</li></ul><p>典型集群职责划分：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/035.jpg" class=""><h4 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h4><p>当ES集群中主节点和其他节点失联（主节点并未宕机），导致从节点中选出一个新的主节点，旧主节点恢复连接后，集群便会出现两个主节点，造成集群数据不一致（旧主节点自成集群，新主节点和其他节点构成新集群）。<br>解决方案：要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题。<br>eg：3个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p><h3 id="集群分布式存储"><a href="#集群分布式存储" class="headerlink" title="集群分布式存储"></a>集群分布式存储</h3><h4 id="分片Shard和副本Replicas"><a href="#分片Shard和副本Replicas" class="headerlink" title="分片Shard和副本Replicas"></a>分片Shard和副本Replicas</h4><p>ES提供了把 Index（索引）拆分到多个 Shard（分片）中的能力。在创建索引时，可以定义 Shard的数量。每个 Shard 本身就是一个全功能的和独立的 “Index（索引）”，Shard可以存储在集群中的任何节点上。ES会通过hash算法来计算文档应该存储到哪个分片：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/036.jpg" class=""><ul><li>_routing默认是文档的id</li><li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li></ul><p>在网络/云环境中可能随时会故障，为了数据的安全性和可靠性，ES 可以让您设置一个或多个索引的 Shard 副本到所谓的副本分片，或者副本中去。</p><ul><li>在 shard/node 故障的情况下提供了高可用性。为了达到这个目的，需要注意的是在原始的/主 Shard 被复制时副本的 Shard 不会被分配到相同的节点上。</li><li>它可以让你水平扩展搜索量/吞吐量，因为搜索可以在所有的副本上并行执行。</li></ul><p>每个索引可以被拆分成多个分片，一个索引可以设置 0 个（没有副本）或多个副本。开启副本后，每个索引将有主分片（被复制的原始分片）和副本分片（主分片的副本）。分片和副本的数量在索引被创建时都能够被指定。在创建索引后，您也可以在任何时候动态的改变副本的数量，但是不能够改变分片数量。<br>默认情况下，Elasticsearch 中的每个索引分配了 5 个主分片和 1 个副本，这也就意味着如果您的集群至少有两个节点的话，您的索引将会有 5 个主分片和另外 5 个副本分片（1 个完整的副本），每个索引共计 10 个分片。</p><h4 id="新增文档流程"><a href="#新增文档流程" class="headerlink" title="新增文档流程"></a>新增文档流程</h4><img src="/2022/07/15/springcloud-xue-xi-bi-ji/037.jpg" class=""><ul><li>新增一个id=1的文档</li><li>对id做hash运算，假如得到的是2，则应该存储到shard-2</li><li>shard-2的主分片在node3节点，将数据路由到node3</li><li>保存文档</li><li>同步给shard-2的副本replica-2，在node2节点</li><li>返回结果给coordinating-node节点</li></ul><h4 id="查询文档流程"><a href="#查询文档流程" class="headerlink" title="查询文档流程"></a>查询文档流程</h4><img src="/2022/07/15/springcloud-xue-xi-bi-ji/038.jpg" class=""><ul><li>scatter phase：分散阶段，coordinating node会把请求分发到每一个分片</li><li>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</li></ul><h3 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a>集群故障转移</h3><p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p><ol><li>ode1是主节点，其它两个节点是从节点。</li><li>突然node1发生了故障<img src="/2022/07/15/springcloud-xue-xi-bi-ji/040.jpg" class=""></li><li>宕机后的第一件事，需要重新选主，例如选中了node2：<img src="/2022/07/15/springcloud-xue-xi-bi-ji/041.jpg" class=""></li><li>node2成为主节点后会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3： <img src="/2022/07/15/springcloud-xue-xi-bi-ji/042.jpg" class=""></li></ol><h1 id="微服务保护"><a href="#微服务保护" class="headerlink" title="微服务保护"></a>微服务保护</h1><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a class="link"   href="https://sentinelguard.io/zh-cn/index.html" >https://sentinelguard.io/zh-cn/index.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="初识sentinel"><a href="#初识sentinel" class="headerlink" title="初识sentinel"></a>初识sentinel</h2><ol><li>下载安装Sentinel</li><li>运行<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar</span><br></pre></td></tr></table></figure>如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置：</li></ol><table><thead><tr><th><strong>配置项</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>server.port</td><td>8080</td><td>服务端口</td></tr><tr><td>sentinel.dashboard.auth.username</td><td>sentinel</td><td>默认用户名</td></tr><tr><td>sentinel.dashboard.auth.password</td><td>sentinel</td><td>默认密码</td></tr></tbody></table><p>例如，修改端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8090 -jar sentinel-dashboard-1.8.1.jar</span><br></pre></td></tr></table></figure><ol start="3"><li>Sentinel控制台，访问<a class="link"   href="http://localhost:8080/" >http://localhost:8080<i class="fas fa-external-link-alt"></i></a> ，输入账号和密码，默认都是：sentinel</li></ol><h3 id="微服务整合Sentinel"><a href="#微服务整合Sentinel" class="headerlink" title="微服务整合Sentinel"></a>微服务整合Sentinel</h3><ol><li>引入sentinel依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>配置控制台，修改application.yaml文件，添加：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br></pre></td></tr></table></figure></li><li>访问order-service的任意端点，触发sentinel的监控。访问sentinel的控制台，查看效果</li></ol><h3 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h3><p>一个微服务发生故障，导致依赖于该微服务的整个服务链发生故障，甚至发生级联故障造成大范围内的微服务不可用，即微服务的雪崩问题。<br>几种解决方案：</p><ul><li>超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待</li><li>仓壁模式：可以限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离</li><li>断路器：由断路器统计业务执行的异常比例，如果超出阈值则会<strong>熔断</strong>该业务，拦截访问该业务的一切请求。</li><li>流量控制：限制业务访问的QPS，避免服务因流量的突增而故障。</li></ul><p>小结：</p><ul><li><strong>限流</strong>是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种<strong>预防</strong>措施。</li><li><strong>超时处理、线程隔离、降级熔断</strong>是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种<strong>补救</strong>措施。</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h3><p>当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做<strong>簇点链路</strong>。簇点链路中被监控的每一个接口就是一个<strong>资源</strong>。<br>默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。</p><h3 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h3><ul><li>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式</li><li>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</li><li>链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流</li></ul><h3 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h3><p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种：</p><ul><li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。</li><li>warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</li><li>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</li></ul><h3 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h3><p>限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是<strong>分别统计参数值相同的请求</strong>，判断是否超过QPS阈值。<br>PS：热点参数限流对默认的SpringMVC资源无效，需要利用@SentinelResource注解标记资源</p><h2 id="隔离、降级"><a href="#隔离、降级" class="headerlink" title="隔离、降级"></a>隔离、降级</h2><p>限流是一种预防措施，虽然可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。要将这些故障控制在一定范围，避免雪崩，就要靠<strong>线程隔离</strong>（舱壁模式）和<strong>熔断降级</strong><br>不管是线程隔离还是熔断降级，都是对<strong>客户端</strong>（调用方）的保护。需要在<strong>调用方</strong> 发起远程调用时做线程隔离、或者服务熔断。我们的微服务远程调用都是基于Feign来完成的，因此我们需要将Feign与Sentinel整合，在Feign里面实现线程隔离和服务熔断。</p><h3 id="FeignClient整合Sentinel"><a href="#FeignClient整合Sentinel" class="headerlink" title="FeignClient整合Sentinel"></a>FeignClient整合Sentinel</h3><ol><li>修改配置，开启sentinel功能<br>修改OrderService的application.yml文件，开启Feign的Sentinel功能：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure></li><li>编写失败降级逻辑<br>业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。给FeignClient编写失败后的降级逻辑：</li></ol><ul><li>方式一：FallbackClass，无法对远程调用的异常做处理</li><li>方式二：FallbackFactory，可以对远程调用的异常做处理（推荐使用）</li></ul><p>eg：降级逻辑实现方式二</p><ol><li>自定义类实现FallbackFactory<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.feign.clients.fallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.feign.clients.UserClient;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.feign.pojo.User;</span><br><span class="line"><span class="keyword">import</span> feign.hystrix.FallbackFactory;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">UserClient</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserClient <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserClient() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">                log.error(<span class="string">&quot;查询用户异常&quot;</span>, throwable);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>将自定义类UserClientFallbackFactory注册为一个Bean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserClientFallbackFactory <span class="title">userClientFallbackFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserClientFallbackFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在UserClient接口中使用UserClientFallbackFactory<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.itcast.feign.clients.fallback.UserClientFallbackFactory;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.feign.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, fallbackFactory = UserClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="线程隔离（舱壁模式）"><a href="#线程隔离（舱壁模式）" class="headerlink" title="线程隔离（舱壁模式）"></a>线程隔离（舱壁模式）</h3><p>线程隔离有两种方式实现：</p><ul><li>线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</li><li>信号量隔离（Sentinel默认采用）：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求</li></ul><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><p><strong>断路器</strong>统计服务调用的异常比例、慢请求比例，如果超出阈值则会<strong>熔断</strong>该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。断路器控制熔断和放行是通过状态机来完成的：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/043.jpg" class=""><p>状态机包括三个状态：</p><ul><li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li>open：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后会进入half-open状态</li><li>half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。<ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p>断路器熔断策略有三种：</p><ul><li>慢调用：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断</li><li>异常比例：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值，则触发熔断</li><li>异常数：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常超过指定异常数达，则触发熔断</li></ul><h2 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h2><h3 id="授权规则-1"><a href="#授权规则-1" class="headerlink" title="授权规则"></a>授权规则</h3><p>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</p><ul><li>白名单：来源（origin）在白名单内的调用者允许访问</li><li>黑名单：来源（origin）在黑名单内的调用者不允许访问<img src="/2022/07/15/springcloud-xue-xi-bi-ji/044.jpg" class=""></li></ul><p>通过<strong>流控应用</strong>选项来指定调用方，sentiel通过获取Request请求头中的<strong>origin</strong>字段来获取调用方的名称。</p><h4 id="获取origin"><a href="#获取origin" class="headerlink" title="获取origin"></a>获取origin</h4><p>Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。默认情况下，sentinel不管请求者从哪里来，返回值永远是default。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestOriginParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从请求request对象中获取origin，获取方式自定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">parseOrigin</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们需要自定义这个接口的实现，让<strong>不同的请求，返回不同的origin</strong><br>eg：order-service服务中，定义一个RequestOriginParser的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.RequestOriginParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderOriginParser</span> <span class="keyword">implements</span> <span class="title">RequestOriginParser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">parseOrigin</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头</span></span><br><span class="line">        String origin = request.getHeader(<span class="string">&quot;origin&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(origin)) &#123;</span><br><span class="line">            origin = <span class="string">&quot;blank&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请求附带origin请求头"><a href="#请求附带origin请求头" class="headerlink" title="请求附带origin请求头"></a>请求附带origin请求头</h4><p>获取origin的方式是从reques-header中获取origin值，我们需要让<strong>所有从gateway路由到微服务的请求都带上origin头</strong>。<br>利用GatewayFilter——AddRequestHeaderGatewayFilter。修改gateway服务中的application.yml，添加一个defaultFilter：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=origin,gateway</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">       <span class="comment"># ...略</span></span><br></pre></td></tr></table></figure><h4 id="配置授权规则"><a href="#配置授权规则" class="headerlink" title="配置授权规则"></a>配置授权规则</h4><img src="/2022/07/15/springcloud-xue-xi-bi-ji/045.jpg" class=""><p>跳过网关，访问order-service服务，结果如下：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/046.jpg" class="">:<p>通过gateway网关访问，结果如下：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/047.jpg" class=""><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BlockException e：被sentinel拦截时抛出的异常，子类如下</li></ul><table><thead><tr><th><strong>异常</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>FlowException</td><td>限流异常</td></tr><tr><td>ParamFlowException</td><td>热点参数限流的异常</td></tr><tr><td>DegradeException</td><td>降级异常</td></tr><tr><td>AuthorityException</td><td>授权规则异常</td></tr><tr><td>SystemBlockException</td><td>系统规则异常</td></tr></tbody></table><p>自定义异常处理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.BlockExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.authority.AuthorityException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.degrade.DegradeException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelExceptionHandler</span> <span class="keyword">implements</span> <span class="title">BlockExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;未知异常&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> status = <span class="number">429</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被限流了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ParamFlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被热点参数限流&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> DegradeException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被降级了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AuthorityException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;没有权限访问&quot;</span>;</span><br><span class="line">            status = <span class="number">401</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        response.setStatus(status);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&#123;\&quot;msg\&quot;: &quot;</span> + msg + <span class="string">&quot;, \&quot;status\&quot;: &quot;</span> + status + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h2><p>sentinel的所有规则都是内存存储，重启后所有规则都会丢失。在生产环境下，必须确保这些规则的持久化，避免丢失。<br>规则是否能持久化，取决于规则管理模式，sentinel支持三种规则管理模式：</p><ul><li>原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。</li><li>pull模式：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则<img src="/2022/07/15/springcloud-xue-xi-bi-ji/048.jpg" class=""></li><li>push模式：控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新<img src="/2022/07/15/springcloud-xue-xi-bi-ji/049.jpg" class=""></li></ul><p>配置方法参见官网：<a class="link"   href="https://sentinelguard.io/zh-cn/docs/dynamic-rule-configuration.html" >https://sentinelguard.io/zh-cn/docs/dynamic-rule-configuration.html<i class="fas fa-external-link-alt"></i></a></p><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务，要保证所有分支事务最终状态一致，这样的事务就是分布式事务。</p><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标：</p><ul><li>Consistency（一致性）</li><li>Availability（可用性）</li><li>Partition tolerance （分区容错性）<img src="/2022/07/15/springcloud-xue-xi-bi-ji/050.jpg" class=""></li></ul><p>CAP定理：分布式系统，不可能同时满足三个指标</p><ul><li>一致性：用户访问分布式系统中的任意节点，得到的数据必须一致</li><li>可用性：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝</li><li>分区容错性：<ul><li>分区：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</li><li>容错：在集群出现分区时，整个系统也要持续对外提供服务</li></ul></li></ul><p>在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance（分区容错性）是不可或缺的。</p><ul><li>如果此时要保证<strong>一致性</strong>，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用</li><li>如果此时要保证<strong>可用性</strong>，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致</li></ul><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p><ul><li><strong>Basically Available</strong> <strong>（基本可用）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li><strong>Soft State（软状态）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态。</li><li><strong>Eventually Consistent（最终一致性）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul><h3 id="分布式事务解决思路"><a href="#分布式事务解决思路" class="headerlink" title="分布式事务解决思路"></a>分布式事务解决思路</h3><p>分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：</p><ul><li>AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致</li><li>CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态</li></ul><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。官网地址：<a class="link"   href="http://seata.io/" >http://seata.io/<i class="fas fa-external-link-alt"></i></a> 。<br>Seata事务管理中有三个重要的角色：</p><ul><li><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。<img src="/2022/07/15/springcloud-xue-xi-bi-ji/051.jpg" class=""></li></ul><p>Seata基于上述架构提供了四种不同的分布式事务解决方案：</p><ul><li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li><li>TCC模式：最终一致的分阶段事务模式，有业务侵入</li><li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li><li>SAGA模式：长事务模式，有业务侵入</li></ul><p>PS：无论哪种方案，都离不开事务的协调者TC。</p><h3 id="Seata-tc-server-部署"><a href="#Seata-tc-server-部署" class="headerlink" title="Seata tc-server 部署"></a>Seata tc-server 部署</h3><h4 id="1-下载安装seata-server"><a href="#1-下载安装seata-server" class="headerlink" title="1. 下载安装seata-server"></a>1. 下载安装seata-server</h4><p>访问官网：<a class="link"   href="http://seata.io/" >http://seata.io/<i class="fas fa-external-link-alt"></i></a> ，下载安装解压压缩包</p><h4 id="2-修改conf目录下registry-conf文件"><a href="#2-修改conf目录下registry-conf文件" class="headerlink" title="2. 修改conf目录下registry.conf文件"></a>2. 修改conf目录下registry.conf文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">registry</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">    # seata tc 服务注册到 nacos的服务名称，可以自定义</span></span><br><span class="line">    <span class="attr">application</span> = <span class="string">&quot;seata-tc-server&quot;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">cluster</span> = <span class="string">&quot;SH&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">config</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"><span class="comment">  # 配置nacos地址等信息</span></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">dataId</span> = <span class="string">&quot;seataServer.properties&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-nacos添加配置信息"><a href="#3-nacos添加配置信息" class="headerlink" title="3. nacos添加配置信息"></a>3. nacos添加配置信息</h4><p>让tc服务的集群可以共享配置，我们选择了nacos作为统一配置中心。因此服务端配置文件seataServer.properties文件需要在nacos中配好。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据存储方式，db代表数据库</span></span><br><span class="line"><span class="meta">store.mode</span>=<span class="string">db</span></span><br><span class="line"><span class="meta">store.db.datasource</span>=<span class="string">druid</span></span><br><span class="line"><span class="meta">store.db.dbType</span>=<span class="string">mysql</span></span><br><span class="line"><span class="meta">store.db.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">store.db.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true</span></span><br><span class="line"><span class="meta">store.db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">store.db.password</span>=<span class="string">123</span></span><br><span class="line"><span class="meta">store.db.minConn</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">store.db.maxConn</span>=<span class="string">30</span></span><br><span class="line"><span class="meta">store.db.globalTable</span>=<span class="string">global_table</span></span><br><span class="line"><span class="meta">store.db.branchTable</span>=<span class="string">branch_table</span></span><br><span class="line"><span class="meta">store.db.queryLimit</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">store.db.lockTable</span>=<span class="string">lock_table</span></span><br><span class="line"><span class="meta">store.db.maxWait</span>=<span class="string">5000</span></span><br><span class="line"><span class="comment"># 事务、日志等配置</span></span><br><span class="line"><span class="meta">server.recovery.committingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">server.recovery.asynCommittingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">server.recovery.rollbackingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">server.recovery.timeoutRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">server.maxCommitRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="meta">server.maxRollbackRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="meta">server.rollbackRetryTimeoutUnlockEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">server.undo.logSaveDays</span>=<span class="string">7</span></span><br><span class="line"><span class="meta">server.undo.logDeletePeriod</span>=<span class="string">86400000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 客户端与服务端传输方式</span></span><br><span class="line"><span class="meta">transport.serialization</span>=<span class="string">seata</span></span><br><span class="line"><span class="meta">transport.compressor</span>=<span class="string">none</span></span><br><span class="line"><span class="comment"># 关闭metrics功能，提高性能</span></span><br><span class="line"><span class="meta">metrics.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">metrics.registryType</span>=<span class="string">compact</span></span><br><span class="line"><span class="meta">metrics.exporterList</span>=<span class="string">prometheus</span></span><br><span class="line"><span class="meta">metrics.exporterPrometheusPort</span>=<span class="string">9898</span></span><br></pre></td></tr></table></figure><p>PS：注意修改数据库地址、用户名、密码</p><h4 id="5-创建数据库表"><a href="#5-创建数据库表" class="headerlink" title="5. 创建数据库表"></a>5. 创建数据库表</h4><p>tc服务在管理分布式事务时，需要记录事务相关数据到数据库中，需要提前创建表。<br>新建seata数据库，运行sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 分支事务表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `branch_table`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `branch_table`  (</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource_group_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource_id` <span class="type">varchar</span>(<span class="number">256</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `branch_type` <span class="type">varchar</span>(<span class="number">8</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` tinyint(<span class="number">4</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `client_id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `application_data` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime(<span class="number">6</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_modified` datetime(<span class="number">6</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`branch_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_xid`(`xid`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 全局事务表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `global_table`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `global_table`  (</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `application_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_service_group` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `timeout` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `begin_time` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `application_data` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`xid`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_transaction_id`(`transaction_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="6-启动TC服务"><a href="#6-启动TC服务" class="headerlink" title="6. 启动TC服务"></a>6. 启动TC服务</h4><p>运行bin目录下seata-server.bat。打开浏览器，访问nacos地址：<a class="link"   href="http://localhost:8848/" >http://localhost:8848<i class="fas fa-external-link-alt"></i></a> ，进入服务列表页面，可以看到seata-tc-server的信息</p><h3 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata</h3><ol><li>引入Seata依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--版本较低，1.3.0，因此排除--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata starter 采用1.4.2版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>修改配置文件<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="comment"># 参考tc服务自己的registry.conf中的配置</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span> <span class="comment"># tc</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-tc-server</span> <span class="comment"># tc服务在nacos中的服务名称</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">SH</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">seata-demo</span> <span class="comment"># 事务组，根据这个获取tc服务的cluster名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与TC服务cluster的映射关系</span></span><br><span class="line">      <span class="attr">seata-demo:</span> <span class="string">SH</span></span><br></pre></td></tr></table></figure>微服务如何根据这些配置寻找TC的地址呢？注册到Nacos中的微服务，确定一个具体实例需要四个信息：</li></ol><ul><li>namespace：命名空间</li><li>group：分组</li><li>application：服务名</li><li>cluster：集群名</li></ul><p>以上四个信息，在刚才的yaml文件中都能找到：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/053.jpg" class=""><p>namespace为空，就是默认的public。结合起来，TC服务的信息就是：public@DEFAULT_GROUP@seata-tc-server@SH，这样就能确定TC服务集群了。然后就可以去Nacos拉取对应的实例信息了。</p><h3 id="Seata分布式事务解决方案"><a href="#Seata分布式事务解决方案" class="headerlink" title="Seata分布式事务解决方案"></a>Seata分布式事务解决方案</h3><h4 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h4><p>XA是规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。<br>正常情况：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/054.jpg" class=""><p>异常情况：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/055.jpg" class=""><p>一阶段：</p><ul><li>事务协调者通知每个事物参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作<ul><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul></li></ul><p><strong>XA模式优缺点</strong><br>优点：</p><ul><li>事务的强一致性，满足ACID原则。</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>缺点：</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><p><strong>Seata XA</strong>模型：Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/056.jpg" class=""><p>RM一阶段的工作：</p><ul><li>注册分支事务到TC</li><li>执行分支业务sql但不提交</li><li>报告执行状态到TC</li></ul><p>TC二阶段的工作：</p><ul><li>TC检测各分支事务执行状态<br>a.如果都成功，通知所有RM提交事务<br>b.如果有失败，通知所有RM回滚事务</li></ul><p>RM二阶段的工作：</p><ul><li>接收TC指令，提交或回滚事务</li></ul><p><strong>Seata实现XA模式</strong>：</p><ul><li>修改application.yml文件（每个参与事务的微服务），开启XA模式<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure></li><li>给发起全局事务的入口方法添加@GlobalTransactional注解</li><li>重启服务并测试</li></ul><h4 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h4><p><strong>Seata AT模型</strong>：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/057.jpg" class=""><p>阶段一RM的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时RM的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时RM的工作：</p><ul><li>根据undo-log恢复数据到更新前</li></ul><p>简述<strong>AT与XA的区别</strong></p><ul><li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</li><li>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</li><li>XA模式强一致；AT模式最终一致</li></ul><h5 id="脏写问题"><a href="#脏写问题" class="headerlink" title="脏写问题"></a>脏写问题</h5><p>在多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/058.jpg" class=""><p>解决思路就是引入了全局锁的概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/059.jpg" class=""><p><strong>实现AT模式</strong></p><ol><li>导入数据库表，记录全局锁<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Navicat Premium Data Transfer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Source Server         : local</span></span><br><span class="line"><span class="comment"> Source Server Type    : MySQL</span></span><br><span class="line"><span class="comment"> Source Server Version : 50622</span></span><br><span class="line"><span class="comment"> Source Host           : localhost:3306</span></span><br><span class="line"><span class="comment"> Source Schema         : seata_demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Target Server Type    : MySQL</span></span><br><span class="line"><span class="comment"> Target Server Version : 50622</span></span><br><span class="line"><span class="comment"> File Encoding         : 65001</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Date: 20/06/2021 12:39:03</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for undo_log</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `undo_log`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log`  (</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">  `log_created` datetime(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">  `log_modified` datetime(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `ux_undo_log`(`xid`, `branch_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;AT transaction mode undo table&#x27;</span> ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of undo_log</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for lock_table</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `lock_table`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `lock_table`  (</span><br><span class="line">  `row_key` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">96</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource_id` <span class="type">varchar</span>(<span class="number">256</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `pk` <span class="type">varchar</span>(<span class="number">36</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`row_key`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_branch_id`(`branch_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li>修改application.yml文件，将事务模式修改为AT模式<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">AT</span> <span class="comment"># 默认就是AT</span></span><br></pre></td></tr></table></figure></li><li>重启服务并测试</li></ol><p><strong>AT模式优缺点</strong><br>优点：</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能比较好</li><li>利用全局锁实现读写隔离</li><li>没有代码侵入，框架自动完成回滚和提交</li></ul><p>缺点：</p><ul><li>两阶段之间属于软状态，属于最终一致</li><li>框架的快照功能会影响性能，但比XA模式要好很多</li></ul><h4 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h4><p>TCC模式通过<strong>补偿操作</strong>来实现数据恢复，依靠人工编码来实现。需实现三个方法：</p><ul><li>Try：资源的检测和预留； </li><li>Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。</li><li>Cancel：预留资源释放，可以理解为try的反向操作。</li></ul><h5 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h5><p>一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。</p><ul><li><strong>阶段一（ Try ）</strong>：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30。此时，总金额 = 冻结金额 + 可用金额，数量依然是100不变。事务直接提交无需等待其它事务。</li><li>**阶段二（Confirm)**：假如要提交（Confirm），则冻结金额扣减30。确认可以提交，因为之前可用金额已经扣减过了，这里只要清除冻结金额。此时，总金额 = 冻结金额 + 可用金额 = 0 + 70  = 70元。</li><li>**阶段三(Canncel)**：如果要回滚（Cancel），则冻结金额扣减30，可用余额增加30。</li></ul><p><strong>TCC模型图</strong>和AT模式几乎相同，只是数据回滚不是依赖数据快照而是通过人工编码实现。</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/060.jpg" class=""><p><strong>TCC模式优缺点</strong><br>优点：</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模型，无需生成快照，无需使用全局锁，性能最强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul><p>缺点：</p><ul><li>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</li><li>软状态，事务是最终一致</li><li>需要考虑Confirm和Cancel的失败情况，做好幂等处理</li></ul><h5 id="事务悬挂和空回滚"><a href="#事务悬挂和空回滚" class="headerlink" title="事务悬挂和空回滚"></a>事务悬挂和空回滚</h5><ol><li>空回滚<br>当某分支事务的try阶段<strong>阻塞</strong>时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是<strong>空回滚</strong>。<img src="/2022/07/15/springcloud-xue-xi-bi-ji/061.jpg" class=""></li></ol><p><strong>执行cancel操作时，应当判断try是否已经执行，如果尚未执行，则应该空回滚。</strong><br>2. 事务悬挂<br>对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能confirm或cancel ，事务一直处于中间状态，这就是<strong>业务（事务）悬挂</strong>。<br><strong>执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂</strong></p><h5 id="TCC模式实现"><a href="#TCC模式实现" class="headerlink" title="TCC模式实现"></a>TCC模式实现</h5><p><strong>解决空回滚和业务悬挂问题，必须要记录当前事务状态，是在try、还是cancel</strong></p><h6 id="1-案例分析"><a href="#1-案例分析" class="headerlink" title="1. 案例分析"></a>1. 案例分析</h6><p>定义数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account_freeze_tbl` (</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `freeze_money` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;冻结金额&#x27;</span>,</span><br><span class="line">  `state` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;事务状态，0:try，1:confirm，2:cancel&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`xid`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure><ul><li>xid：是全局事务id</li><li>freeze_money：用来记录用户冻结金额</li><li>state：用来记录事务状态</li></ul><p>那么业务该怎么做呢？</p><ul><li>Try业务：<ul><li>记录冻结金额和事务状态到account_freeze表</li><li>扣减account表可用金额</li></ul></li><li>Confirm业务<ul><li>根据xid删除account_freeze表的冻结记录</li></ul></li><li>Cancel业务<ul><li>修改account_freeze表，冻结金额为0，state为2</li><li>修改account表，恢复可用金额</li></ul></li><li>如何判断是否空回滚？<ul><li>cancel业务中，根据xid查询account_freeze，如果为null则说明try还没做，需要空回滚</li></ul></li><li>如何避免业务悬挂？<ul><li>try业务中，根据xid查询account_freeze ，如果已经存在则证明Cancel已经执行，拒绝执行try业务</li></ul></li></ul><h6 id="2-声明TCC接口"><a href="#2-声明TCC接口" class="headerlink" title="2. 声明TCC接口"></a>2. 声明TCC接口</h6><p>TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明。<br>新建一个接口，声明TCC三个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.account.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.BusinessActionContext;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.BusinessActionContextParameter;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.LocalTCC;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.TwoPhaseBusinessAction;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LocalTCC</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountTCCService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(name = &quot;deduct&quot;, commitMethod = &quot;confirm&quot;, rollbackMethod = &quot;cancel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deduct</span><span class="params">(<span class="meta">@BusinessActionContextParameter(paramName = &quot;userId&quot;)</span> String userId,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="meta">@BusinessActionContextParameter(paramName = &quot;money&quot;)</span><span class="keyword">int</span> money)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">confirm</span><span class="params">(BusinessActionContext ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(BusinessActionContext ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-编写实现类"><a href="#3-编写实现类" class="headerlink" title="3. 编写实现类"></a>3. 编写实现类</h6><p>新建一个类，实现TCC业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.account.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.entity.AccountFreeze;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.mapper.AccountFreezeMapper;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.mapper.AccountMapper;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.service.AccountTCCService;</span><br><span class="line"><span class="keyword">import</span> io.seata.core.context.RootContext;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.BusinessActionContext;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTCCServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountTCCService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountFreezeMapper freezeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduct</span><span class="params">(String userId, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0.获取事务id</span></span><br><span class="line">        String xid = RootContext.getXID();</span><br><span class="line">        <span class="comment">// 1.扣减可用余额</span></span><br><span class="line">        accountMapper.deduct(userId, money);</span><br><span class="line">        <span class="comment">// 2.记录冻结金额，事务状态</span></span><br><span class="line">        AccountFreeze freeze = <span class="keyword">new</span> AccountFreeze();</span><br><span class="line">        freeze.setUserId(userId);</span><br><span class="line">        freeze.setFreezeMoney(money);</span><br><span class="line">        freeze.setState(AccountFreeze.State.TRY);</span><br><span class="line">        freeze.setXid(xid);</span><br><span class="line">        freezeMapper.insert(freeze);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">confirm</span><span class="params">(BusinessActionContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取事务id</span></span><br><span class="line">        String xid = ctx.getXid();</span><br><span class="line">        <span class="comment">// 2.根据id删除冻结记录</span></span><br><span class="line">        <span class="keyword">int</span> count = freezeMapper.deleteById(xid);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(BusinessActionContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0.查询冻结记录</span></span><br><span class="line">        String xid = ctx.getXid();</span><br><span class="line">        AccountFreeze freeze = freezeMapper.selectById(xid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.恢复可用余额</span></span><br><span class="line">        accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney());</span><br><span class="line">        <span class="comment">// 2.将冻结金额清零，状态改为CANCEL</span></span><br><span class="line">        freeze.setFreezeMoney(<span class="number">0</span>);</span><br><span class="line">        freeze.setState(AccountFreeze.State.CANCEL);</span><br><span class="line">        <span class="keyword">int</span> count = freezeMapper.updateById(freeze);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SAGA模式"><a href="#SAGA模式" class="headerlink" title="SAGA模式"></a>SAGA模式</h4><p>Seata官网对于Saga的指南：<a class="link"   href="https://seata.io/zh-cn/docs/user/saga.html" >https://seata.io/zh-cn/docs/user/saga.html<i class="fas fa-external-link-alt"></i></a></p><p><strong>原理</strong>：<br>在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p><p>Saga分为两个阶段：</p><ul><li>一阶段：直接提交本地事务</li><li>二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚</li></ul><p><strong>SAGA优缺点</strong><br>优点：</p><ul><li>事务参与者可以基于事件驱动实现异步调用，吞吐高</li><li>一阶段直接提交事务，无锁，性能好</li><li>不用编写TCC中的三个阶段，实现简单</li></ul><p>缺点：</p><ul><li>软状态持续时间不确定，时效性差</li><li>没有锁，没有事务隔离，会有脏写</li></ul><h4 id="四种模式对比"><a href="#四种模式对比" class="headerlink" title="四种模式对比"></a>四种模式对比</h4><p>从以下几个方面来对比四种实现：</p><ul><li>一致性：能否保证事务的一致性？强一致还是最终一致？</li><li>隔离性：事务之间的隔离性如何？</li><li>代码侵入：是否需要对业务代码改造？</li><li>性能：有无性能损耗？</li><li>场景：常见的业务场景<img src="/2022/07/15/springcloud-xue-xi-bi-ji/062.jpg" class=""></li></ul><h3 id="TC服务的高可用和异地容灾"><a href="#TC服务的高可用和异地容灾" class="headerlink" title="TC服务的高可用和异地容灾"></a>TC服务的高可用和异地容灾</h3><p>微服务基于事务组（tx-service-group)与TC集群的映射关系，来查找当前应该使用哪个TC集群。当SH集群故障时，只需要将vgroup-mapping中的映射关系改成HZ。则所有微服务就会切换到HZ的TC集群了。</p><h4 id="模拟异地容灾的TC集群"><a href="#模拟异地容灾的TC集群" class="headerlink" title="模拟异地容灾的TC集群"></a>模拟异地容灾的TC集群</h4><p>计划启动两台seata的tc服务节点：<br>| 节点名称 | ip地址    | 端口号 | 集群名称 |<br>| ——– | ——— | —— | ——– |<br>| seata    | 127.0.0.1 | 8091   | SH       |<br>| seata2   | 127.0.0.1 | 8092   | HZ       |</p><p>前面我们已经启动了一台seata服务，端口是8091，集群名为SH。现在，将seata目录复制一份，起名为seata2，修改seata2/conf/registry.conf内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">registry</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">    # seata tc 服务注册到 nacos的服务名称，可以自定义</span></span><br><span class="line">    <span class="attr">application</span> = <span class="string">&quot;seata-tc-server&quot;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">cluster</span> = <span class="string">&quot;HZ&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">config</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"><span class="comment">  # 配置nacos地址等信息</span></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">dataId</span> = <span class="string">&quot;seataServer.properties&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>进入seata2/bin目录，然后运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seata-server.bat -p 8092</span><br></pre></td></tr></table></figure><p>打开nacos控制台，查看服务列表，点进详情查看：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/052.jpg" class=""><h4 id="将事务组映射配置到nacos"><a href="#将事务组映射配置到nacos" class="headerlink" title="将事务组映射配置到nacos"></a>将事务组映射配置到nacos</h4><p>需要将tx-service-group与cluster的映射关系都配置到nacos配置中心，新建一个配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务组映射关系</span></span><br><span class="line"><span class="meta">service.vgroupMapping.seata-demo</span>=<span class="string">SH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">service.enableDegrade</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">service.disableGlobalTransaction</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 与TC服务的通信配置</span></span><br><span class="line"><span class="meta">transport.type</span>=<span class="string">TCP</span></span><br><span class="line"><span class="meta">transport.server</span>=<span class="string">NIO</span></span><br><span class="line"><span class="meta">transport.heartbeat</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">transport.enableClientBatchSendRequest</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">transport.threadFactory.bossThreadPrefix</span>=<span class="string">NettyBoss</span></span><br><span class="line"><span class="meta">transport.threadFactory.workerThreadPrefix</span>=<span class="string">NettyServerNIOWorker</span></span><br><span class="line"><span class="meta">transport.threadFactory.serverExecutorThreadPrefix</span>=<span class="string">NettyServerBizHandler</span></span><br><span class="line"><span class="meta">transport.threadFactory.shareBossWorker</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">transport.threadFactory.clientSelectorThreadPrefix</span>=<span class="string">NettyClientSelector</span></span><br><span class="line"><span class="meta">transport.threadFactory.clientSelectorThreadSize</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">transport.threadFactory.clientWorkerThreadPrefix</span>=<span class="string">NettyClientWorkerThread</span></span><br><span class="line"><span class="meta">transport.threadFactory.bossThreadSize</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">transport.threadFactory.workerThreadSize</span>=<span class="string">default</span></span><br><span class="line"><span class="meta">transport.shutdown.wait</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"># RM配置</span></span><br><span class="line"><span class="meta">client.rm.asyncCommitBufferLimit</span>=<span class="string">10000</span></span><br><span class="line"><span class="meta">client.rm.lock.retryInterval</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">client.rm.lock.retryTimes</span>=<span class="string">30</span></span><br><span class="line"><span class="meta">client.rm.lock.retryPolicyBranchRollbackOnConflict</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">client.rm.reportRetryCount</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">client.rm.tableMetaCheckEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">client.rm.tableMetaCheckerInterval</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">client.rm.sqlParserType</span>=<span class="string">druid</span></span><br><span class="line"><span class="meta">client.rm.reportSuccessEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">client.rm.sagaBranchRegisterEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># TM配置</span></span><br><span class="line"><span class="meta">client.tm.commitRetryCount</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">client.tm.rollbackRetryCount</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">client.tm.defaultGlobalTransactionTimeout</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">client.tm.degradeCheck</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">client.tm.degradeCheckAllowTimes</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">client.tm.degradeCheckPeriod</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># undo日志配置</span></span><br><span class="line"><span class="meta">client.undo.dataValidation</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">client.undo.logSerialization</span>=<span class="string">jackson</span></span><br><span class="line"><span class="meta">client.undo.onlyCareUpdateColumns</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">client.undo.logTable</span>=<span class="string">undo_log</span></span><br><span class="line"><span class="meta">client.undo.compress.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">client.undo.compress.type</span>=<span class="string">zip</span></span><br><span class="line"><span class="meta">client.undo.compress.threshold</span>=<span class="string">64k</span></span><br><span class="line"><span class="meta">client.log.exceptionRate</span>=<span class="string">100</span></span><br></pre></td></tr></table></figure><h4 id="微服务读取nacos配置"><a href="#微服务读取nacos配置" class="headerlink" title="微服务读取nacos配置"></a>微服务读取nacos配置</h4><p>修改每一个微服务的application.yml文件，让微服务读取nacos中的client.properties文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">data-id:</span> <span class="string">client.properties</span></span><br></pre></td></tr></table></figure><p>重启微服务，现在微服务到底是连接tc的SH集群，还是tc的HZ集群，都统一由nacos的client.properties来决定了。</p><h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>参考Redis学习笔记。</p><h1 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h1><p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p><ul><li>浏览器访问静态资源时，优先读取浏览器本地缓存</li><li>访问非静态资源（ajax查询数据）时，访问服务端</li><li>请求到达Nginx后，优先读取Nginx本地缓存</li><li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</li><li>如果Redis查询未命中，则查询Tomcat</li><li>请求进入Tomcat后，优先查询JVM进程缓存</li><li>如果JVM进程缓存未命中，则查询数据库<img src="/2022/07/15/springcloud-xue-xi-bi-ji/063.jpg" class=""></li></ul><p>在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此nginx服务不再是一个<strong>反向代理服务器</strong>，而是一个编写<strong>业务的Web服务器了</strong>。因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，Tomcat服务将来也会部署为集群模式</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/064.jpg" class=""><p>多级缓存的关键有两个：</p><ul><li>一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询</li><li>另一个就是在Tomcat中实现JVM进程缓存</li></ul><h2 id="JVM进程缓存"><a href="#JVM进程缓存" class="headerlink" title="JVM进程缓存"></a>JVM进程缓存</h2><h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><p><strong>Caffeine</strong>是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：<a class="link"   href="https://github.com/ben-manes/caffeine" >https://github.com/ben-manes/caffeine<i class="fas fa-external-link-alt"></i></a></p><p>缓存使用基本流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBasicOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建cache对象</span></span><br><span class="line">    Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存数据</span></span><br><span class="line">    cache.put(<span class="string">&quot;gf&quot;</span>, <span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    String gf = cache.getIfPresent(<span class="string">&quot;gf&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;gf = &quot;</span> + gf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据，包含两个参数：</span></span><br><span class="line">    <span class="comment">// 参数一：缓存的key</span></span><br><span class="line">    <span class="comment">// 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑</span></span><br><span class="line">    <span class="comment">// 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式</span></span><br><span class="line">    String defaultGF = cache.get(<span class="string">&quot;defaultGF&quot;</span>, key -&gt; &#123;</span><br><span class="line">        <span class="comment">// 根据key去数据库查询数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;柳岩&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;defaultGF = &quot;</span> + defaultGF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Caffeine缓存驱逐策略：</p><ul><li><strong>基于容量</strong>：设置缓存的数量上限<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1</span>) <span class="comment">// 设置缓存大小上限为 1</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li><li><strong>基于时间</strong>：设置缓存的有效时间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    <span class="comment">// 设置缓存有效期为 10 秒，从最后一次写入开始计时 </span></span><br><span class="line">    .expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>)) </span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li><li><strong>基于引用</strong>：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用</li></ul><p>PS：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</p><h3 id="缓存实现示例"><a href="#缓存实现示例" class="headerlink" title="缓存实现示例"></a>缓存实现示例</h3><p>eg：利用Caffeine实现下列需求：</p><ul><li>给根据id查询商品的业务添加缓存，缓存未命中时查询数据库</li><li>给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库</li><li>缓存初始大小为100</li><li>缓存上限为10000</li></ul><ol><li>定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache&lt;Long, Item&gt; <span class="title">itemCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache&lt;Long, ItemStock&gt; <span class="title">stockCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修改item-service的ItemController类，添加缓存逻辑<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, ItemStock&gt; stockCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...其它略</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itemCache.get(id, key -&gt; itemService.query()</span><br><span class="line">                .ne(<span class="string">&quot;status&quot;</span>, <span class="number">3</span>).eq(<span class="string">&quot;id&quot;</span>, key)</span><br><span class="line">                .one()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/stock/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ItemStock <span class="title">findStockById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stockCache.get(id, key -&gt; stockService.getById(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="OpenRestry"><a href="#OpenRestry" class="headerlink" title="OpenRestry"></a>OpenRestry</h2><h3 id="快速入门Lua"><a href="#快速入门Lua" class="headerlink" title="快速入门Lua"></a>快速入门Lua</h3><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：<a class="link"   href="https://www.lua.org/" >https://www.lua.org/<i class="fas fa-external-link-alt"></i></a></p><p>为什么学习Lua？<br>因为对Nginx进行编程需要使用Lua（Nginx本身也是C语言开发，允许基于Lua做拓展），因此要实现Nginx缓存必须了解Lua</p><h4 id="HellodWorld"><a href="#HellodWorld" class="headerlink" title="HellodWorld"></a>HellodWorld</h4><ol><li>新建 hello.lua 文件</li><li>添加Lua语句<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)  </span><br></pre></td></tr></table></figure></li><li>运行<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua hello.lua</span><br></pre></td></tr></table></figure></li></ol><h4 id="变量、循环"><a href="#变量、循环" class="headerlink" title="变量、循环"></a>变量、循环</h4><p>Lua中支持的常见数据类型包括：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/065.png" class=""><p>PS：Lua提供了type()函数来判断一个变量的数据类型</p><p><strong>声明变量</strong>：<br>Lua声明变量的时候无需指定数据类型，而是用local来声明变量为局部变量</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明字符串，可以用单引号或双引号，</span></span><br><span class="line"><span class="keyword">local</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">-- 字符串拼接可以使用 ..</span></span><br><span class="line"><span class="keyword">local</span> str2 = <span class="string">&#x27;hello&#x27;</span> .. <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="comment">-- 声明数字</span></span><br><span class="line"><span class="keyword">local</span> num = <span class="number">21</span></span><br><span class="line"><span class="comment">-- 声明布尔类型</span></span><br><span class="line"><span class="keyword">local</span> flag = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Lua中的table类型既可以作为数组，又可以作为map。数组就是特殊的table，key是数组角标而已：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 ，key为角标的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 声明table，类似java的map</span></span><br><span class="line"><span class="keyword">local</span> map =  &#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">21</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 访问数组，lua数组的角标从1开始</span></span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 访问table,可以用key来访问</span></span><br><span class="line"><span class="built_in">print</span>(map[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(map.name)</span><br></pre></td></tr></table></figure><p><strong>循环</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 key为索引的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index, value) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 声明map，也就是table</span></span><br><span class="line"><span class="keyword">local</span> map = &#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">21</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历table</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(map) <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(key, value) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="条件控制、函数"><a href="#条件控制、函数" class="headerlink" title="条件控制、函数"></a>条件控制、函数</h4><p><strong>函数</strong>：<br>定义函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名<span class="params">( argument1, argument2..., argumentn)</span></span></span><br><span class="line">    <span class="comment">-- 函数体</span></span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>条件控制</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 false 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>PS：与java不同，布尔表达式中的逻辑运算是基于英文单词</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/066.png" class=""><h3 id="安装OpenRestry"><a href="#安装OpenRestry" class="headerlink" title="安装OpenRestry"></a>安装OpenRestry</h3><p>OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关：</p><ul><li>具备Nginx的完整功能</li><li>基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块</li><li>允许使用Lua<strong>自定义业务逻辑</strong>、<strong>自定义库</strong></li></ul><ol><li>安装开发库<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre-devel openssl-devel gcc --skip-broken</span><br></pre></td></tr></table></figure></li><li>安装OpenResty<br>（CentOS）添加 <code>openresty</code> 仓库，可以便于未来安装或更新软件包（通过 <code>yum check-update</code> 命令）<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo</span><br></pre></td></tr></table></figure>如果提示说命令不存在，则运行：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils </span><br></pre></td></tr></table></figure></li><li>安装OpenResty<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openresty</span><br></pre></td></tr></table></figure></li><li>安装opm工具<br>opm是OpenResty的一个管理工具，可以帮助我们安装一个第三方的Lua模块<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openresty-opm</span><br></pre></td></tr></table></figure></li><li>目录结构<br>默认情况下，OpenResty安装的目录是：/usr/local/openresty。OpenResty就是在Nginx基础上集成了一些Lua模块。</li><li>配置nginx的环境变量</li></ol><ul><li>打开配置文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure></li><li>添加内容（NGINX_HOME：后面是OpenResty安装目录下的nginx的目录）<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NGINX_HOME=/usr/<span class="built_in">local</span>/openresty/nginx</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;NGINX_HOME&#125;</span>/sbin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li>配置生效<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li>启动运行<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动nginx</span></span><br><span class="line">nginx</span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure></li></ol><p><strong>备注</strong>：<br>加载OpenResty的lua模块：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#lua 模块</span></span><br><span class="line"><span class="attribute">lua_package_path</span> <span class="string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;</span><br><span class="line"><span class="comment">#c模块     </span></span><br><span class="line"><span class="attribute">lua_package_cpath</span> <span class="string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;  </span><br></pre></td></tr></table></figure><p>common.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http not found, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure><p>释放Redis连接API：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>读取Redis数据的API：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">    <span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询redis</span></span><br><span class="line">    <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">    <span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--得到的数据为空处理</span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">        resp = <span class="literal">nil</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    close_redis(red)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>开启共享词典：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span></span><br><span class="line"><span class="attribute">lua_shared_dict</span> item_cache <span class="number">150m</span>; </span><br></pre></td></tr></table></figure><h3 id="监听请求"><a href="#监听请求" class="headerlink" title="监听请求"></a>监听请求</h3><p>我们希望达到的多级缓存架构如图：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/067.png" class=""><ul><li>windows上的nginx用来做反向代理服务，将前端的查询商品的ajax请求代理到OpenResty集群</li><li>OpenResty集群用来编写多级缓存业务</li></ul><p><strong>反向代理流程</strong>:</p><ol><li>浏览器发送请求,请求被nginx拦截</li><li>nginx将请求代理到OpenResty集群<img src="/2022/07/15/springcloud-xue-xi-bi-ji/068.png" class=""></li></ol><h4 id="1-添加OpenResty对Lua模块的加载"><a href="#1-添加OpenResty对Lua模块的加载" class="headerlink" title="1. 添加OpenResty对Lua模块的加载"></a>1. 添加OpenResty对Lua模块的加载</h4><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在其中的http下面，添加下面代码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#lua 模块</span></span><br><span class="line"><span class="attribute">lua_package_path</span> <span class="string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;</span><br><span class="line"><span class="comment">#c模块     </span></span><br><span class="line"><span class="attribute">lua_package_cpath</span> <span class="string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;  </span><br></pre></td></tr></table></figure><h4 id="2-监听路径，配置响应文件"><a href="#2-监听路径，配置响应文件" class="headerlink" title="2. 监听路径，配置响应文件"></a>2. 监听路径，配置响应文件</h4><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在nginx.conf的server下面，添加对/api/item这个路径的监听：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span>  /api/item &#123;</span><br><span class="line">    <span class="comment"># 默认的响应类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="comment"># 响应结果由lua/item.lua文件来决定</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于SpringMVC中的<code>@GetMapping(&quot;/api/item&quot;)</code>路径映射。而<code>content_by_lua_file lua/item.lua</code>则相当于调用item.lua这个文件，执行其中的业务，把结果返回给用户，相当于java中调用service。</p><h4 id="3-编写Lua文件"><a href="#3-编写Lua文件" class="headerlink" title="3. 编写Lua文件"></a>3. 编写Lua文件</h4><ol><li>在<code>/usr/loca/openresty/nginx</code>目录创建文件夹<code>lua</code>并在目录<code>lua</code>下新建<code>item.lua</code>文件</li><li>在<code>item.lua</code>中编写业务逻辑<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:10001,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:17900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>PS：这里返回的是假数据</li><li>重新加载配置<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h4></li><li>获取请求参数API<br>OpenResty中提供了一些API用来获取不同类型的前端请求参数：<img src="/2022/07/15/springcloud-xue-xi-bi-ji/069.png" class=""></li><li>获取请求参数<br>eg：获取 <a class="link"   href="http://localhost/api/item/1001" >http://localhost/api/item/1001<i class="fas fa-external-link-alt"></i></a> 的<code>id</code>=1001<br>参数以路径占位符方式传递的，则利用正则表达式匹配的方式来获取。<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ /api/item/(\d+)</span> &#123;</span><br><span class="line">    <span class="comment"># 默认的响应类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="comment"># 响应结果由lua/item.lua文件来决定</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>修改<code>lua</code>文件获取id并拼接到结果中返回：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 获取商品<span class="attribute">id</span></span><br><span class="line">local id = ngx.var[<span class="number">1</span>]</span><br><span class="line">-- 拼接并返回</span><br><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:&#x27;</span> .. id .. <span class="string">&#x27;,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:17900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="查询Tomcat"><a href="#查询Tomcat" class="headerlink" title="查询Tomcat"></a>查询Tomcat</h4><p>此时环境是OpenResty是在虚拟机，Tomcat是在Windows。</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/070.png" class=""><p>关于OpenResty和Tomcat之间的访问问题有以下参考：</p><ul><li>教程视频中使用的是虚拟机，虚拟机ip和主机ip有对应关系（虎哥说的），关闭防火墙，即可完成连接</li><li>弹幕说，用云服务的阿里云服务器的话，把课件中的项目放到阿里云运行，然后配置nginx代理地址之间转发到阿里云的地址即可</li><li>弹幕说，用云服务器的话可以搜一下如何配置内网穿透</li><li>弹幕说，服务器的话用公网ip就可以</li></ul><p><strong>发送请求API</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">local</span> resp = ngx.location.capture(<span class="string">&quot;/path&quot;</span>,&#123;</span><br><span class="line">    <span class="attribute">method</span> = ngx.HTTP_GET,   -- 请求方式</span><br><span class="line">    args = &#123;a=1,b=2&#125;,  -- get方式传参数</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回的响应内容包括：</p><ul><li>resp.status：响应状态码</li><li>resp.header：响应头，是一个table</li><li>resp.body：响应体，就是响应数据</li></ul><p>这里的path是路径，并不包含IP和端口，这个请求会被nginx内部的server监听并处理。我们希望这个请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /path &#123;</span><br><span class="line">    <span class="comment"># 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.150.1:8081; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="封装http工具"><a href="#封装http工具" class="headerlink" title="封装http工具"></a>封装http工具</h4><p>封装一个发送Http请求的工具，基于ngx.location.capture来实现查询tomcat</p><ol><li>添加反向代理，到windows的Java服务。</li></ol><p>因为item-service中接口都是/item开头，所以监听/item路径代理到windows上的tomcat服务，添加一个location：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.150.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后调用<code>ngx.location.capture(&quot;/item&quot;)</code>，就会发送请求到windows的tomcat服务。</p><ol start="2"><li>封装工具类</li></ol><p>OpenResty启动时会加载以下两个目录中的工具文件：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/072.png" class=""><p>所以，自定义的http工具也需要放到这个目录下，新建common.lua文件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http请求查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure><p>这个工具将read_http函数封装到_M这个table类型的变量中，并且返回，这类似于导出。使用的时候，可以利用<code>require(&#39;common&#39;)</code>来导入该函数库，这里的common是函数库的文件名。</p><ol start="3"><li>实现商品查询</li></ol><p>修改<code>/usr/local/openresty/lua/item.lua</code>文件，利用刚刚封装的函数库实现对tomcat的查询：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 引入自定义common工具模块，返回值是common中返回的 _M</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&quot;common&quot;</span>)</span><br><span class="line"><span class="comment">-- 从 common中获取read_http这个函数</span></span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_http(<span class="string">&quot;/item/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> itemStockJSON = read_http(<span class="string">&quot;/item/stock/&quot;</span>.. id, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h3 id="序列化、反序列化"><a href="#序列化、反序列化" class="headerlink" title="序列化、反序列化"></a>序列化、反序列化</h3><p>OpenResty提供cjson模块用来处理JSON的序列化和反序列化，官方地址： <a class="link"   href="https://github.com/openresty/lua-cjson/" >https://github.com/openresty/lua-cjson/<i class="fas fa-external-link-alt"></i></a></p><ol><li>引入cjson模块</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">&quot;cjson&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>序列化</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = &#123;</span><br><span class="line">    name = <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age = <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 把 table 序列化为 json</span></span><br><span class="line"><span class="keyword">local</span> json = cjson.encode(obj)</span><br></pre></td></tr></table></figure><ol start="3"><li>反序列化</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> json = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 21&#125;&#x27;</span></span><br><span class="line"><span class="comment">-- 反序列化 json为 table</span></span><br><span class="line"><span class="keyword">local</span> obj = cjson.decode(json);</span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure><p>修改之前的item.lua中的业务，添加json处理功能：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_http(<span class="string">&quot;/item/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> itemStockJSON = read_http(<span class="string">&quot;/item/stock/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure><h3 id="基于ID负载均衡"><a href="#基于ID负载均衡" class="headerlink" title="基于ID负载均衡"></a>基于ID负载均衡</h3><p>以上示例代码中，tomcat均是单机部署。而实际开发中，tomcat一定是集群模式，因此OpenResty需要对tomcat集群做负载均衡。</p><p>默认的负载均衡规则是轮询模式，当查询/item/10001时：</p><ul><li>第一次会访问8081端口的tomcat服务，在该服务内部就形成了JVM进程缓存</li><li>第二次会访问8082端口的tomcat服务，该服务内部没有JVM缓存（因为JVM缓存无法共享），会查询数据库</li><li>…</li></ul><p>因为轮询，第一次查询8081形成的JVM缓存并未生效，直到下一次再次访问到8081时才可以生效，显得JVM进程缓存并没有多大意义，这种负载均衡的效率很低。</p><p><strong>Hash负载均衡</strong><br>nginx提供了基于请求路径做负载均衡的算法，根据请求路径做hash运算根据运算结果决定访问哪个服务，实现负载均衡。<br>只要id不变，每次hash运算结果也不会变，那就可以保证同一个商品，一直访问同一个tomcat服务，确保JVM缓存生效。</p><ol><li>配置Tomcat集群</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcat-cluster &#123;</span><br><span class="line">    <span class="attribute">hash</span> $request_uri;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.150.1:8081</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.150.1:8082</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改对tomcat服务的反向代理，目标指向tomcat集群：</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tomcat-cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>重新加载OpenResty</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nginx</span> -s reload</span><br></pre></td></tr></table></figure><h2 id="Redis缓存预热"><a href="#Redis缓存预热" class="headerlink" title="Redis缓存预热"></a>Redis缓存预热</h2><p>Redis缓存会面临冷启动问题：<br><strong>冷启动</strong>：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。<br><strong>缓存预热</strong>：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。</p><ol><li>安装Redis</li><li>微服务引入Redis依赖</li><li>配置Redis</li><li>编写初始化类</li></ol><p>缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。利用InitializingBean接口来实现，因为InitializingBean可以在对象被Spring创建并且成员变量全部注入后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisHandler</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            String json = MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            String json = MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OpenResty查询Redis"><a href="#OpenResty查询Redis" class="headerlink" title="OpenResty查询Redis"></a>OpenResty查询Redis</h3><p>当请求进入OpenResty之后：</p><ul><li>优先查询Redis缓存</li><li>如果Redis缓存未命中，再查询Tomcat</li></ul><h3 id="封装Redis工具"><a href="#封装Redis工具" class="headerlink" title="封装Redis工具"></a>封装Redis工具</h3><p>OpenResty提供了操作Redis的模块，引入该模块就使用。但是为了方便，我们将Redis操作封装到之前的common.lua工具库中。<br>修改上文中的<code>/usr/local/openresty/lualib/common.lua</code>文件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入redis</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;resty.redis&#x27;</span>)</span><br><span class="line"><span class="comment">-- 初始化redis</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">    <span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询redis</span></span><br><span class="line">    <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">    <span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--得到的数据为空处理</span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">        resp = <span class="literal">nil</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    close_redis(red)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http,</span><br><span class="line">    read_redis = read_redis</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure><h4 id="实现Redis查询"><a href="#实现Redis查询" class="headerlink" title="实现Redis查询"></a>实现Redis查询</h4><p>eg：</p><ul><li>根据id查询Redis</li><li>如果查询失败则继续查询Tomcat</li><li>将查询结果返回</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">    <span class="comment">-- 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">        val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure><h2 id="Nginx本地缓存"><a href="#Nginx本地缓存" class="headerlink" title="Nginx本地缓存"></a>Nginx本地缓存</h2><p>OpenResty为Nginx提供了<strong>shard dict</strong>的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。</p><ol><li>开启共享字典，在nginx.conf的http下添加配置</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span></span><br><span class="line"><span class="attribute">lua_shared_dict</span> item_cache <span class="number">150m</span>; </span><br></pre></td></tr></table></figure><ol start="2"><li>操作共享词典</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 获取本地缓存对象</span><br><span class="line"><span class="attribute">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line">-- 存储, 指定key、value、过期时间，单位s，默认为<span class="number">0</span>代表永不过期</span><br><span class="line">item_cache:set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line">-- 读取</span><br><span class="line">local val = item_cache:get(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>本地缓存查询</li></ol><p>修改<code>/usr/local/openresty/lua/item.lua</code>文件:</p><ul><li>修改read_data查询函数，添加本地缓存逻辑</li><li>修改item.lua中查询商品和库存的业务，实现最新的read_data函数<ul><li>多了缓存时间参数，过期后nginx缓存会自动删除，下次访问即可更新缓存。<br>品基本信息设置超时时间为30分钟，库存为1分钟。</li></ul></li></ul><p>因为库存更新频率较高，如果缓存时间过长，可能与数据库差异较大。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id, <span class="number">1800</span>,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="number">60</span>, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure><h2 id="缓存同步"><a href="#缓存同步" class="headerlink" title="缓存同步"></a>缓存同步</h2><p>缓存同步策略：<br><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p><ul><li>优势：简单、方便</li><li>缺点：时效性差，缓存过期之前可能不一致</li><li>场景：更新频率较低，时效性要求低的业务</li></ul><p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p><ul><li>优势：时效性强，缓存与数据库强一致</li><li>缺点：有代码侵入，耦合度高；</li><li>场景：对一致性、时效性要求较高的缓存数据</li></ul><p><strong>异步通知：</strong>修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p><ul><li>优势：低耦合，可以同时通知多个缓存服务</li><li>缺点：时效性一般，可能存在中间不一致状态</li><li>场景：时效性要求一般，有多个服务需要同步</li></ul><p>异步实现可以基于MQ或者Canal：</p><ul><li>基于MQ的异步通知<img src="/2022/07/15/springcloud-xue-xi-bi-ji/073.png" class=""></li><li>商品服务完成对数据的修改后，只需要发送一条消息到MQ中。</li><li>缓存服务监听MQ消息，然后完成对缓存的更新</li></ul><p>依然有少量的代码侵入。</p><ul><li>基于Canal的通知<img src="/2022/07/15/springcloud-xue-xi-bi-ji/074.png" class=""></li><li>商品服务完成商品修改后，业务直接结束，没有任何代码侵入</li><li>Canal监听MySQL变化，当发现变化后，立即通知缓存服务</li><li>缓存服务接收到canal通知，更新缓存</li></ul><p>代码零侵入</p><h3 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h3><p>Canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。GitHub的地址：<a class="link"   href="https://github.com/alibaba/canal" >https://github.com/alibaba/canal<i class="fas fa-external-link-alt"></i></a></p><p>Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：</p><img src="/2022/07/15/springcloud-xue-xi-bi-ji/075.png" class=""><ul><li>MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events</li><li>MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)</li><li>MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li></ul><p>Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。</p><h4 id="安装配置Canal"><a href="#安装配置Canal" class="headerlink" title="安装配置Canal"></a>安装配置Canal</h4><p>Canal是基于MySQL的主从同步功能，因此必须先开启MySQL的主从功能</p><ol><li>开启binlog</li></ol><p>打开mysql容器挂载的日志文件，添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log-bin</span>=/var/lib/mysql/mysql-bin</span><br><span class="line"><span class="attr">binlog-do-db</span>=heima</span><br></pre></td></tr></table></figure><ul><li><code>log-bin=/var/lib/mysql/mysql-bin</code>：设置binary log文件的存放地址和文件名，叫做mysql-bin</li><li><code>binlog-do-db=heima</code>：指定对哪个database记录binary log events，这里记录heima这个库</li></ul><p>最终效果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="attr">character_set_server</span>=utf8</span><br><span class="line"><span class="attr">datadir</span>=/var/lib/mysql</span><br><span class="line"><span class="attr">server-id</span>=<span class="number">1000</span></span><br><span class="line"><span class="attr">log-bin</span>=/var/lib/mysql/mysql-bin</span><br><span class="line"><span class="attr">binlog-do-db</span>=heima</span><br></pre></td></tr></table></figure><ol start="2"><li>设置用户权限</li></ol><p>添加一个仅用于数据同步的账户，出于安全考虑，这里仅提供对heima这个库的操作权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> canal@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">by</span> <span class="string">&#x27;canal&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, REPLICATION SLAVE, REPLICATION CLIENT,SUPER <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;canal&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>重启Mysql</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure><p>安装过程略。<br>安装好之后，运行容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 11111:11111 --name canal \</span><br><span class="line">-e canal.destinations=heima \</span><br><span class="line">-e canal.instance.master.address=mysql:3306  \</span><br><span class="line">-e canal.instance.dbUsername=canal  \</span><br><span class="line">-e canal.instance.dbPassword=canal  \</span><br><span class="line">-e canal.instance.connectionCharset=UTF-8 \</span><br><span class="line">-e canal.instance.tsdb.enable=<span class="literal">true</span> \</span><br><span class="line">-e canal.instance.gtidon=<span class="literal">false</span>  \</span><br><span class="line">-e canal.instance.filter.regex=heima\\..* \</span><br><span class="line">--network heima \</span><br><span class="line">-d canal/canal-server:v1.1.5</span><br></pre></td></tr></table></figure><ul><li><code>-p 11111:11111</code>：这是canal的默认监听端口</li><li><code>-e canal.instance.master.address=mysql:3306</code>：数据库地址和端口，如果不知道mysql容器地址，可以通过<code>docker inspect 容器id</code>来查看</li><li><code>-e canal.instance.dbUsername=canal</code>：数据库用户名</li><li><code>-e canal.instance.dbPassword=canal</code> ：数据库密码</li><li><code>-e canal.instance.filter.regex=</code>：要监听的表名称</li></ul><p>表名称监听支持的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql 数据解析关注的表，Perl正则表达式.</span><br><span class="line">多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\) </span><br><span class="line">常见例子：</span><br><span class="line">1.  所有表：.*   or  .*\\..*</span><br><span class="line">2.  canal schema下所有表： canal\\..*</span><br><span class="line">3.  canal下的以canal打头的表：canal\\.canal.*</span><br><span class="line">4.  canal schema下的一张表：canal.test1</span><br><span class="line">5.  多个规则组合使用然后以逗号隔开：canal\\..*,mysql.test1,mysql.test2 </span><br></pre></td></tr></table></figure><h4 id="监听Canal"><a href="#监听Canal" class="headerlink" title="监听Canal"></a>监听Canal</h4><p>当Canal监听到binlog变化时，会通知Canal的客户端。用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p><p>这里我们会使用GitHub上的第三方开源的canal-starter客户端，<a class="link"   href="https://github.com/NormanGyllenhaal/canal-client" >https://github.com/NormanGyllenhaal/canal-client<i class="fas fa-external-link-alt"></i></a> 与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。</p><ol><li>引入依赖</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;top.javatool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;canal-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.1-RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">heima</span> <span class="comment"># canal的集群名字，要与安装canal时设置的名称一致</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:11111</span> <span class="comment"># canal服务地址</span></span><br></pre></td></tr></table></figure><ol start="3"><li>修改实体类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Transient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//商品id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//商品标题</span></span><br><span class="line">    <span class="keyword">private</span> Long price;<span class="comment">//价格（分）</span></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//商品图片</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">//分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String brand;<span class="comment">//品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String spec;<span class="comment">//规格</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;<span class="comment">//商品状态 1-正常，2-下架</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;<span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;<span class="comment">//更新时间</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer sold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>编写监听器</li></ol><p>通过实现<code>EntryHandler&lt;T&gt;</code>接口编写监听器，监听Canal消息。注意两点：</p><ul><li>实现类通过<code>@CanalTable(&quot;tb_item&quot;)</code>指定监听的表信息</li><li>EntryHandler的泛型是与表对应的实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.config.RedisHandler;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CanalTable(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemHandler</span> <span class="keyword">implements</span> <span class="title">EntryHandler</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisHandler redisHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(item.getId(), item);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Item before, Item after)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(after.getId(), after);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(after);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除数据到JVM进程缓存</span></span><br><span class="line">        itemCache.invalidate(item.getId());</span><br><span class="line">        <span class="comment">// 删除数据到redis</span></span><br><span class="line">        redisHandler.deleteItemById(item.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里对Redis的操作都封装到了RedisHandler这个对象中，是我们之前做缓存预热时编写的一个类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisHandler</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            String json = MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            String json = MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveItem</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String json = MAPPER.writeValueAsString(item);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteItemById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;item:id:&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="SpringClound" scheme="https://up-bear.github.io/tags/SpringClound/"/>
    
  </entry>
  
  <entry>
    <title>nginx初试</title>
    <link href="https://up-bear.github.io/2022/04/06/nginx-chu-shi/"/>
    <id>https://up-bear.github.io/2022/04/06/nginx-chu-shi/</id>
    <published>2022-04-06T12:35:52.000Z</published>
    <updated>2022-04-07T13:08:57.722Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Linux安装nginx，安装路径为 /usr/local/nginx 。启动及其他命令须在 sbin 目录下进行。<br>常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动nginx./nginx</span><br><span class="line">停止nginx./nginx-s stop</span><br><span class="line">重新加载nginx  ./nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>概念：客户端发送的请求经过中间件，然后派发到不同服务器的过程即为反向代理。<br>正向代理代理的是客户端，特点是用户明确知道实际访问的服务器。<br>反向代理代理的是服务器，特点是用户不知道实际要访问的服务器，服务器对用户来说是隐藏的，用户知道的是中间件。</p><h4 id="反向代理单个节点"><a href="#反向代理单个节点" class="headerlink" title="反向代理单个节点"></a>反向代理单个节点</h4><p>nginx.con配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen&quot;访问端口&quot;;</span><br><span class="line">server_name:&quot;访问ip&quot;;</span><br><span class="line">location / &#123;</span><br><span class="line">roothtml;</span><br><span class="line">indexindex.html index.html;</span><br><span class="line">proxy_name&quot;被代理的服务器ip:port&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反向代理两个节点"><a href="#反向代理两个节点" class="headerlink" title="反向代理两个节点"></a>反向代理两个节点</h4><p>nginx.conf配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen&quot;访问端口&quot;;</span><br><span class="line">server&quot;访问ip&quot;;</span><br><span class="line"></span><br><span class="line">location ~ /edu/ &#123;</span><br><span class="line">proxy_passhttp://op:port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /vod/ &#123;</span><br><span class="line">proxy_passhttp://ip:port;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/edu/ 是正则表达式，nginx会根据客户端的访问路径，将请求派发到与正则表达式匹配的服务器。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>概念：将请求派发到不同服务器上，减轻服务器的负担，提高系统的可用性和可靠性。</p><h4 id="默认轮询"><a href="#默认轮询" class="headerlink" title="默认轮询"></a>默认轮询</h4><p>nginx.conf配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">upstream myServer&#123;</span><br><span class="line">serverip:port;</span><br><span class="line">serverip:port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listenport;</span><br><span class="line">server_nameip;</span><br><span class="line">    </span><br><span class="line">    location&#123;</span><br><span class="line">    proxy_passhttp://myServer;</span><br><span class="line">    </span><br><span class="line">    roothtml;</span><br><span class="line">    indexindex.htmlindex.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分配权重"><a href="#分配权重" class="headerlink" title="分配权重"></a>分配权重</h4><p>nginx.conf配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">upstream myServer&#123;</span><br><span class="line">serverip:portweight=10;</span><br><span class="line">serverip:portweight=5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listenport;</span><br><span class="line">server_nameip;</span><br><span class="line">    </span><br><span class="line">    location&#123;</span><br><span class="line">    proxy_passhttp://myServer;</span><br><span class="line">    </span><br><span class="line">    roothtml;</span><br><span class="line">    indexindex.htmlindex.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>weight的值越大，请求被派发到该服务器的几率越大。</p><h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>nginx.conf配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream myServer&#123;</span><br><span class="line">ip_hash;</span><br><span class="line">serverip:port;</span><br><span class="line">serverip:port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listenport;</span><br><span class="line">server_nameip;</span><br><span class="line">    </span><br><span class="line">    location&#123;</span><br><span class="line">    proxy_passhttp://myServer;</span><br><span class="line">    </span><br><span class="line">    roothtml;</span><br><span class="line">    indexindex.htmlindex.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx根据客户端的ip的hash值进行派发请求，此方法可以解决session问题。</p><h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p>nginx.conf配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream myServer&#123;</span><br><span class="line">fair;</span><br><span class="line">serverip:port;</span><br><span class="line">serverip:port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listenport;</span><br><span class="line">server_nameip;</span><br><span class="line">    </span><br><span class="line">    location&#123;</span><br><span class="line">    proxy_passhttp://myServer;</span><br><span class="line">    </span><br><span class="line">    roothtml;</span><br><span class="line">    indexindex.htmlindex.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx根据服务器的响应时间来分配请求，响应时间越短越优先分配。</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>看尚硅谷的nginx视频，感觉这部分讲的不是很好，和一般的反向代理差不多，但还是记录一下。<br>本次测试是把静态资源放在nginx所在的主机下，在/myData/img 和 /myData/html 目录下放置静态资源。<br>nginx.conf配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listenport;</span><br><span class="line">server_nameip;</span><br><span class="line">    </span><br><span class="line">    location&#123;</span><br><span class="line">    proxy_passhttp://myServer;</span><br><span class="line">    </span><br><span class="line">    roothtml;</span><br><span class="line">    indexindex.htmlindex.html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #添加规则</span><br><span class="line">    location /html/ &#123;</span><br><span class="line">        root    /myData/;</span><br><span class="line">    &#125;</span><br><span class="line">    location /img/ &#123;</span><br><span class="line"> root    /myData/;</span><br><span class="line"> #访问/img/会把该目录下的资源列出来</span><br><span class="line">autoindex       on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="nginx" scheme="https://up-bear.github.io/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>问题踩坑汇总</title>
    <link href="https://up-bear.github.io/2022/03/17/wen-ti-cai-keng-hui-zong/"/>
    <id>https://up-bear.github.io/2022/03/17/wen-ti-cai-keng-hui-zong/</id>
    <published>2022-03-17T06:47:51.000Z</published>
    <updated>2023-03-13T15:26:41.054Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="请路径参数获取问题"><a href="#请路径参数获取问题" class="headerlink" title="请路径参数获取问题"></a>请路径参数获取问题</h2><p>使用ajax发送请求，在请求路径中拼接了一个参数 calledName ，在后台 controller 方法中使用 request.getAttribute(“calledName”) 获取 calledName ，结果为 null 。换一种方法使用 @RequestParam 注解却能获取到 calledName 的值。<br>原因尚未知，在以后的开发中尽量使用 @RequestParam 注解获取参数值。<br>请求路径中拼接参数的方式，GET 和 POST 都可以使用。</p><h2 id="ajax回调函数的返回数据data"><a href="#ajax回调函数的返回数据data" class="headerlink" title="ajax回调函数的返回数据data"></a>ajax回调函数的返回数据data</h2><p>使用 $.ajax() 方式发送 ajax 请求，其中 datatype 的值设为 json，发现最终回调函数不能正常使用，将 datatype 这一参数设置不写，（后台 controller 方法注解是有 @RequestBody 的），回调函数能够正常使用。</p><h2 id="集合遍历中修改"><a href="#集合遍历中修改" class="headerlink" title="集合遍历中修改"></a>集合遍历中修改</h2><p><strong>方式一： for(int i = 0; i &lt; length; i++)</strong><br>如果能够使用这该方式遍历集合，则可以在遍历中修改</p><p><strong>方式二：增强 for 循环，for(Integer i : list)</strong><br>如果使用该方式遍历，则不可以在遍历中修改！！！<br>原因：在迭代器的底层源码中，使用该方式会产生下标索引不一致的问题，会报错。</p><p><strong>方式三：使用迭代器，Iterator</strong><br>可以使用迭代器方式遍历集合，遍历中可以删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator it = set.iterator();it.hasNext();)&#123;</span><br><span class="line">Object obj = it.next();</span><br><span class="line">it.remove();<span class="comment">//删除迭代出来的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="char-比较是否相等"><a href="#char-比较是否相等" class="headerlink" title="char[] 比较是否相等"></a>char[] 比较是否相等</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] c1 = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>[] c2 = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">//输出为 false</span></span><br><span class="line">Arrays.equals(c1, c2); <span class="comment">//输出为 true</span></span><br></pre></td></tr></table></figure><p>不能使用 <strong>c1.equals(c2)<strong>，可以借助</strong>Arrays.equals()方法</strong></p><h2 id="复制数组的一部分"><a href="#复制数组的一部分" class="headerlink" title="复制数组的一部分"></a>复制数组的一部分</h2><p>可以借助工具类<strong>Arrays</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.copyOfRange(is, from, to); <span class="comment">//不包含to</span></span><br></pre></td></tr></table></figure><h2 id="拼接String集合"><a href="#拼接String集合" class="headerlink" title="拼接String集合"></a>拼接String集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">String res = String.join(<span class="string">&quot; &quot;</span>, track);<span class="comment">//将track中的字符串以“ ”连接</span></span><br></pre></td></tr></table></figure><h1 id="Maven-pom爆红"><a href="#Maven-pom爆红" class="headerlink" title="Maven pom爆红"></a>Maven pom爆红</h1><h2 id="1-1-maven坐标正确"><a href="#1-1-maven坐标正确" class="headerlink" title="1.1 maven坐标正确"></a>1.1 maven坐标正确</h2><p>这种情况可能是maven或IDEA自身的问题，这里给出一种解决方案。</p><ol><li>首先到maven中央仓库手动下载所需要的jar包</li><li>将下载的jar包导入到maven本地仓库<br>在jar包所在目录下打开cmd控制台，执行：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=jar包名称（带后缀） -DgroupId=jar包groupId -DartifactId=jar包artifactId -Dversion=jar包版本号 -Dpackaging=jar</span><br></pre></td></tr></table></figure><ol start="3"><li>修改IDEA maven设置<img src="/2022/03/17/wen-ti-cai-keng-hui-zong/001.jpg" class="">勾选圈出的选项，确定。之后重启IDEA，pom文件不再爆红。</li></ol><h1 id="参考帖子"><a href="#参考帖子" class="headerlink" title="参考帖子"></a>参考帖子</h1><ol><li><a class="link"   href="https://www.cnblogs.com/think-world/p/12229763.html" >https://www.cnblogs.com/think-world/p/12229763.html<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/qq_43242707/article/details/115277308" >https://blog.csdn.net/qq_43242707/article/details/115277308<i class="fas fa-external-link-alt"></i></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记</title>
    <link href="https://up-bear.github.io/2022/03/10/java-xue-xi-bi-ji/"/>
    <id>https://up-bear.github.io/2022/03/10/java-xue-xi-bi-ji/</id>
    <published>2022-03-10T11:29:24.000Z</published>
    <updated>2023-03-13T15:25:40.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>实体类的属性名称不能和数据库的保留字相同，否则会导致数据表创建错误。<br>Mysql保留字有：<br>    call</p><h1 id="反射与注解"><a href="#反射与注解" class="headerlink" title="反射与注解"></a>反射与注解</h1><h3 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h3><p>作用：注释和解释（狂神说的，很喜欢，简洁）。被人用来注释代码，并交给JVM去解释执行。</p><p>定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@interface MyAnnotation&#123;</span><br><span class="line">    public String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就简单自定义了一个注解。在定义注解的时候可以使用其他注解。</p><p>元注解：用来注解注解的注解。<br>四个元注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Target 确定注解可以使用的地方，如类、接口、方法等</span><br><span class="line">@Retention 可以理解为注解的&quot;生命周期&quot;</span><br><span class="line">@Documented 此注解会被javadoc工具提取成文档</span><br><span class="line">@Inherited 允许子类继承父类中的注解</span><br></pre></td></tr></table></figure><h3 id="反射Reflection"><a href="#反射Reflection" class="headerlink" title="反射Reflection"></a>反射Reflection</h3><p>个人理解：通过Class类去操纵对象的过程就称为反射。<br>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h1><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>描述：一个类中，同一个方法名，有用多个参数类型或数量不同的方法实现，则称之为方法重载。<br>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">public void methodA()&#123;&#125;;</span><br><span class="line">public void methodA(int a)&#123;&#125;;</span><br><span class="line">    public void methodA(String str)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类B继承了类A，B拥有A的所有方法（构造方法除外）和属性。类B可以对父类A的方法进行重写，还可以声明父类A没有的属性。<br>构造方法：当父类有多个构造方法时，子类必须声明一个参数列表（可以是无参类型）和父类相同的构造方法，并在方法体的第一行调用父类的其中一个构造方法。<br>注意，当父类只有默认无参构造方法时，子类的默认无参构造方法中默认调用了父类的无参构造方法。<br>当以一个类声明了构造方法，默认的无参构造方法便不存在了。<br>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">示例一：</span><br><span class="line">public class Father &#123;</span><br><span class="line">    public Father()&#123;</span><br><span class="line">        System.out.println(&quot;Father&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Father(String name, String age)&#123;</span><br><span class="line">        System.out.println(name + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line"></span><br><span class="line">    public Son(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">示例二：</span><br><span class="line">public class Father &#123;</span><br><span class="line">    public Father()&#123;</span><br><span class="line">        System.out.println(&quot;Father&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Father(String name, String age)&#123;</span><br><span class="line">        System.out.println(name + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">//有默认的无参构造器，而且会默认调用父类的无参构造器</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">new Son();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：Father</span><br><span class="line"></span><br><span class="line">示例三：</span><br><span class="line">public class Father &#123;</span><br><span class="line">    public Father(String name)&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Father(String name, String age)&#123;</span><br><span class="line">        System.out.println(name + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">public Son(String name)&#123;</span><br><span class="line">super(name + &quot;age&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>描述：子类继承父类，并对继承的父类方法进行重新实现的过程，称之为方法重写。</p><p>代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Father&#123;</span><br><span class="line">public String method1()&#123;</span><br><span class="line">return &quot;father&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Son extends Father&#123;</span><br><span class="line">public String method1()&#123;</span><br><span class="line">return &quot;son&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向上转型与向下转型"><a href="#向上转型与向下转型" class="headerlink" title="向上转型与向下转型"></a>向上转型与向下转型</h3><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p>描述：把子类的对象实例赋值给父类的引用。<br>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Father&#123;</span><br><span class="line">public void method1()&#123;</span><br><span class="line">System.out.println(&quot;father&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B extends Father&#123;</span><br><span class="line">public void method1()&#123;</span><br><span class="line">System.out.println(&quot;son&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Father f = new Son();//向上转型,将子类实例赋值给父类引用。可以理解为把子类对象向上转换成父类对象。 </span><br><span class="line">f.method1();//输出结果为&quot;son&quot;,而不是&quot;father&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过向上转型的获得的对象引用，在调用方法时，只能调用父类中已有的方法，但执行的方法体是子类的方法。</p><p>易混淆情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Father&#123;</span><br><span class="line">public void method1()&#123;</span><br><span class="line">System.out.println(&quot;father&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void method2()&#123;</span><br><span class="line">System.out.println(&quot;father.method2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B extends Father&#123;</span><br><span class="line">public void method1()&#123;</span><br><span class="line">System.out.println(&quot;son&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Father f = new Son();//向上转型,将子类实例赋值给父类引用。可以理解为把子类对象向上转换成父类对象。 </span><br><span class="line">f.method2();//输出结果为&quot;father.method2&quot;,method2()方法没有被子类B重写，是从父类A中继承过来的，也是类B的方法不要理解为method2不是B的方法。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line">    public String method1()&#123;</span><br><span class="line">        return &quot;father&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    public String method1()&#123;</span><br><span class="line">        return &quot;son&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String method2()&#123;</span><br><span class="line">        return &quot;Son.method2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Father f = new Son();</span><br><span class="line">        //System.out.println(f.method2());该行会提示报错，因为f此时是Father类型，没有method2()方法</span><br><span class="line">        System.out.println(((Son)f).method2());//此时再使用向下转型，便不会报错。输出结果为&quot;Son.method2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向上转型经典例题"><a href="#向上转型经典例题" class="headerlink" title="向上转型经典例题"></a>向上转型经典例题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public String show(D obj) &#123;</span><br><span class="line">        return (&quot;A and D&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String show(A obj) &#123;</span><br><span class="line">        return (&quot;A and A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public String show(B obj)&#123;</span><br><span class="line">        return (&quot;B and B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String show(A obj)&#123;</span><br><span class="line">        return (&quot;B and A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D extends B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a1 = new A();</span><br><span class="line">        A a2 = new B();</span><br><span class="line">        B b = new B();</span><br><span class="line">        C c = new C();</span><br><span class="line">        D d = new D();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;1--&quot; + a1.show(b));</span><br><span class="line">        System.out.println(&quot;2--&quot; + a1.show(c));</span><br><span class="line">        System.out.println(&quot;3--&quot; + a1.show(d));</span><br><span class="line">        System.out.println(&quot;4--&quot; + a2.show(b));</span><br><span class="line">        System.out.println(&quot;5--&quot; + a2.show(c));</span><br><span class="line">        System.out.println(&quot;6--&quot; + a2.show(d));</span><br><span class="line">        System.out.println(&quot;7--&quot; + b.show(b));</span><br><span class="line">        System.out.println(&quot;8--&quot; + b.show(c));</span><br><span class="line">        System.out.println(&quot;9--&quot; + b.show(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//结果：</span><br><span class="line">//1--A and A</span><br><span class="line">//2--A and A</span><br><span class="line">//3--A and D</span><br><span class="line">//4--B and A</span><br><span class="line">//5--B and A</span><br><span class="line">//6--A and D</span><br><span class="line">//7--B and B</span><br><span class="line">//8--B and B</span><br><span class="line">//9--A and D</span><br><span class="line"></span><br><span class="line">//能看懂这个结果么？先自分析一下。</span><br></pre></td></tr></table></figure><p>这个例子是非常复杂的啦，要想完全理解后面几个输出结果还要知道一条重要知识：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</span><br><span class="line">(其实按照我前面的理解，感觉这一条原则不要也行，因为子类没有重写的方法是默认继承自父类的，验证了一下例题也没问题)</span><br></pre></td></tr></table></figure><p>对于输出4，a2.show(b))的输出结果是”B and A”。对象a2是A类型，但是指向B类型实例，为向上转型。a2可执行的方法名为类A中的方法，public String show(D obj)和public String show(A obj)；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">继承链第一步：this.show(O)显然不行，因为对象b是B类型，可执行方法中没有符合要求的。</span><br><span class="line">继承链第二步：super.show(O)，显然没有符合要求的。</span><br><span class="line">继承链第三步：this.show((super)O)，即shou((A) b)，执行类B中的方法show(A obj)，输出&quot;B and A&quot;</span><br></pre></td></tr></table></figure><p>对于输出5，分析同输出4，略。<br>对于输出6，a2.show(d))的输出结果为”A and D”，也很好理解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">继承链第一步：this.show(O)显然可以，因为类B继承了类A的public String show(D obj)方法，</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://blog.csdn.net/qq_31655965/article/details/54746235" >参考博文<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="mysql" scheme="https://up-bear.github.io/categories/mysql/"/>
    
    <category term="Java" scheme="https://up-bear.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot源码笔记</title>
    <link href="https://up-bear.github.io/2022/01/19/springboot-yuan-ma-bi-ji/"/>
    <id>https://up-bear.github.io/2022/01/19/springboot-yuan-ma-bi-ji/</id>
    <published>2022-01-19T08:16:08.000Z</published>
    <updated>2022-02-11T15:06:18.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><h4 id="默认路径"><a href="#默认路径" class="headerlink" title="默认路径"></a>默认路径</h4><p>项目资源文件夹resources下：/META-INF/resources/、/resources/、/static/、/public/ 共四个路径。即使是使用了thymeleaf模板的情况下，放在以上路径下的静态资源仍然可以被访问，而且在这些路径下的html页面中使用thymeleaf语法同样有效。（thymeleaf似乎值对拦截再templates路径下的资源访问进行拦截设置）<br>源码探究：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web;</span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.web&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebProperties</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,<span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义资源路径"><a href="#自定义资源路径" class="headerlink" title="自定义资源路径"></a>自定义资源路径</h5><p>注解@ConfigurationProperties(“spring.web”)，WebProperties类下的属性和配置文件进行了绑定，在配置文件application.properties中即可自定义静态资源访问路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##由于CLASSPATH_RESOURCE_LOCATIONS被final修饰，所以不能修改</span><br><span class="line">##类属性和配置文件的对应规则：spring.web为注解设置前缀，resource对应内部类Resources的类名，static-locations对应类属性staticLocations</span><br><span class="line">spring.web.resources.static-locations = 自定义资源路径</span><br></pre></td></tr></table></figure><p>源码探究：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web;</span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.web&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebProperties</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,<span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="资源访问前缀"><a href="#资源访问前缀" class="headerlink" title="资源访问前缀"></a>资源访问前缀</h4><p>默认访问前缀：/<br>源码探究：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcProperties</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Path of the dispatcher servlet. Setting a custom value for this property is not</span></span><br><span class="line"><span class="comment"> * compatible with the PathPatternParser matching strategy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String path = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义访问前缀：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.web.servlet.path = 自定义前缀（注意要“/”结尾）</span><br></pre></td></tr></table></figure><h3 id="web请求处理过程"><a href="#web请求处理过程" class="headerlink" title="web请求处理过程"></a>web请求处理过程</h3><p>所有web请求都会进入到 org.springframework.web.servlet 包下的 DispatcherServlet 类的 doDispatch(HttpServletRequest request, HttpServletResponse response) 方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line"><span class="comment">//***获取映射处理器，进入该方法可以看到所有的请求路径映射***</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = HttpMethod.GET.matches(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***（1）***</span></span><br><span class="line">             <span class="comment">//***真正要开始处理请求映射的方法***</span></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 mappedHandler = getHandler(processedRequest) ，进入到 getHandler() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//***mapping中包含了所有的请求路径，和请求路径映射的方法。</span></span><br><span class="line"><span class="keyword">for</span> (HandlerMapping mapping : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.handlerMappings:<br>    <img src="/2022/01/19/springboot-yuan-ma-bi-ji/003.png" class=""><br>mapping:<br>    包含了所有请求路径和请求路径的映射方法<br>    <img src="/2022/01/19/springboot-yuan-ma-bi-ji/005.png" class=""><br>    <img src="/2022/01/19/springboot-yuan-ma-bi-ji/004.png" class=""></p><p>执行 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()) 时，会进入到 AbstractHandlerMethodAdapter 类的 handle(HttpServletRequest request, HttpServletResponse response, Object handler) 方法中（共有四个HandleMethodAdapter， 分别是…）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着进入到 RequestMappingHandlerAdapter 类的 handleInternal(HttpServletRequest request,<br>HttpServletResponse response, HandlerMethod handlerMethod) 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">ModelAndView mav;</span><br><span class="line">checkRequest(request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line"><span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//***(2)***</span></span><br><span class="line">         <span class="comment">//***开始进入请求方法执行流程***</span></span><br><span class="line"><span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line"><span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">prepareResponse(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 mav = invokeHandlerMethod(request, response, handlerMethod) 进入到同类中的 invokeHandlerMethod(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod) 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;  </span><br><span class="line"><span class="comment">//***设置请求方法的参数解析器***</span></span><br><span class="line">invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//***设置请求方法的返回值处理器***</span></span><br><span class="line">invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">&#125;</span><br><span class="line">invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line">AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"><span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">Object result = asyncManager.getConcurrentResult();</span><br><span class="line">mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">asyncManager.clearConcurrentResult();</span><br><span class="line">LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//***(3)***</span></span><br><span class="line">        <span class="comment">//***开始处理请求方法的参数、试图等</span></span><br><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">webRequest.requestCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求方法参数解析器 ：<img src="/2022/01/19/springboot-yuan-ma-bi-ji/001.png" class=""><br>请求方法返回值处理器：<img src="/2022/01/19/springboot-yuan-ma-bi-ji/002.png" class=""></p><p>执行 invocableMethod.invokeAndHandle(webRequest, mavContainer)，进入到 ServletInvocableHandlerMethod 类下的 invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,Object… providedArgs) 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//***(4)***</span></span><br><span class="line">    <span class="comment">//***对请求方法选择支持的参数类型解析器（可能不准确）***</span></span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">setResponseStatus(webRequest);</span><br><span class="line"><span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">disableContentCachingIfNecessary(webRequest);</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs) ，进入 InvocableHandlerMethod 类下的 invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object… providedArgs) 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//***(5)***</span></span><br><span class="line">Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs) ，进入到同类下的 getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object… providedArgs) 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MethodParameter[] parameters = getMethodParameters();</span><br><span class="line"><span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line"><span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***(6)***</span></span><br><span class="line"><span class="comment">//***开始遍历请求方法的参数列表,按照参数列表的数量创建一个对象数组args，args中的的每个元素后来都会转化为对应的参数列表中的对象类型***</span></span><br><span class="line">Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">MethodParameter parameter = parameters[i];</span><br><span class="line">parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line"><span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//***(7)***</span></span><br><span class="line"><span class="comment">//判断resolvers中是否有支持当前参数的resolver</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//***(8)***</span></span><br><span class="line"><span class="comment">//***获取参数类型的对象数组***</span></span><br><span class="line">args[i] = <span class="keyword">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">String exMsg = ex.getMessage();</span><br><span class="line"><span class="keyword">if</span> (exMsg != <span class="keyword">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//***(9)***</span></span><br><span class="line"><span class="comment">//***获取参数解析器***</span></span><br><span class="line">HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);</span><br><span class="line"><span class="keyword">if</span> (resolver == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unsupported parameter type [&quot;</span> +</span><br><span class="line">parameter.getParameterType().getName() + <span class="string">&quot;]. supportsParameter should be called first.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***这一部像是递归，还没搞懂该行的作用***</span></span><br><span class="line"><span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//***(10)***</span></span><br><span class="line"><span class="comment">//***遍历所有的参数类型解析器，找到支持该参数的解析器***</span></span><br><span class="line"><span class="keyword">for</span> (HandlerMethodArgumentResolver resolver : <span class="keyword">this</span>.argumentResolvers) &#123;</span><br><span class="line"><span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">result = resolver;</span><br><span class="line"><span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内容协商机制"><a href="#内容协商机制" class="headerlink" title="内容协商机制"></a>内容协商机制</h3><p>内容协商：协商浏览器能接受的数据类型和服务端能生产的数据类型（数据类型值的是数据的格式，例如XML和JSON等）<br>在SpringBoot中，内容协商流程发生在返回值处理器中。<br>请求的响应过程中，会得到支持请求路径映射的方法返回值的返回值处理器HandlerMethodReturnValueHandler ，接着进入到 HandlerMethodReturnValueHandler 具体实现类中，执行 handleReturnValue() 方法。以 RequestResponseBodyMethodProcessor 为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="params"><span class="function">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try even with null return value. ResponseBodyAdvice could get involved.</span></span><br><span class="line">writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithMessageConverters</span><span class="params">(<span class="meta">@Nullable</span> T value, MethodParameter returnType,</span></span></span><br><span class="line"><span class="params"><span class="function">ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object body;</span><br><span class="line">Class&lt;?&gt; valueType;</span><br><span class="line">Type targetType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">body = value.toString();</span><br><span class="line">valueType = String.class;</span><br><span class="line">targetType = String.class;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">body = value;</span><br><span class="line">valueType = getReturnValueType(body, returnType);</span><br><span class="line">targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isResourceType(value, returnType)) &#123;</span><br><span class="line">outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, <span class="string">&quot;bytes&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">outputMessage.getServletResponse().getStatus() == <span class="number">200</span>) &#123;</span><br><span class="line">Resource resource = (Resource) value;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">List&lt;HttpRange&gt; httpRanges = inputMessage.getHeaders().getRange();</span><br><span class="line">outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());</span><br><span class="line">body = HttpRange.toResourceRegions(httpRanges, resource);</span><br><span class="line">valueType = body.getClass();</span><br><span class="line">targetType = RESOURCE_REGION_LIST_TYPE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, <span class="string">&quot;bytes */&quot;</span> + resource.contentLength());</span><br><span class="line">outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MediaType selectedMediaType = <span class="keyword">null</span>;</span><br><span class="line">MediaType contentType = outputMessage.getHeaders().getContentType();</span><br><span class="line"><span class="keyword">boolean</span> isContentTypePreset = contentType != <span class="keyword">null</span> &amp;&amp; contentType.isConcrete();</span><br><span class="line"><span class="keyword">if</span> (isContentTypePreset) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Found &#x27;Content-Type:&quot;</span> + contentType + <span class="string">&quot;&#x27; in response&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">selectedMediaType = contentType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">HttpServletRequest request = inputMessage.getServletRequest();</span><br><span class="line">List&lt;MediaType&gt; acceptableTypes;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//***得到浏览器可接受的媒体类型***</span></span><br><span class="line"><span class="comment">//***进入getAcceptableMediaTypes方法，可获取使用哪种内容协商策略ContentNegotiationStrategy***</span></span><br><span class="line">acceptableTypes = getAcceptableMediaTypes(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (HttpMediaTypeNotAcceptableException ex) &#123;</span><br><span class="line"><span class="keyword">int</span> series = outputMessage.getServletResponse().getStatus() / <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (body == <span class="keyword">null</span> || series == <span class="number">4</span> || series == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Ignoring error response content (if any). &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***得到服务端可生产的媒体类型***</span></span><br><span class="line">List&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (body != <span class="keyword">null</span> &amp;&amp; producibleTypes.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotWritableException(</span><br><span class="line"><span class="string">&quot;No converter found for return value of type: &quot;</span> + valueType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***遍历两种媒体类型，得到双方可以匹配的媒体类型***</span></span><br><span class="line">List&lt;MediaType&gt; mediaTypesToUse = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (MediaType requestedType : acceptableTypes) &#123;</span><br><span class="line"><span class="keyword">for</span> (MediaType producibleType : producibleTypes) &#123;</span><br><span class="line"><span class="keyword">if</span> (requestedType.isCompatibleWith(producibleType)) &#123;</span><br><span class="line">mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mediaTypesToUse.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotAcceptableException(producibleTypes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;No match for &quot;</span> + acceptableTypes + <span class="string">&quot;, supported: &quot;</span> + producibleTypes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***按照权重等规则进行排序***</span></span><br><span class="line">MediaType.sortBySpecificityAndQuality(mediaTypesToUse);</span><br><span class="line"></span><br><span class="line"><span class="comment">//***确定最佳匹配的媒体类型***</span></span><br><span class="line"><span class="keyword">for</span> (MediaType mediaType : mediaTypesToUse) &#123;</span><br><span class="line"><span class="keyword">if</span> (mediaType.isConcrete()) &#123;</span><br><span class="line">selectedMediaType = mediaType;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) &#123;</span><br><span class="line">selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Using &#x27;&quot;</span> + selectedMediaType + <span class="string">&quot;&#x27;, given &quot;</span> +</span><br><span class="line">acceptableTypes + <span class="string">&quot; and supported &quot;</span> + producibleTypes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (selectedMediaType != <span class="keyword">null</span>) &#123;</span><br><span class="line">selectedMediaType = selectedMediaType.removeQualityValue();</span><br><span class="line"><span class="comment">//***根据最终匹配的媒体类型，遍历寻找支持的消息转换器Converter</span></span><br><span class="line"><span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">GenericHttpMessageConverter genericConverter = (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ?</span><br><span class="line">(GenericHttpMessageConverter&lt;?&gt;) converter : <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (genericConverter != <span class="keyword">null</span> ?</span><br><span class="line">((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :</span><br><span class="line">converter.canWrite(valueType, selectedMediaType)) &#123;</span><br><span class="line">body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,</span><br><span class="line">(Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),</span><br><span class="line">inputMessage, outputMessage);</span><br><span class="line"><span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object theBody = body;</span><br><span class="line">LogFormatUtils.traceDebug(logger, traceOn -&gt;</span><br><span class="line"><span class="string">&quot;Writing [&quot;</span> + LogFormatUtils.formatValue(theBody, !traceOn) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">addContentDispositionHeader(inputMessage, outputMessage);</span><br><span class="line"><span class="keyword">if</span> (genericConverter != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//***执行消息转换器的 write 方法***</span></span><br><span class="line">genericConverter.write(body, targetType, selectedMediaType, outputMessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//***执行消息转换器的 write 方法***</span></span><br><span class="line">((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Nothing to write: null body&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">Set&lt;MediaType&gt; producibleMediaTypes =</span><br><span class="line">(Set&lt;MediaType&gt;) inputMessage.getServletRequest()</span><br><span class="line">.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isContentTypePreset || !CollectionUtils.isEmpty(producibleMediaTypes)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotWritableException(</span><br><span class="line"><span class="string">&quot;No converter for [&quot;</span> + valueType + <span class="string">&quot;] with preset Content-Type &#x27;&quot;</span> + contentType + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotAcceptableException(getSupportedMediaTypes(body.getClass()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acceptableTypes = getAcceptableMediaTypes(request) ，确定内容协商策略，进而根据策略获取浏览器可接受的媒体类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;MediaType&gt; <span class="title">getAcceptableMediaTypes</span><span class="params">(HttpServletRequest request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> HttpMediaTypeNotAcceptableException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.contentNegotiationManager.resolveMediaTypes(<span class="keyword">new</span> ServletWebRequest(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MediaType&gt; <span class="title">resolveMediaTypes</span><span class="params">(NativeWebRequest request)</span> <span class="keyword">throws</span> HttpMediaTypeNotAcceptableException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (ContentNegotiationStrategy strategy : <span class="keyword">this</span>.strategies) &#123;</span><br><span class="line">List&lt;MediaType&gt; mediaTypes = strategy.resolveMediaTypes(request);</span><br><span class="line"><span class="keyword">if</span> (mediaTypes.equals(MEDIA_TYPE_ALL_LIST)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mediaTypes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> MEDIA_TYPE_ALL_LIST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时只有一种默认的协商策略，基于request请求头的协商策略：HeaderContentNegotiationStrategy。也可以添加其他的内容协商策略，如在配置文件中开启基于请求参数的协商策略，也可以自定义协商策略。</p><img src="/2022/01/19/springboot-yuan-ma-bi-ji/007.png" class=""><p>消息转换器Converter：<img src="/2022/01/19/springboot-yuan-ma-bi-ji/006.png" class=""></p><p>开启支持XML格式数据：导入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>开启基于请求参数的内容协商策略，配置文件中配置相应属性值。此时发送的请求中要附带一个 format 的字段，例如 <a class="link"   href="http://localhost:8080/test/person?format=json" >http://localhost:8080/test/person?format=json<i class="fas fa-external-link-alt"></i></a> 和<a class="link"   href="http://localhost:8080/test/person?format=xml" >http://localhost:8080/test/person?format=xml<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.contentnegotiation.favor-parameter=true</span><br></pre></td></tr></table></figure><p>自定义内容协商策略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot-JPA</title>
    <link href="https://up-bear.github.io/2021/12/04/springboot-jpa/"/>
    <id>https://up-bear.github.io/2021/12/04/springboot-jpa/</id>
    <published>2021-12-04T10:52:03.000Z</published>
    <updated>2021-12-04T13:49:16.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="pom依赖配置"><a href="#pom依赖配置" class="headerlink" title="pom依赖配置"></a>pom依赖配置</h3><h4 id="jpa本身配置"><a href="#jpa本身配置" class="headerlink" title="jpa本身配置"></a>jpa本身配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="引入驱动依赖（mysql数据库操作必配）"><a href="#引入驱动依赖（mysql数据库操作必配）" class="headerlink" title="引入驱动依赖（mysql数据库操作必配）"></a>引入驱动依赖（mysql数据库操作必配）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="mysql数据库链接"><a href="#mysql数据库链接" class="headerlink" title="mysql数据库链接"></a>mysql数据库链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#数据库连接</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/admin?characterEncoding=UTF-8</span><br><span class="line">spring.datasource.username=用户名</span><br><span class="line">spring.datasource.password=用户密码</span><br><span class="line">#mysql驱动</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="一、创建实体类"><a href="#一、创建实体类" class="headerlink" title="一、创建实体类"></a>一、创建实体类</h4><p>实体类标注注解：@Entity、@Table。注意导入的包为：javax.persistence.*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    String headImg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//性别</span></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    String gender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    String email;</span><br><span class="line"></span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeadImg</span><span class="params">(String headImg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headImg = headImg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHeadImg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> headImg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JPA默认的字段命名规则是驼峰转换，eg：UserName –&gt; user_name。</p><h4 id="JPA配置修改"><a href="#JPA配置修改" class="headerlink" title="JPA配置修改"></a>JPA配置修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置自动更新表结构</span><br><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br><span class="line">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">#在控制台显示sql语句</span><br><span class="line">spring.jpa.show-sql= true</span><br></pre></td></tr></table></figure><h4 id="二、继承JpaRepository接口"><a href="#二、继承JpaRepository接口" class="headerlink" title="二、继承JpaRepository接口"></a>二、继承JpaRepository接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User对应要操作的数据表实体类，Integer是int类型的封装类，固定不变</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="三、使用接口类进行CRUD操作"><a href="#三、使用接口类进行CRUD操作" class="headerlink" title="三、使用接口类进行CRUD操作"></a>三、使用接口类进行CRUD操作</h4><p>当UserDAO继承了JpaRepository后，可以在其它类中注入UserDAO，使用UserDAO进行简单的crud操作。在类UserService标注注解@Service的作用是，向容器中添加该类的组件，之后可以在其它地方使用注解@Autowired注入该类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserDAO userDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userDAO.save(user);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JPA注入：<br>    使用注解@Autowired。<br>    内部使用了@Autowired的类，在外面不能使用new创建该类对象，而是使用@Autowired注入对象，否则会导致JPA注入失败，报空指针异常。<br>    eg：UserController类中使用了new UserService创建对象，导致UserService类中UserDAO注入失败，userDAO为null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public void hi()&#123;</span><br><span class="line">        new UserService().add(new User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确用法是使用@Autowired注入UserService对象，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public void hi()&#123;</span><br><span class="line">        userService.add(new User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="mysql" scheme="https://up-bear.github.io/categories/mysql/"/>
    
    <category term="SpringBoot" scheme="https://up-bear.github.io/categories/SpringBoot/"/>
    
    
    <category term="JPA" scheme="https://up-bear.github.io/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-方法参数</title>
    <link href="https://up-bear.github.io/2021/12/02/springboot-fang-fa-can-shu/"/>
    <id>https://up-bear.github.io/2021/12/02/springboot-fang-fa-can-shu/</id>
    <published>2021-12-02T15:30:00.000Z</published>
    <updated>2021-12-04T13:50:04.872Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="方法参数封装"><a href="#方法参数封装" class="headerlink" title="方法参数封装"></a>方法参数封装</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://up-bear.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记</title>
    <link href="https://up-bear.github.io/2021/11/26/mysql-xue-xi-bi-ji/"/>
    <id>https://up-bear.github.io/2021/11/26/mysql-xue-xi-bi-ji/</id>
    <published>2021-11-26T01:53:52.000Z</published>
    <updated>2022-11-28T14:35:23.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h1><h2 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h2><p><strong>书写规范：</strong></p><ul><li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li><li>每条命令以 ; 或 \g 或 \G 结束</li><li>关键字不能被缩写也不能分行</li><li>关于标点符号<ul><li>必须保证所有的()、单引号、双引号是成对结束的</li><li>必须使用英文状态下的半角输入方式</li><li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示</li><li>列的别名，尽量使用双引号（” “），而且不建议省略as</li></ul></li></ul><p><strong>大小写：</strong></p><ul><li><strong>MySQL 在 Windows 环境下是大小写不敏感的</strong></li><li><strong>MySQL 在 Linux 环境下是大小写敏感的</strong></li><li>数据库名、表名、表的别名、变量名是严格区分大小写的</li><li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的</li></ul><p><strong>推荐采用统一的书写规范：</strong></p><ul><li>数据库名、表名、表别名、字段名、字段别名等都小写</li><li>SQL 关键字、函数名、绑定变量等都大写</li></ul><p><strong>注释：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释：#注释文字(MySQL特有的方式)</span><br><span class="line">单行注释：-- 注释文字(--后面必须包含一个空格。)</span><br><span class="line">多行注释：/* 注释文字  */</span><br></pre></td></tr></table></figure><p><strong>数据导入：</strong><br>Mysql命令行客户端使用<code>source</code>命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source d:\mysqldb.sql</span><br></pre></td></tr></table></figure><p><strong>查看表结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DESCRIBE employees;</span><br><span class="line"># 或</span><br><span class="line">DESC employees;</span><br></pre></td></tr></table></figure><h2 id="SELECT语法基础"><a href="#SELECT语法基础" class="headerlink" title="SELECT语法基础"></a>SELECT语法基础</h2><ol><li><p>SELECT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1; #没有任何子句</span><br><span class="line">SELECT 9/2; #没有任何子句</span><br></pre></td></tr></table></figure></li><li><p>SELECT … FROM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT   表列名</span><br><span class="line">FROM     要选择的表</span><br><span class="line"></span><br><span class="line">#选择特定列</span><br><span class="line">SELECT department_id, location_id</span><br><span class="line">FROM   departments;</span><br><span class="line"></span><br><span class="line">#选择表的全部列</span><br><span class="line">SELECT *</span><br><span class="line">FROM   departments;</span><br></pre></td></tr></table></figure><blockquote><p>一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符<code>*</code><br>使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率<br>在生产环境下，不推荐你直接使用<code>SELECT *</code>进行查询</p></blockquote></li></ol><p><strong>列的别名</strong><br>语法：紧跟列名，也可以<strong>在列名和别名之间加入关键字AS，别名使用双引号</strong>，以便在别名中包含空格或特殊的字符并区分大小写。AS 可以省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name AS name, commission_pct comm</span><br><span class="line">FROM   employees;</span><br><span class="line">  </span><br><span class="line">SELECT last_name &quot;Name&quot;, salary*12 &quot;Annual Salary&quot;</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure><p><strong>去除重复行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure><p><code>DISTINCT</code>其实是对后面所有列名的组合进行去重，当<code>DISTINCT</code>后面有多个列名时，<code>DISTINCT</code>需要放在最前面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT department_id,salary </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><p><strong>空值null</strong><br>所有运算符或列值遇到null值，运算的结果都为null</p><p><strong>着重号</strong><br>表中的字段、表名等如果有和Mysql保留字、数据库系统或常用方法冲突时，需在SQL语句中使用一对``（着重号）引起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `ORDER`;</span><br></pre></td></tr></table></figure><p><strong>查询常数</strong><br><code>SELECT</code>查询还可以对常数进行查询。在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。</p><p>SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。<br>比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段<code>corporation</code>，这个字段固定值为“尚硅谷”，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &#x27;尚硅谷&#x27; as corporation, last_name FROM employees;</span><br></pre></td></tr></table></figure><p><strong>过滤数据——WHERE</strong></p><ul><li>使用WHERE 子句，将不满足条件的行过滤掉</li><li><strong>WHERE子句紧随 FROM子句</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1,字段2</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 过滤条件</span><br><span class="line"></span><br><span class="line"># 举例</span><br><span class="line">SELECT employee_id, last_name, job_id, department_id</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  department_id = 90 ;</span><br></pre></td></tr></table></figure></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式。<br><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/001.png" alt="img-001"></p><ol><li><p>加减法运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5 FROM dual;</span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+</span><br><span class="line">| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |</span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+</span><br><span class="line">| 100 |     100 |     100 |      150 |          120 |      135.5 |       64.5 |</span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><ul><li>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</li><li>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</li><li>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</li><li>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）</li></ul></blockquote></li><li><p>乘除法运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100 DIV 0 FROM dual;</span><br><span class="line">+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><br><span class="line">| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3  | 100 DIV 0 |</span><br><span class="line">+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><br><span class="line">| 100 |     100 |     100.0 |  100.0000 | 50.0000 |        105.0000 | 33.3333 |      NULL |</span><br><span class="line">+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><ul><li>一个数乘以整数1和除以整数1后仍得原数；</li><li>一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；</li><li>一个数除以整数后，不管是否能除尽，结果都为一个浮点数；</li><li>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；</li><li>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</li><li>在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。</li></ul></blockquote></li></ol><p><strong>求模（求余）运算符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 12 % 3, 12 MOD 5 FROM dual;</span><br><span class="line">+--------+----------+</span><br><span class="line">| 12 % 3 | 12 MOD 5 |</span><br><span class="line">+--------+----------+</span><br><span class="line">|      0 |        2 |</span><br><span class="line">+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><strong>等号运算符</strong></p><ul><li>等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0</li><li>在使用等号运算符时，遵循如下规则：<ul><li>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</li><li>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</li><li>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</li><li>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</li></ul></li><li>对比：SQL中赋值符号使用 := </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 = 1, 1 = &#x27;1&#x27;, 1 = 0, &#x27;a&#x27; = &#x27;a&#x27;, (5 + 3) = (2 + 6), &#x27;&#x27; = NULL , NULL = NULL; </span><br><span class="line">+-------+---------+-------+-----------+-------------------+-----------+-------------+</span><br><span class="line">| 1 = 1 | 1 = &#x27;1&#x27; | 1 = 0 | &#x27;a&#x27; = &#x27;a&#x27; | (5 + 3) = (2 + 6) | &#x27;&#x27; = NULL | NULL = NULL |</span><br><span class="line">+-------+---------+-------+-----------+-------------------+-----------+-------------+</span><br><span class="line">|    1  |     1   |   0   |      1    |             1     |    NULL   |        NULL  |</span><br><span class="line">+-------+---------+-------+-----------+-------------------+-----------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT 1 = 2, 0 = &#x27;abc&#x27;, 1 = &#x27;abc&#x27; FROM dual;</span><br><span class="line">+-------+-----------+-----------+</span><br><span class="line">| 1 = 2 | 0 = &#x27;abc&#x27; | 1 = &#x27;abc&#x27; |</span><br><span class="line">+-------+-----------+-----------+</span><br><span class="line">|     0 |         1 |         0 |</span><br><span class="line">+-------+-----------+-----------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>安全等与运算符</strong><br>安全等于运算符（&lt;=&gt;）与等于运算符（=）的作用是相似的，<code>唯一的区别</code>是‘&lt;=&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &lt;=&gt; &#x27;1&#x27;, 1 &lt;=&gt; 0, &#x27;a&#x27; &lt;=&gt; &#x27;a&#x27;, (5 + 3) &lt;=&gt; (2 + 6), &#x27;&#x27; &lt;=&gt; NULL,NULL &lt;=&gt; NULL FROM dual;</span><br><span class="line">+-----------+---------+-------------+---------------------+-------------+---------------+</span><br><span class="line">| 1 &lt;=&gt; &#x27;1&#x27; | 1 &lt;=&gt; 0 | &#x27;a&#x27; &lt;=&gt; &#x27;a&#x27; | (5 + 3) &lt;=&gt; (2 + 6) | &#x27;&#x27; &lt;=&gt; NULL | NULL &lt;=&gt; NULL |</span><br><span class="line">+-----------+---------+-------------+---------------------+-------------+---------------+</span><br><span class="line">|         1 |       0 |           1 |                   1 |           0 |             1 |</span><br><span class="line">+-----------+---------+-------------+---------------------+-------------+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>不等于运算符</strong><br>不等于运算符（&lt;&gt;和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &lt;&gt; 1, 1 != 2, &#x27;a&#x27; != &#x27;b&#x27;, (3+4) &lt;&gt; (2+6), &#x27;a&#x27; != NULL, NULL &lt;&gt; NULL; </span><br><span class="line">+--------+--------+------------+----------------+-------------+--------------+</span><br><span class="line">| 1 &lt;&gt; 1 | 1 != 2 | &#x27;a&#x27; != &#x27;b&#x27; | (3+4) &lt;&gt; (2+6) | &#x27;a&#x27; != NULL | NULL &lt;&gt; NULL |</span><br><span class="line">+--------+--------+------------+----------------+-------------+--------------+</span><br><span class="line">|      0 |   1    |       1    |            1   |     NULL    |         NULL |</span><br><span class="line">+--------+--------+------------+----------------+-------------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>空值运算符</strong><br>空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。</p><p><strong>非空运算符</strong><br>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。</p><p><strong>最小值运算符</strong><br>语法格式为：LEAST(值1，值2，…，值n)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT LEAST (1,0,2), LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), LEAST(1,NULL,2);</span><br><span class="line">+---------------+--------------------+-----------------+</span><br><span class="line">| LEAST (1,0,2) | LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | LEAST(1,NULL,2) |</span><br><span class="line">+---------------+--------------------+-----------------+</span><br><span class="line">|       0       |        a           |      NULL       |</span><br><span class="line">+---------------+--------------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><p><strong>最大值运算符</strong><br>语法格式为：GREATEST(值1，值2，…，值n)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT GREATEST(1,0,2), GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), GREATEST(1,NULL,2);</span><br><span class="line">+-----------------+-----------------------+--------------------+</span><br><span class="line">| GREATEST(1,0,2) | GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | GREATEST(1,NULL,2) |</span><br><span class="line">+-----------------+-----------------------+--------------------+</span><br><span class="line">|               2 | c                     |               NULL |</span><br><span class="line">+-----------------+-----------------------+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><p><strong>BETWEEN AND运算符</strong><br>使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，注意A必须小于B！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, &#x27;b&#x27; BETWEEN &#x27;a&#x27; AND &#x27;c&#x27;;</span><br><span class="line">+-------------------+----------------------+-------------------------+</span><br><span class="line">| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | &#x27;b&#x27; BETWEEN &#x27;a&#x27; AND &#x27;c&#x27; |</span><br><span class="line">+-------------------+----------------------+-------------------------+</span><br><span class="line">|                 1 |                    0 |                       1 |</span><br><span class="line">+-------------------+----------------------+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>IN运算符</strong><br>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 IN (2,3), NULL IN (&#x27;a&#x27;,&#x27;b&#x27;), &#x27;a&#x27; IN (&#x27;a&#x27;, NULL);</span><br><span class="line">+----------------------+------------+-------------------+--------------------+</span><br><span class="line">| &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 IN (2,3) | NULL IN (&#x27;a&#x27;,&#x27;b&#x27;) | &#x27;a&#x27; IN (&#x27;a&#x27;, NULL) |</span><br><span class="line">+----------------------+------------+-------------------+--------------------+</span><br><span class="line">|            1         |        0   |         NULL      |         1          |</span><br><span class="line">+----------------------+------------+-------------------+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>NOT IN运算符</strong><br>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;a&#x27; NOT IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 NOT IN (2,3);</span><br><span class="line">+--------------------------+----------------+</span><br><span class="line">| &#x27;a&#x27; NOT IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 NOT IN (2,3) |</span><br><span class="line">+--------------------------+----------------+</span><br><span class="line">|                 0        |            1   |</span><br><span class="line">+--------------------------+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>LIKE运算符</strong><br>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 通配符</span><br><span class="line"># “%”：匹配0个或多个字符。</span><br><span class="line"># “_”：只能匹配一个字符。</span><br><span class="line"></span><br><span class="line">SELECTfirst_name</span><br><span class="line">FROM employees</span><br><span class="line">WHEREfirst_name LIKE &#x27;S%&#x27;;</span><br></pre></td></tr></table></figure><p><strong>ESCAPE</strong><br>ESCAPE 关键字的主要作用就是指定一个字符替代“\”的作用。查询条件中所有通过ESCAPE指代的字符均会替代“\”的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># MySQL中，转义字符以“\”开头</span><br><span class="line"></span><br><span class="line">### 查询名字中带明字的用户</span><br><span class="line">SELECT * FROM user WHERE name LIKE CONCAT(&quot;%&quot;, &quot;明&quot;, &quot;%&quot;)</span><br><span class="line"></span><br><span class="line">### 查询名字带有%字符的用户</span><br><span class="line">SELECT * FROM user WHERE name LIKE CONCAT(&quot;%&quot;, &quot;\%&quot;, &quot;%&quot;)</span><br><span class="line"></span><br><span class="line"># 使用ESCAPE代替转义字符 \</span><br><span class="line">### 查询名字带有“%”字符的用户</span><br><span class="line">SELECT * FROM user WHERE name LIKE CONCAT(&quot;%&quot;, &quot;$%&quot;, &quot;%&quot;) ESCAPE &quot;$&quot;</span><br><span class="line"></span><br><span class="line">### 查询名字带有“_”字符的用户</span><br><span class="line">SELECT * FROM user WHERE name LIKE CONCAT(&quot;%&quot;, &quot;a_&quot;, &quot;%&quot;) ESCAPE &quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>REGEXP运算符</strong><br>REGEXP运算符用来匹配字符串，语法格式为：<code>expr REGEXP 匹配条件</code>。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。</p><p>REGEXP运算符在进行匹配时，常用的有下面几种通配符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）‘^’匹配以该字符后面的字符开头的字符串。</span><br><span class="line">（2）‘$’匹配以该字符前面的字符结尾的字符串。</span><br><span class="line">（3）‘.’匹配任何一个单字符。</span><br><span class="line">（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</span><br><span class="line">（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，而“*”匹配任何数量的任何字符。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27;;</span><br><span class="line">+------------------------+------------------------+-------------------------+</span><br><span class="line">| &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27; | &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27; | &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27;  |</span><br><span class="line">+------------------------+------------------------+-------------------------+</span><br><span class="line">|                      1 |                      1 |                       1 |</span><br><span class="line">+------------------------+------------------------+-------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27;, &#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27;;</span><br><span class="line">+--------------------------+-------------------------+</span><br><span class="line">| &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27; | &#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27; |</span><br><span class="line">+--------------------------+-------------------------+</span><br><span class="line">|                        1 |                       1 |</span><br><span class="line">+--------------------------+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>图示总览</strong><br><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/002.png" alt="img-002"><br><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/003.png" alt="img-003"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。<br><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/004.png" alt="img-004"></p><p><strong>逻辑与运算符</strong><br>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。</p><p><strong>逻辑或运算符</strong><br>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。</p><blockquote><p>OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p></blockquote><p><strong>逻辑非运算符</strong><br>逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。</p><p><strong>逻辑异或运算符</strong><br>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。<br><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/005.png" alt="img-005"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/006.png" alt="img-006"><br><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/007.png" alt="img-007"></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。<br><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/008.png" alt="img-008"></p><p><strong>1. 查询以特定字符或字符串开头的记录</strong><br>字符‘^’匹配以特定字符或者字符串开头的文本。</p><p>在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^b&#x27;;</span><br></pre></td></tr></table></figure><p><strong>2. 查询以特定字符或字符串结尾的记录</strong><br>字符‘$’匹配以特定字符或者字符串结尾的文本。</p><p>在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;y$&#x27;;</span><br></pre></td></tr></table></figure><p><strong>3. 用符号”.”来替代字符串中的任意一个字符</strong><br>字符‘.’匹配任意一个字符。<br>在fruits表中，查询f_name字段值包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;a.g&#x27;;</span><br></pre></td></tr></table></figure><p><strong>4. 使用”*”和”+”来匹配多个字符</strong><br>星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至少一次。</p><p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba*&#x27;;</span><br></pre></td></tr></table></figure><p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba+&#x27;;</span><br></pre></td></tr></table></figure><p><strong>5. 匹配指定字符串</strong><br>正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。</p><p>在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on&#x27;;</span><br></pre></td></tr></table></figure><p>在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on|ap&#x27;;</span><br></pre></td></tr></table></figure><p>之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。</p><p>在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name like &#x27;on&#x27;;</span><br><span class="line">Empty set(0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>6. 匹配指定字符中的任意一个</strong><br>方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。</p><p>在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;[ot]&#x27;;</span><br></pre></td></tr></table></figure><p>在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE s_id REGEXP &#x27;[456]&#x27;;</span><br></pre></td></tr></table></figure><p><strong>7. 匹配指定字符以外的字符</strong><br><code>“[^字符集合]”</code>匹配不在指定集合中的任何字符。</p><p>在fruits表中，查询f_id字段中包含字母a<del>e和数字1</del>2以外字符的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_id REGEXP &#x27;[^a-e1-2]&#x27;;</span><br></pre></td></tr></table></figure><p><strong>8. 使用{n,}或者{n,m}来指定字符串连续出现的次数</strong><br>“字符串{n,}”表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。</p><p>在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;x&#123;2,&#125;&#x27;;</span><br></pre></td></tr></table></figure><p>在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;ba&#123;1,3&#125;&#x27;;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>使用 ORDER BY 子句排序<ul><li><strong>ASC（ascend）: 升序</strong></li><li><strong>DESC（descend）:降序</strong></li></ul></li><li><strong>ORDER BY 子句在SELECT语句的结尾</strong></li></ul><p><strong>单列排序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT   last_name, job_id, department_id, hire_date</span><br><span class="line">FROM     employees</span><br><span class="line">ORDER BY hire_date ;</span><br><span class="line"></span><br><span class="line"># 降序</span><br><span class="line">SELECT   last_name, job_id, department_id, hire_date</span><br><span class="line">FROM     employees</span><br><span class="line">ORDER BY hire_date DESC ;</span><br></pre></td></tr></table></figure><p><strong>多列排序</strong><br>多列排序，实际上是先按第一个排序条件进行排序，如果结果相同再按第二个排序条件进行比较，以此类推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name, department_id, salary</span><br><span class="line">FROM   employees</span><br><span class="line">ORDER BY department_id, salary DESC;</span><br></pre></td></tr></table></figure><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/009.png" alt="img-009"></p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>MySQL中使用<strong>LIMIT</strong>实现分页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT [位置偏移量,] 行数</span><br></pre></td></tr></table></figure><p>“位置偏移量”指示MySQL从哪一行开始显示，是一个可选参数，不指定会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--前10条记录：</span><br><span class="line">SELECT * FROM 表名 LIMIT 0,10;</span><br><span class="line">或者</span><br><span class="line">SELECT * FROM 表名 LIMIT 10;</span><br><span class="line"></span><br><span class="line">--第11至20条记录：</span><br><span class="line">SELECT * FROM 表名 LIMIT 10,10;</span><br><span class="line"></span><br><span class="line">--第21至30条记录： </span><br><span class="line">SELECT * FROM 表名 LIMIT 20,10;</span><br></pre></td></tr></table></figure><p>分页显示公式：<strong>（当前页数-1）每页条数，每页条数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table </span><br><span class="line">LIMIT(PageNo - 1)*PageSize,PageSize;</span><br></pre></td></tr></table></figure><p>PS：LIMIT 子句必须放在整个SELECT语句的最后！</p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p><p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。</p><h3 id="错误案例"><a href="#错误案例" class="headerlink" title="错误案例"></a>错误案例</h3><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/010.png" alt="img-010"></p><p>从多个表中获取数据：</p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/011.png" alt="img-011"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#案例：查询员工的姓名及部门名称</span><br><span class="line">SELECT last_name, department_name</span><br><span class="line">FROM employees, departments;</span><br></pre></td></tr></table></figure><p>查询结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+-----------+----------------------+</span><br><span class="line">| last_name | department_name      |</span><br><span class="line">+-----------+----------------------+</span><br><span class="line">| King      | Administration       |</span><br><span class="line">| King      | Marketing            |</span><br><span class="line">| King      | Purchasing           |</span><br><span class="line">| King      | Human Resources      |</span><br><span class="line">| King      | Shipping             |</span><br><span class="line">| King      | IT                   |</span><br><span class="line">| King      | Public Relations     |</span><br><span class="line">| King      | Sales                |</span><br><span class="line">| King      | Executive            |</span><br><span class="line">| King      | Finance              |</span><br><span class="line">| King      | Accounting           |</span><br><span class="line">| King      | Treasury             |</span><br><span class="line">...</span><br><span class="line">| Gietz     | IT Support           |</span><br><span class="line">| Gietz     | NOC                  |</span><br><span class="line">| Gietz     | IT Helpdesk          |</span><br><span class="line">| Gietz     | Government Sales     |</span><br><span class="line">| Gietz     | Retail Sales         |</span><br><span class="line">| Gietz     | Recruiting           |</span><br><span class="line">| Gietz     | Payroll              |</span><br><span class="line">+-----------+----------------------+</span><br><span class="line">2889 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>错误分析：<br>上面的SQL语句的查询结果将每一个员工和每一个部门都进行了匹配，出现了一个员工隶属所有部门的情况，查询结果的数量为员工表和部门表的记录数量乘积。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ul><li>笛卡儿积错误产生条件：<ul><li>省略多个表的连接条件（关联条件）</li><li>连接条件（关联条件）无效</li><li>所有表中的所有行相互连接</li></ul></li><li>避免笛卡儿积，<strong>在WHERE 加入有效的连接条件</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECTtable1.column, table2.column</span><br><span class="line">FROMtable1, table2</span><br><span class="line">WHEREtable1.column1 = table2.column2;  #连接条件</span><br></pre></td></tr></table></figure></li><li>上述错误案例的正确写法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#案例：查询员工的姓名及其部门名称</span><br><span class="line">SELECT last_name, department_name</span><br><span class="line">FROM employees, departments</span><br><span class="line">WHERE employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure></li><li>在多个表中存在相同列名时，在列名前加上表名前缀</li></ul><h3 id="多表查询分类及拓展"><a href="#多表查询分类及拓展" class="headerlink" title="多表查询分类及拓展"></a>多表查询分类及拓展</h3><p><strong>分类1：等值链接 vs 非等值连接</strong><br>等值连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT employees.employee_id, employees.last_name, </span><br><span class="line">       employees.department_id, departments.department_id,</span><br><span class="line">       departments.location_id</span><br><span class="line">FROM   employees, departments</span><br><span class="line">WHERE  employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure><p>非等值连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name, e.salary, j.grade_level</span><br><span class="line">FROM   employees e, job_grades j</span><br><span class="line">WHERE  e.salary BETWEEN j.lowest_sal AND j.highest_sal;</span><br></pre></td></tr></table></figure><p><strong>分类2：自连接 vs 非自连接</strong></p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/012.png" alt="img-012"></p><p>当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义，此时的多表查询类型为自连接。然后两个表可以再进行内连接，外连接等查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT(worker.last_name ,&#x27; works for &#x27; </span><br><span class="line">       , manager.last_name)</span><br><span class="line">FROM   employees worker, employees manager</span><br><span class="line">WHERE  worker.manager_id = manager.employee_id ;</span><br></pre></td></tr></table></figure><p><strong>分类3：内连接 vs外连接</strong></p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/013.png" alt="img-013"></p><ul><li>内连接: 合并具有同一列的两个以上的表的行, <strong>结果集中不包含一个表与另一个表不匹配的行</strong></li><li>外连接: 两个表在连接过程中除了返回满足连接条件的行以外<strong>还返回左（或右）表中不满足条件的行</strong> <strong>，这种连接称为左（或右） 外连接</strong>。没有匹配的行时, 结果表中相应的列为空(NULL)<ul><li>如果是左外连接，则连接条件中左边的表也称为<code>主表</code>，右边的表称为<code>从表</code></li><li>如果是右外连接，则连接条件中右边的表也称为<code>主表</code>，左边的表称为<code>从表</code></li></ul></li></ul><p><strong>拓展</strong><br>拓展1：多个连接条件时使用<strong>AND</strong>操作符<br>拓展2：使用表名前缀区分重复的列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT employees.last_name, departments.department_name,employees.department_id</span><br><span class="line">FROM employees, departments</span><br><span class="line">WHERE employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure><p>拓展3：使用表别名简化查询，提高查询效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.employee_id, e.last_name, e.department_id,</span><br><span class="line">       d.department_id, d.location_id</span><br><span class="line">FROM   employees e , departments d</span><br><span class="line">WHERE  e.department_id = d.department_id;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。</p></blockquote><blockquote><p><code>阿里开发规范</code>：</p><p>【<code>强制</code>】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或 表名）进行限定。 </p><p><code>说明</code>：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。 </p><p><code>正例</code>：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id; </p><p><code>反例</code>：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column  ‘name’ in field list is ambiguous。</p></blockquote><p>拓展4：连接n个表，至少需要n-1个连接条件</p><h3 id="SQL99语法实现多表查询"><a href="#SQL99语法实现多表查询" class="headerlink" title="SQL99语法实现多表查询"></a>SQL99语法实现多表查询</h3><ul><li>使用JOIN…ON子句创建连接的语法结构：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1.column, table2.column,table3.column</span><br><span class="line">FROM table1</span><br><span class="line">    JOIN table2 ON table1 和 table2 的连接条件</span><br><span class="line">    JOIN table3 ON table2 和 table3 的连接条件</span><br></pre></td></tr></table></figure></li></ul><p>嵌套逻辑类似 FOR 循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for t1 in table1:</span><br><span class="line">    for t2 in table2:</span><br><span class="line">       if condition1:</span><br><span class="line">           for t3 in table3:</span><br><span class="line">              if condition2:</span><br><span class="line">                  output t1 + t2 + t3</span><br></pre></td></tr></table></figure><p>SQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰</p><ul><li>语法说明：<ul><li><strong>可以使用 ON 子句指定额外的连接条件</strong></li><li>这个连接条件是与其它条件分开的</li><li><strong>ON 子句使语句具有更高的易读性</strong></li><li>关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接</li></ul></li></ul><h4 id="内连接-INNER-JOIN-的实现"><a href="#内连接-INNER-JOIN-的实现" class="headerlink" title="内连接(INNER JOIN)的实现"></a>内连接(INNER JOIN)的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 INNER JOIN B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br></pre></td></tr></table></figure><h4 id="外连接-OUTER-JOIN-的实现"><a href="#外连接-OUTER-JOIN-的实现" class="headerlink" title="外连接(OUTER JOIN)的实现"></a>外连接(OUTER JOIN)的实现</h4><h5 id="左外连接LEFT-OUTER-JOIN"><a href="#左外连接LEFT-OUTER-JOIN" class="headerlink" title="左外连接LEFT OUTER JOIN"></a>左外连接LEFT OUTER JOIN</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#实现查询结果是A</span><br><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 LEFT JOIN B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br></pre></td></tr></table></figure><h5 id="右外连接REIGHT-OUTER-JOIN"><a href="#右外连接REIGHT-OUTER-JOIN" class="headerlink" title="右外连接REIGHT OUTER JOIN"></a>右外连接REIGHT OUTER JOIN</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#实现查询结果是B</span><br><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 RIGHT JOIN B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br></pre></td></tr></table></figure><h5 id="满外连接FULL-OUTER-JOIN"><a href="#满外连接FULL-OUTER-JOIN" class="headerlink" title="满外连接FULL OUTER JOIN"></a>满外连接FULL OUTER JOIN</h5><ul><li>满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</li><li>SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。</li><li>需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN <strong>UNION</strong> RIGHT join代替</li></ul><h5 id="UNION的使用"><a href="#UNION的使用" class="headerlink" title="UNION的使用"></a>UNION的使用</h5><p><strong>合并查询结果</strong><br>利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column,... FROM table1</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT column,... FROM table2</span><br></pre></td></tr></table></figure><p><strong>UNION操作符</strong></p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/014.png" alt="img 014"></p><p>返回两个查询的结果集的并集，去除重复记录</p><p><strong>UNION ALL操作符</strong></p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/015.png" alt="img 015"></p><p>返回两个查询的结果集的并集，不去除重复记录</p><blockquote><p>执行UNION ALL所需要的资源比UNION语句少，如果名曲知道合并数据的结果不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，提高数据查询的效率</p></blockquote><p>举例1：查询部门编号&gt;90或邮箱包含a的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#方式1</span><br><span class="line">SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27; OR department_id&gt;90;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#方式2</span><br><span class="line">SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27;</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM employees WHERE department_id&gt;90;</span><br></pre></td></tr></table></figure><p>举例2：查询中国用户中男性的信息及美国用户中男性的用户信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, cname FROM t_chinamale WHERE csex=&#x27;男&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT id, tname FROM t_usmale WHERE tGender=&#x27;male&#x27;;</span><br></pre></td></tr></table></figure><h5 id="7种SQL-JOINS的实现"><a href="#7种SQL-JOINS的实现" class="headerlink" title="7种SQL JOINS的实现"></a>7种SQL JOINS的实现</h5><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/016.png" alt="img 016"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#中图：内连接 A∩B</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#左上图：左外连接</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e LEFT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#右上图：右外连接</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e RIGHT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#左中图：A - A∩B</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e LEFT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">WHERE d.`department_id` IS NULL</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#右中图：B-A∩B</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e RIGHT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">WHERE e.`department_id` IS NULL</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#左下图：满外连接</span><br><span class="line">#左中图 + 右上图  A∪B</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e LEFT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">WHERE d.`department_id` IS NULL</span><br><span class="line">UNION ALL  #没有去重操作，效率高</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e RIGHT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#右下图</span><br><span class="line">#左中图 + 右中图  A ∪B- A∩B 或者 (A -  A∩B) ∪ （B - A∩B）</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e LEFT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">WHERE d.`department_id` IS NULL</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e RIGHT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">WHERE e.`department_id` IS NULL</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li>左中图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#实现A -  A∩B</span><br><span class="line">select 字段列表</span><br><span class="line">from A表 left join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 从表关联字段 is null and 等其他子句;</span><br></pre></td></tr></table></figure><ul><li>右中图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#实现B -  A∩B</span><br><span class="line">select 字段列表</span><br><span class="line">from A表 right join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 从表关联字段 is null and 等其他子句;</span><br></pre></td></tr></table></figure><ul><li>左下图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#实现查询结果是A∪B</span><br><span class="line">#用左外的A，union 右外的B</span><br><span class="line">select 字段列表</span><br><span class="line">from A表 left join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 等其他子句</span><br><span class="line"></span><br><span class="line">union </span><br><span class="line"></span><br><span class="line">select 字段列表</span><br><span class="line">from A表 right join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 等其他子句;</span><br></pre></td></tr></table></figure><ul><li>右下图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#实现A∪B -  A∩B  或   (A -  A∩B) ∪ （B - A∩B）</span><br><span class="line">#使用左外的 (A -  A∩B)  union 右外的（B - A∩B）</span><br><span class="line">select 字段列表</span><br><span class="line">from A表 left join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 从表关联字段 is null and 等其他子句</span><br><span class="line"></span><br><span class="line">union</span><br><span class="line"></span><br><span class="line">select 字段列表</span><br><span class="line">from A表 right join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 从表关联字段 is null and 等其他子句</span><br></pre></td></tr></table></figure><h4 id="SQL99新特性"><a href="#SQL99新特性" class="headerlink" title="SQL99新特性"></a>SQL99新特性</h4><h5 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h5><p>SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 <code>NATURAL JOIN</code> 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中<code>所有相同的字段</code>，然后进行<code>等值连接</code>。</p><p>在SQL92标准中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">AND e.`manager_id` = d.`manager_id`;</span><br></pre></td></tr></table></figure><p>在 SQL99 中你可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e NATURAL JOIN departments d;</span><br></pre></td></tr></table></figure><h5 id="USING连接"><a href="#USING连接" class="headerlink" title="USING连接"></a>USING连接</h5><p>当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的<code>同名字段</code>进行等值连接。但是只能配合JOIN一起使用。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">USING (department_id);</span><br></pre></td></tr></table></figure><p>你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 <code>JOIN...USING</code> 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e ,departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br></pre></td></tr></table></figure><p><strong>小结</strong><br>表连接的约束条件可以有三种方式：WHERE, ON, USING</p><ul><li>WHERE：适用于所有关联查询</li><li>ON：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好</li><li>USING：只能和JOIN一起使用，而且要求<strong>两个</strong>关联字段在关联表中名称一致，而且只能表示关联字段值相等</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#关联条件</span><br><span class="line">#把关联条件写在where后面</span><br><span class="line">SELECT last_name,department_name </span><br><span class="line">FROM employees,departments </span><br><span class="line">WHERE employees.department_id = departments.department_id;</span><br><span class="line"></span><br><span class="line">#把关联条件写在on后面，只能和JOIN一起使用</span><br><span class="line">SELECT last_name,department_name </span><br><span class="line">FROM employees INNER JOIN departments </span><br><span class="line">ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name </span><br><span class="line">FROM employees CROSS JOIN departments </span><br><span class="line">ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name  </span><br><span class="line">FROM employees JOIN departments </span><br><span class="line">ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br><span class="line">#把关联字段写在using()中，只能和JOIN一起使用</span><br><span class="line">#而且两个表中的关联字段必须名称相同，而且只能表示=</span><br><span class="line">#查询员工姓名与基本工资</span><br><span class="line">SELECT last_name,job_title</span><br><span class="line">FROM employees INNER JOIN jobs USING(job_id);</span><br><span class="line"></span><br><span class="line">#n张表关联，需要n-1个关联条件</span><br><span class="line">#查询员工姓名，基本工资，部门名称</span><br><span class="line">SELECT last_name,job_title,department_name FROM employees,departments,jobs </span><br><span class="line">WHERE employees.department_id = departments.department_id </span><br><span class="line">AND employees.job_id = jobs.job_id;</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_title,department_name </span><br><span class="line">FROM employees INNER JOIN departments INNER JOIN jobs </span><br><span class="line">ON employees.department_id = departments.department_id </span><br><span class="line">AND employees.job_id = jobs.job_id;</span><br></pre></td></tr></table></figure><p>注意：我们要控制<strong>连接表的数量</strong>。多表连接就相当嵌套for循环一样，非常消耗资源，会让SQL的查询性能下降得很严重，因此不要连接不要的表。</p><blockquote><p>【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。<br>说明：即使双表 join 也要注意表索引、SQL 性能。<br>来源：阿里巴巴《Java开发手册》</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。</p><p>MySQL提供的内置函数从<code>实现的功能角度</code>可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类：<code>单行函数</code>、<code>聚合函数（或分组函数）</code>。</p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/017.png" alt="img 017"></p><h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><ul><li>操作数据对象</li><li>接受参数返回一个结果</li><li><strong>只对一行进行变换</strong></li><li><strong>每行返回一个结果</strong></li><li>可以嵌套</li><li>参数可以是一列或一个值</li></ul><h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><p><strong>基本函数</strong><br>| 函数                | 用法                                                         |<br>| ——————- | ———————————————————— |<br>| ABS(x)              | 返回x的绝对值                                                |<br>| SIGN(X)             | 返回X的符号。正数返回1，负数返回-1，0返回0                   |<br>| PI()                | 返回圆周率的值                                               |<br>| CEIL(x)，CEILING(x) | 返回大于或等于某个值的最小整数                               |<br>| FLOOR(x)            | 返回小于或等于某个值的最大整数                               |<br>| LEAST(e1,e2,e3…)    | 返回列表中的最小值                                           |<br>| GREATEST(e1,e2,e3…) | 返回列表中的最大值                                           |<br>| MOD(x,y)            | 返回X除以Y后的余数                                           |<br>| RAND()              | 返回0<del>1的随机值                                              |<br>| RAND(x)             | 返回0</del>1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数 |<br>| ROUND(x)            | 返回一个对x的值进行四舍五入后，最接近于X的整数               |<br>| ROUND(x,y)          | 返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位 |<br>| TRUNCATE(x,y)       | 返回数字x截断为y位小数的结果                                 |<br>| SQRT(x)             | 返回x的平方根。当X的值为负数时，返回NULL                     |</p><p><strong>角度与弧度互换函数</strong><br>| 函数       | 用法                                  |<br>| ———- | ————————————- |<br>| RADIANS(x) | 将角度转化为弧度，其中，参数x为角度值 |<br>| DEGREES(x) | 将弧度转化为角度，其中，参数x为弧度值 |</p><p><strong>三角函数</strong><br>| 函数       | 用法                                                         |<br>| ———- | ———————————————————— |<br>| SIN(x)     | 返回x的正弦值，其中，参数x为弧度值                           |<br>| ASIN(x)    | 返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL |<br>| COS(x)     | 返回x的余弦值，其中，参数x为弧度值                           |<br>| ACOS(x)    | 返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL |<br>| TAN(x)     | 返回x的正切值，其中，参数x为弧度值                           |<br>| ATAN(x)    | 返回x的反正切值，即返回正切值为x的值                         |<br>| ATAN2(m,n) | 返回两个参数的反正切值                                       |<br>| COT(x)     | 返回x的余切值，其中，X为弧度值                               |</p><p><strong>指数与对数</strong><br>| 函数                 | 用法                                                 |<br>| ——————– | —————————————————- |<br>| POW(x,y)，POWER(X,Y) | 返回x的y次方                                         |<br>| EXP(X)               | 返回e的X次方，其中e是一个常数，2.718281828459045     |<br>| LN(X)，LOG(X)        | 返回以e为底的X的对数，当X &lt;= 0 时，返回的结果为NULL  |<br>| LOG10(X)             | 返回以10为底的X的对数，当X &lt;= 0 时，返回的结果为NULL |<br>| LOG2(X)              | 返回以2为底的X的对数，当X &lt;= 0 时，返回NULL        |</p><p><strong>进制转换</strong><br>| 函数                 | 用法                                                 |<br>| ——————– | —————————————————- |<br>| POW(x,y)，POWER(X,Y) | 返回x的y次方                                         |<br>| EXP(X)               | 返回e的X次方，其中e是一个常数，2.718281828459045     |<br>| LN(X)，LOG(X)        | 返回以e为底的X的对数，当X &lt;= 0 时，返回的结果为NULL  |<br>| LOG10(X)             | 返回以10为底的X的对数，当X &lt;= 0 时，返回的结果为NULL |<br>| LOG2(X)              | 返回以2为底的X的对数，当X &lt;= 0 时，返回NULL        |</p><p><strong>字符串函数</strong><br>| 函数                              | 用法                                                         |<br>| ——————————— | ———————————————————— |<br>| ASCII(S)                          | 返回字符串S中的第一个字符的ASCII码值                         |<br>| CHAR_LENGTH(s)                    | 返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同           |<br>| LENGTH(s)                         | 返回字符串s的字节数，和字符集有关                            |<br>| CONCAT(s1,s2,……,sn)           | 连接s1,s2,……,sn为一个字符串                              |<br>| CONCAT_WS(x, s1,s2,……,sn)     | 同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x           |<br>| INSERT(str, idx, len, replacestr) | 将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr |<br>| REPLACE(str, a, b)                | 用字符串b替换字符串str中所有出现的字符串a                    |<br>| UPPER(s) 或 UCASE(s)              | 将字符串s的所有字母转成大写字母                              |<br>| LOWER(s)  或LCASE(s)              | 将字符串s的所有字母转成小写字母                              |<br>| LEFT(str,n)                       | 返回字符串str最左边的n个字符                                 |<br>| RIGHT(str,n)                      | 返回字符串str最右边的n个字符                                 |<br>| LPAD(str, len, pad)               | 用字符串pad对str最左边进行填充，直到str的长度为len个字符     |<br>| RPAD(str ,len, pad)               | 用字符串pad对str最右边进行填充，直到str的长度为len个字符     |<br>| LTRIM(s)                          | 去掉字符串s左侧的空格                                        |<br>| RTRIM(s)                          | 去掉字符串s右侧的空格                                        |<br>| TRIM(s)                           | 去掉字符串s开始与结尾的空格                                  |<br>| TRIM(s1 FROM s)                   | 去掉字符串s开始与结尾的s1                                    |<br>| TRIM(LEADING s1 FROM s)           | 去掉字符串s开始处的s1                                        |<br>| TRIM(TRAILING s1 FROM s)          | 去掉字符串s结尾处的s1                                        |<br>| REPEAT(str, n)                    | 返回str重复n次的结果                                         |<br>| SPACE(n)                          | 返回n个空格                                                  |<br>| STRCMP(s1,s2)                     | 比较字符串s1,s2的ASCII码值的大小                             |<br>| SUBSTR(s,index,len)               | 返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同 |<br>| LOCATE(substr,str)                | 返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0 |<br>| ELT(m,s1,s2,…,sn)                 | 返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn |<br>| FIELD(s,s1,s2,…,sn)               | 返回字符串s在字符串列表中第一次出现的位置                    |<br>| FIND_IN_SET(s1,s2)                | 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串 |<br>| REVERSE(s)                        | 返回s反转后的字符串                                          |<br>| NULLIF(value1,value2)             | 比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1 |</p><blockquote><p>注意：MySQL中，字符串的位置是从1开始的。</p></blockquote><p><strong>日期时间函数</strong><br>| 函数                                                         | 用法                           |<br>| ———————————————————— | —————————— |<br>| <strong>CURDATE()</strong> ，CURRENT_DATE()   | 返回当前日期，只包含年、月、日   |<br>| <strong>CURTIME()</strong> ， CURRENT_TIME()    | 返回当前时间，只包含时、分、秒 |<br>| <strong>NOW()</strong> / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP() | 返回当前系统日期和时间         |<br>| UTC_DATE()             | 返回UTC（世界标准时间）日期    |<br>| UTC_TIME()             | 返回UTC（世界标准时间）时间    |<br>| UNIX_TIMESTAMP()         | 以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() -&gt;1634348884 |<br>| UNIX_TIMESTAMP(date)     | 将时间date以UNIX时间戳的形式返回          |<br>| FROM_UNIXTIME(timestamp) | 将UNIX时间戳的时间转换为普通格式的时间      |<br>| YEAR(date) / MONTH(date) / DAY(date)     | 返回具体的日期值         |<br>| HOUR(time) / MINUTE(time) / SECOND(time) | 返回具体的时间值   |<br>| MONTHNAME(date)                          | 返回月份：January，…      |<br>| DAYNAME(date)            | 返回星期几：MONDAY，TUESDAY…..SUNDAY       |<br>| WEEKDAY(date)         | 返回周几，注意，周1是0，周2是1，。。。周日是6   |<br>| QUARTER(date)                | 返回日期对应的季度，范围为1～4           |<br>| WEEK(date) ， WEEKOFYEAR(date)           | 返回一年中的第几周     |<br>| DAYOFYEAR(date)                          | 返回日期是一年中的第几天     |<br>| DAYOFMONTH(date)                         | 返回日期位于所在月份的第几天   |<br>| DAYOFWEEK(date)         | 返回周几，注意：周日是1，周一是2，。。。周六是7 |<br>| EXTRACT(type FROM date) | 返回指定日期中特定的部分，type指定返回的值 |<br>| TIME_TO_SEC(time)    | 将 time 转化为秒并返回结果值。转化的公式为：<code>小时*3600+分钟*60+秒</code> |<br>| SEC_TO_TIME(seconds) | 将 seconds 描述转化为包含小时、分钟和秒的时间     |<br>| DATE_ADD(datetime, INTERVAL  expr type)，ADDDATE(date,INTERVAL expr type) | 返回与给定日期时间相差INTERVAL时间段的日期时间 |<br>| DATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr type) | 返回与date相差INTERVAL时间间隔的日期           |<br>| ADDTIME(time1,time2)         | 返回time1加上time2的时间。当time2为一个数字时，代表的是<code>秒</code>，可以为负数 |<br>| SUBTIME(time1,time2)         | 返回time1减去time2后的时间。当time2为一个数字时，代表的是<code>秒</code>，可以为负数 |<br>| DATEDIFF(date1,date2)        | 返回date1 - date2的日期间隔天数        |<br>| TIMEDIFF(time1, time2)       | 返回time1 - time2的时间间隔         |<br>| FROM_DAYS(N)                 | 返回从0000年1月1日起，N天以后的日期     |<br>| TO_DAYS(date)                | 返回日期date距离0000年1月1日的天数     |<br>| LAST_DAY(date)               | 返回date所在月份的最后一天的日期       |<br>| MAKEDATE(year,n)             | 针对给定年份与所在年份中的天数返回一个日期   |<br>| MAKETIME(hour,minute,second) | 将给定的小时、分钟和秒组合成时间并返回       |<br>| PERIOD_ADD(time,n)           | 返回time加上n后的时间                 |<br>| DATE_FORMAT(date,fmt)             | 按照字符串fmt格式化日期date值      |<br>| TIME_FORMAT(time,fmt)             | 按照字符串fmt格式化时间time值      |<br>| GET_FORMAT(date_type,format_type) | 返回日期字符串的显示格式            |<br>| STR_TO_DATE(str, fmt)             | 按照字符串fmt对str进行解析，解析为一个日期 |</p><p>EXTRACT(type FROM date)函数中type的取值与含义：<br><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/018.png" alt="img-018"><br><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/019.png" alt="img-019"></p><p>GET_FORMAT函数中date_type和format_type参数取值如下：<br><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/020.png" alt="img-010"></p><p><strong>流程控制函数</strong><br>流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。<br>| 函数                                                         | 用法   |<br>| ———————————————————— | ———————————————– |<br>| IF(value,value1,value2)                                      | 如果value的值为TRUE，返回value1，否则返回value2 |<br>| IFNULL(value1, value2)                                       | 如果value1不为NULL，返回value1，否则返回value2  |<br>| CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 …. [ELSE resultn] END | 相当于Java的if…else if…else…              |<br>| CASE  expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END | 相当于Java的switch…case…                    |</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT IF(1 &gt; 0,&#x27;正确&#x27;,&#x27;错误&#x27;)    </span><br><span class="line">-&gt;正确</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT IFNULL(null,&#x27;Hello Word&#x27;)</span><br><span class="line">-&gt;Hello Word</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT CASE </span><br><span class="line">　　WHEN 1 &gt; 0</span><br><span class="line">　　THEN &#x27;1 &gt; 0&#x27;</span><br><span class="line">　　WHEN 2 &gt; 0</span><br><span class="line">　　THEN &#x27;2 &gt; 0&#x27;</span><br><span class="line">　　ELSE &#x27;3 &gt; 0&#x27;</span><br><span class="line">　　END</span><br><span class="line">-&gt;1 &gt; 0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT CASE 1 </span><br><span class="line">　　WHEN 1 THEN &#x27;我是1&#x27;</span><br><span class="line">　　WHEN 2 THEN &#x27;我是2&#x27;</span><br><span class="line">ELSE &#x27;你是谁&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,salary, CASE WHEN salary&gt;=15000 THEN &#x27;高薪&#x27; </span><br><span class="line">  WHEN salary&gt;=10000 THEN &#x27;潜力股&#x27;  </span><br><span class="line">  WHEN salary&gt;=8000 THEN &#x27;屌丝&#x27; </span><br><span class="line">  ELSE &#x27;草根&#x27; END  &quot;描述&quot;</span><br><span class="line">FROM employees; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT oid,`status`, CASE `status` WHEN 1 THEN &#x27;未付款&#x27; </span><br><span class="line">   WHEN 2 THEN &#x27;已付款&#x27; </span><br><span class="line">   WHEN 3 THEN &#x27;已发货&#x27;  </span><br><span class="line">   WHEN 4 THEN &#x27;确认收货&#x27;  </span><br><span class="line">   ELSE &#x27;无效订单&#x27; END </span><br><span class="line">FROM t_order;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT CASE WHEN 1 &gt; 0 THEN &#x27;yes&#x27; WHEN 1 &lt;= 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END;</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">| CASE WHEN 1 &gt; 0 THEN &#x27;yes&#x27; WHEN 1 &lt;= 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END |</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">| yes                                                                  |</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT CASE WHEN 1 &lt; 0 THEN &#x27;yes&#x27; WHEN 1 = 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END;  </span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">| CASE WHEN 1 &lt; 0 THEN &#x27;yes&#x27; WHEN 1 = 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">| unknown                                                             |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">| CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">|                                               1 |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">| CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">|                                               -1 |</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,12 * salary * (1 + IFNULL(commission_pct,0))</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name, job_id, salary,</span><br><span class="line">       CASE job_id WHEN &#x27;IT_PROG&#x27;  THEN  1.10*salary</span><br><span class="line">                   WHEN &#x27;ST_CLERK&#x27; THEN  1.15*salary</span><br><span class="line">                   WHEN &#x27;SA_REP&#x27;   THEN  1.20*salary</span><br><span class="line">          ELSE      salary END     &quot;REVISED_SALARY&quot;</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure><p><strong>加密、解密函数</strong><br>加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>PASSWORD(str)</td><td>返回字符串str的加密版本，41位长的字符串。加密结果<code>不可逆</code>，常用于用户的密码加密</td></tr><tr><td>MD5(str)</td><td>返回字符串str的md5加密后的值，也是一种加密方式。若参数为NULL，则会返回NULL</td></tr><tr><td>SHA(str)</td><td>从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。<code>SHA加密算法比MD5更加安全</code>。</td></tr><tr><td>ENCODE(value,password_seed)</td><td>返回使用password_seed作为加密密码加密value</td></tr><tr><td>DECODE(value,password_seed)</td><td>返回使用password_seed作为加密密码解密value</td></tr></tbody></table><p>可以看到，ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数。</p><p><strong>Mysql信息函数</strong><br>MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>VERSION()</td><td>返回当前MySQL的版本号</td></tr><tr><td>CONNECTION_ID()</td><td>返回当前MySQL服务器的连接数</td></tr><tr><td>DATABASE()，SCHEMA()</td><td>返回MySQL命令行当前所在的数据库</td></tr><tr><td>USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()</td><td>返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”</td></tr><tr><td>CHARSET(value)</td><td>返回字符串value自变量的字符集</td></tr><tr><td>COLLATION(value)</td><td>返回字符串value的比较规则</td></tr></tbody></table><p><strong>其他函数</strong><br>MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视的。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>FORMAT(value,n)</td><td>返回对数字value进行格式化后的结果数据。n表示<code>四舍五入</code>后保留到小数点后n位</td></tr><tr><td>CONV(value,from,to)</td><td>将value的值进行不同进制之间的转换</td></tr><tr><td>INET_ATON(ipvalue)</td><td>将以点分隔的IP地址转化为一个数字</td></tr><tr><td>INET_NTOA(value)</td><td>将数字形式的IP地址转化为以点分隔的IP地址</td></tr><tr><td>BENCHMARK(n,expr)</td><td>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</td></tr><tr><td>CONVERT(value USING char_code)</td><td>将value所使用的字符编码修改为char_code</td></tr></tbody></table><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>聚合函数作用于一组数据，并对一组数据返回一个值。</p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/021.png" alt="img-021"></p><p>聚合函数类型：</p><ul><li>AVG()</li><li>SUM()</li><li>MAX()</li><li>MIN()</li><li>COUNT()</li></ul><p>聚合函数语法：</p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/022.png" alt="img-022"></p><p>PS：聚合函数不能嵌套使用！</p><p><strong>AVG和SUM函数</strong><br>对数值类型的数据求<strong>平均值和总和</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(salary), MAX(salary), MIN(salary), SUM(salary)</span><br><span class="line">FROM emloyees</span><br><span class="line">WHERE job_id LIKE &#x27;%REP%&#x27;;</span><br></pre></td></tr></table></figure><p><strong>MIN和MAX函数</strong><br>可以对任意类型的数据使用，求其<strong>最大值或最小值</strong></p><p><strong>COUNT函数</strong></p><ul><li> COUNT(*)返回表中记录总数，适用于任意数据类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM  employees</span><br><span class="line">WHERE  department_id = 50;</span><br></pre></td></tr></table></figure></li><li>COUNT(expr)返回<code>expr</code>不为空的记录总数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(commission_pct)</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  department_id = 50;</span><br></pre></td></tr></table></figure></li></ul><p><strong>QA：用count(<em>)，count(1)，count(列名)统计记录数量谁好呢</em></strong></p><ul><li>对于MyISAM引擎的表是没有区别的，这种引擎内部有一计数器在维护着行数</li><li>Innodb引擎的表用count(*)，count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)</li></ul><p><strong>QA：能不能使用count(列名)替换count(*)</strong><br>不要使用 count(列名)来替代 <code>count(*)</code>，<code>count(*)</code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br>PS：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行</p><h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/023.png" alt="img-023"></p><p>可使用GROUP BY将表中的数据分成若干组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column, group_function(column)</span><br><span class="line">FROM table</span><br><span class="line">[WHEREcondition]</span><br><span class="line">[GROUP BYgroup_by_expression]</span><br><span class="line">[ORDER BYcolumn];</span><br></pre></td></tr></table></figure><p>PS：</p><ul><li>SELECT列表中所有未包含在组函数中的列都应该包含在<strong>GROUP BY</strong>子句中</li><li>包含在<strong>GROUP BY</strong>子句中的列不必包含在SELECT列表中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT   department_id, AVG(salary)</span><br><span class="line">FROM     employees</span><br><span class="line">GROUP BY department_id ;</span><br></pre></td></tr></table></figure></li></ul><p>可以使用多个列名进行分组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT   department_id dept_id, job_id, SUM(salary)</span><br><span class="line">FROM     employees</span><br><span class="line">GROUP BY department_id, job_id ;</span><br></pre></td></tr></table></figure><p><strong>使用WITH ROLLUP</strong><br>使用<code>WITH ROLLUP</code>关键字后，在所欲查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id,AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id &gt; 80</span><br><span class="line">GROUP BY department_id WITH ROLLUP;</span><br></pre></td></tr></table></figure><blockquote><p>PS：<br>当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互斥的</p></blockquote><h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/024.png" alt="img-024"></p><p><strong>过滤分组：HAVING</strong></p><ul><li>行已经被分组</li><li>使用了聚合函数</li><li>满足HAVING子句中条件的分组将被显示</li><li>HAVNG不能单独使用，必须要跟GROUP BY一起使用</li></ul><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/025.png" alt="img-025"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT   department_id, MAX(salary)</span><br><span class="line">FROM     employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING   MAX(salary)&gt;10000 ;</span><br></pre></td></tr></table></figure><blockquote><p>PS：</p><p>不能再WHERE子句中使用聚合函数</p></blockquote><p><strong>WHERE和HAVING的对比</strong></p><ol><li><p>WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。 </p><blockquote><p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。</p></blockquote></li><li><p>如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。</p><blockquote><p>这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。 </p></blockquote></li></ol><p>小结如下：<br>|        | 优点                         | 缺点                          |<br>| —— | —————————- | ————————————– |<br>| WHERE  | 先筛选数据再关联，执行效率高 | 不能使用分组中的计算函数进行筛选       |<br>| HAVING | 可以使用分组中的计算函数     | 在最后的结果集中进行筛选，执行效率较低 |</p><p>开发中的选择：<br>WHERE 和 HAVING 不是互相排斥的，可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p><h2 id="SELECT执行过程"><a href="#SELECT执行过程" class="headerlink" title="SELECT执行过程"></a>SELECT执行过程</h2><h3 id="查询结构"><a href="#查询结构" class="headerlink" title="查询结构"></a>查询结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#方式1：</span><br><span class="line">SELECT ...,....,...</span><br><span class="line">FROM ...,...,....</span><br><span class="line">WHERE 多表的连接条件</span><br><span class="line">AND 不包含组函数的过滤条件</span><br><span class="line">GROUP BY ...,...</span><br><span class="line">HAVING 包含组函数的过滤条件</span><br><span class="line">ORDER BY ... ASC/DESC</span><br><span class="line">LIMIT ...,...</span><br><span class="line"></span><br><span class="line">#方式2：</span><br><span class="line">SELECT ...,....,...</span><br><span class="line">FROM ... JOIN ... </span><br><span class="line">ON 多表的连接条件</span><br><span class="line">JOIN ...</span><br><span class="line">ON ...</span><br><span class="line">WHERE 不包含组函数的过滤条件</span><br><span class="line">AND/OR 不包含组函数的过滤条件</span><br><span class="line">GROUP BY ...,...</span><br><span class="line">HAVING 包含组函数的过滤条件</span><br><span class="line">ORDER BY ... ASC/DESC</span><br><span class="line">LIMIT ...,...</span><br><span class="line"></span><br><span class="line">#其中：</span><br><span class="line">#（1）from：从哪些表中筛选</span><br><span class="line">#（2）on：关联多表查询时，去除笛卡尔积</span><br><span class="line">#（3）where：从表中筛选的条件</span><br><span class="line">#（4）group by：分组依据</span><br><span class="line">#（5）having：在统计结果中再次筛选</span><br><span class="line">#（6）order by：排序</span><br><span class="line">#（7）limit：分页</span><br></pre></td></tr></table></figure><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>SELECT查询时的两个顺序</p><ol><li><p>关键字的顺序不能颠倒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT</span><br></pre></td></tr></table></figure></li><li><p>SELECT语句的执行顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</span><br></pre></td></tr></table></figure></li></ol><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/026.png" alt="img-026"></p><p>SQL举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5</span><br><span class="line">FROM player JOIN team ON player.team_id = team.team_id # 顺序 1</span><br><span class="line">WHERE height &gt; 1.80 # 顺序 2</span><br><span class="line">GROUP BY player.team_id # 顺序 3</span><br><span class="line">HAVING num &gt; 2 # 顺序 4</span><br><span class="line">ORDER BY num DESC # 顺序 6</span><br><span class="line">LIMIT 2 # 顺序 7</span><br></pre></td></tr></table></figure><blockquote><p>在SELECT语句执行这些步骤的时候，每一步都会产生一个<code>虚拟表</code>，然后将这个<code>虚拟表</code>插入下一步中作为输入。这些步骤隐含在SQL的执行过程中，对于我们是不可见的。</p></blockquote><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p><ol><li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li><li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li><li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li></ol><p>如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</p><p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 <code>vt1</code>，就可以在此基础上再进行 <code>WHERE 阶段</code>。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 <code>vt2</code>。</p><p>然后进入第三步和第四步，也就是 <code>GROUP 和 HAVING 阶段</code>。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表 <code>vt3</code> 和 <code>vt4</code>。</p><p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 <code>SELECT 和 DISTINCT 阶段</code>。</p><p>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 <code>vt5-1</code> 和 <code>vt5-2</code>。</p><p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 <code>ORDER BY 阶段</code>，得到虚拟表 <code>vt6</code>。</p><p>最后在 vt6 的基础上，取出指定行的记录，也就是 <code>LIMIT 阶段</code>，得到最终的结果，对应的是虚拟表 <code>vt7</code>。</p><p>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p><p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的关键字顺序，<strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序。</strong></p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>即查询语句的嵌套。</p><h3 id="基本使用与分类"><a href="#基本使用与分类" class="headerlink" title="基本使用与分类"></a>基本使用与分类</h3><p>基本语法：</p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/027.png" alt="img-027"></p><ul><li>子查询在主查询之前执行完成</li><li>子查询的结果被主查询使用<blockquote><p>PS：<br>子查询要包含在括号内<br>将子查询放在比较条件的右侧<br>单行操作符对应单行子查询，多行操作符对应多行子查询</p></blockquote></li></ul><p><strong>子查询分类</strong></p><ul><li>分类一：<ul><li>单行子查询</li><li>多行子查询</li></ul></li><li>分类二：<ul><li>相关（关联）子查询</li><li>不相关（非关联）子查询</li></ul></li></ul><h3 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h3><p>单行比较操作符<br>| 操作符 | 含义                     |<br>| —— | ———————— |<br>| =      | equal to                 |<br>| &gt;      | greater than             |<br>| &gt;=     | greater than or equal to |<br>| &lt;      | less than                |<br>| &lt;=     | less than or equal to    |<br>| &lt;&gt;     | not equal to             |</p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/028.png" alt="img-028"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name, job_id, salary</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  job_id =  </span><br><span class="line">                (SELECT job_id</span><br><span class="line">                 FROM   employees</span><br><span class="line">                 WHERE  employee_id = 141)</span><br><span class="line">AND    salary &gt;</span><br><span class="line">                (SELECT salary</span><br><span class="line">                 FROM   employees</span><br><span class="line">                 WHERE  employee_id = 143);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name, job_id, salary</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  salary = </span><br><span class="line">                (SELECT MIN(salary)</span><br><span class="line">                 FROM   employees);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#写法一</span><br><span class="line">SELECT  employee_id, manager_id, department_id</span><br><span class="line">FROM    employees</span><br><span class="line">WHERE   manager_id IN</span><br><span class="line">  (SELECT  manager_id</span><br><span class="line">                   FROM    employees</span><br><span class="line">                   WHERE   employee_id IN (174,141))</span><br><span class="line">AND     department_id IN </span><br><span class="line">  (SELECT  department_id</span><br><span class="line">                   FROM    employees</span><br><span class="line">                   WHERE   employee_id IN (174,141))</span><br><span class="line">ANDemployee_id NOT IN(174,141);</span><br><span class="line"></span><br><span class="line">#写法二</span><br><span class="line">SELECTemployee_id, manager_id, department_id</span><br><span class="line">FROMemployees</span><br><span class="line">WHERE  (manager_id, department_id) IN</span><br><span class="line">                      (SELECT manager_id, department_id</span><br><span class="line">                       FROM   employees</span><br><span class="line">                       WHERE  employee_id IN (141,174))</span><br><span class="line">ANDemployee_id NOT IN (141,174);</span><br></pre></td></tr></table></figure><p><strong>HAVING中子查询</strong></p><ul><li>首先执行子查询</li><li>向主查询中的HAVING子句返回结果</li></ul><p>EG：查询最低工资大于50号部门最低工资的部门id和其最低工资</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT   department_id, MIN(salary)</span><br><span class="line">FROM     employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING   MIN(salary) &gt;</span><br><span class="line">                       (SELECT MIN(salary)</span><br><span class="line">                        FROM   employees</span><br><span class="line">                        WHERE  department_id = 50);</span><br></pre></td></tr></table></figure><p><strong>CASE中子查询</strong><br>在CASE表达式中使用<code>单列</code>子查询</p><p>EG：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id, last_name,</span><br><span class="line">       (CASE department_id</span><br><span class="line">        WHEN</span><br><span class="line">             (SELECT department_id FROM departments</span><br><span class="line">      WHERE location_id = 1800)           </span><br><span class="line">        THEN &#x27;Canada&#x27; ELSE &#x27;USA&#x27; END) location</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure><p><strong>子查询空值问题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name, job_id</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  job_id =</span><br><span class="line">                (SELECT job_id</span><br><span class="line">                 FROM   employees</span><br><span class="line">                 WHERE  last_name = &#x27;Haas&#x27;);</span><br></pre></td></tr></table></figure><p>子查询结果为空值时，此时子查询不返回任何行</p><p><strong>非法使用子查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id, last_name</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  salary =</span><br><span class="line">                (SELECT   MIN(salary)</span><br><span class="line">                 FROM     employees</span><br><span class="line">                 GROUP BY department_id);</span><br></pre></td></tr></table></figure><p>错误原因：子查询类型为多行子查询却使用单行比较符<code>=</code></p><h3 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h3><ul><li>也称集合比较子查询</li><li>子查询返回多行</li><li>使用多行比较操作符</li></ul><p>多行比较操作符<br>| 操作符 | 含义                                                         |<br>| —— | ———————————————————- |<br>| IN     | 等于列表中的<strong>任意一个</strong>                                     |<br>| ANY    | 需要和单行比较操作符一起使用，和子查询返回的<strong>某一个</strong>值比较 |<br>| ALL    | 需要和单行比较操作符一起使用，和子查询返回的<strong>所有</strong>值比较   |<br>| SOME   | 实际上是ANY的别名，作用相同，一般常使用ANY                   |</p><blockquote><p>体会 ANY 和 ALL 的区别</p></blockquote><p>EG：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary</p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/029.png" alt="img-029"></p><p>EG：返回其它job_id中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id以及salary</p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/030.png" alt="img-030"></p><p>EG：查询平均工资最低的部门id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#方式1：</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) = (</span><br><span class="line">SELECT MIN(avg_sal)</span><br><span class="line">FROM (</span><br><span class="line">SELECT AVG(salary) avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">) dept_avg_sal</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#方式2：</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) &lt;= ALL (</span><br><span class="line">SELECT AVG(salary) avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>空值问题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id NOT IN (</span><br><span class="line">SELECT manager_id</span><br><span class="line">FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>同单行子查询，查询为空时不返回任何行</p><h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为<code>关联子查询</code></p><p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询</p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/031.png" alt="img-031"></p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/032.png" alt="img-032"></p><blockquote><p>子查询中使用主查询中的列</p></blockquote><p>EG：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id<br>方式一：相关子查询</p><p><img src="/./Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/033.png" alt="img-033"></p><p>方式二：在FROM中使用子查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,salary,e1.department_id</span><br><span class="line">FROM employees e1,(SELECT department_id,AVG(salary) dept_avg_sal FROM employees GROUP BY department_id) e2</span><br><span class="line">WHERE e1.`department_id` = e2.department_id</span><br><span class="line">AND e2.dept_avg_sal &lt; e1.`salary`;</span><br></pre></td></tr></table></figure><blockquote><p>FROM型的子查询：子查询是作为FROM的一部分，子查询要用（）引起来，并且要给这个子查询取别名，把它当成一个<code>临时的虚拟的表</code>使用</p></blockquote><p><strong>在ORDER BY中使用子查询</strong><br>EG：查询员工的id,salary,按照department_name 排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,salary</span><br><span class="line">FROM employees e</span><br><span class="line">ORDER BY (</span><br><span class="line">  SELECT department_name</span><br><span class="line">  FROM departments d</span><br><span class="line">  WHERE e.`department_id` = d.`department_id`</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>EG：若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同id的员工的employee_id,last_name和其job_id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.employee_id, last_name,e.job_id</span><br><span class="line">FROM   employees e </span><br><span class="line">WHERE  2 &lt;= (SELECT COUNT(*)</span><br><span class="line">             FROM   job_history </span><br><span class="line">             WHERE  employee_id = e.employee_id);</span><br></pre></td></tr></table></figure><p><strong>EXISTS 与NOT EXISTS关键字</strong></p><ul><li>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行</li><li>如果子查询中不存在满足条件的行：<ul><li>条件返回 FALSE</li><li>继续在子查询中查找</li></ul></li><li>如果在子查询中存在满足条件的行：<ul><li>不在子查询中继续查找</li><li>条件返回 TRUE</li></ul></li><li>NOT EXISTS关键字表示不存在某种条件，则返回TRUE，否则返回FALSE</li></ul><p>EG：查询公司管理者的employee_id，last_name，job_id，department_id信息<br>方式一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id, last_name, job_id, department_id</span><br><span class="line">FROM   employees e1</span><br><span class="line">WHERE  EXISTS ( SELECT *</span><br><span class="line">                 FROM   employees e2</span><br><span class="line">                 WHERE  e2.manager_id = </span><br><span class="line">                        e1.employee_id);</span><br></pre></td></tr></table></figure><p>方式二：自连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT e1.employee_id, e1.last_name, e1.job_id, e1.department_id</span><br><span class="line">FROM   employees e1 JOIN employees e2</span><br><span class="line">WHERE e1.employee_id = e2.manager_id;</span><br></pre></td></tr></table></figure><p>方式三：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,job_id,department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id IN (</span><br><span class="line">     SELECT DISTINCT manager_id</span><br><span class="line">     FROM employees</span><br><span class="line">     </span><br><span class="line">     );</span><br></pre></td></tr></table></figure><p>EG：查询departments表中，不存在于employees表中的部门的department_id和department_name</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id, department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE NOT EXISTS (SELECT &#x27;X&#x27;</span><br><span class="line">                  FROM   employees</span><br><span class="line">                  WHERE  department_id = d.department_id);</span><br></pre></td></tr></table></figure><p><strong>相关更新</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table1 alias1</span><br><span class="line"><span class="keyword">SET</span>    <span class="keyword">column</span> <span class="operator">=</span> (<span class="keyword">SELECT</span> expression</span><br><span class="line">                 <span class="keyword">FROM</span>   table2 alias2</span><br><span class="line">                 <span class="keyword">WHERE</span>  alias1.column <span class="operator">=</span> alias2.column);</span><br></pre></td></tr></table></figure><p>使用相关子查询依据一个表中的数据更新另一个表的数据。</p><p>EG：在employees中增加一个department_name字段，数据为员工对应的部门名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1）</span><br><span class="line">ALTER TABLE employees</span><br><span class="line">ADD(department_name VARCHAR2(14));</span><br><span class="line"></span><br><span class="line"># 2）</span><br><span class="line">UPDATE employees e</span><br><span class="line">SET department_name =  (SELECT department_name </span><br><span class="line">                       FROM   departments d</span><br><span class="line">                       WHERE  e.department_id = d.department_id);</span><br></pre></td></tr></table></figure><p><strong>相关删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table1 alias1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> operator (<span class="keyword">SELECT</span> expression</span><br><span class="line">                       <span class="keyword">FROM</span>   table2 alias2</span><br><span class="line">                       <span class="keyword">WHERE</span>  alias1.column <span class="operator">=</span> alias2.column);</span><br></pre></td></tr></table></figure><p>使用相关子查询依据一个表中的数据删除另一个表的数据。</p><p>EG：删除表employees中，其与emp_history表皆有的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">in</span>  </span><br><span class="line">           (<span class="keyword">SELECT</span> employee_id</span><br><span class="line">            <span class="keyword">FROM</span>   emp_history </span><br><span class="line">            <span class="keyword">WHERE</span>  employee_id <span class="operator">=</span> e.employee_id);</span><br></pre></td></tr></table></figure><p><strong>思考题</strong></p><p>QA：谁的工资比Abel的高？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#方式1：自连接</span><br><span class="line">SELECT e2.last_name,e2.salary</span><br><span class="line">FROM employees e1,employees e2</span><br><span class="line">WHERE e1.last_name = &#x27;Abel&#x27;</span><br><span class="line">AND e1.`salary` &lt; e2.`salary`</span><br><span class="line"></span><br><span class="line">#方式2：子查询</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &#x27;Abel&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>QA：以上两种方式有好坏之分吗？<br>自连接方式好</p><p>题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多</p><p>可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化</p><h1 id="表创建与管理"><a href="#表创建与管理" class="headerlink" title="表创建与管理"></a>表创建与管理</h1><h2 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h2><ul><li>数据库名、表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含 A–Z, a–z, 0–9, <code>_</code>共63个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用（着重号）引起来</li><li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、**INT(或INTEGER)**、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td><strong>DECIMAL</strong></td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、<strong>DATE</strong>、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、<strong>VARCHAR</strong>、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值：GEOMETRY、POINT、LINESTRING、POLYGON；<br/>集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table><p>常用几种数据类型：<br>| 数据类型      | 描述                                                         |<br>| ————- | ———————————————————— |<br>| INT           | 从-2^31到2^31-1的整型数据。存储大小为 4个字节          |<br>| CHAR(size)    | 定长字符数据。若未指定，默认为1个字符，最大长度255           |<br>| VARCHAR(size) | 可变长字符数据，根据字符串实际长度保存，<strong>必须指定长度</strong>     |<br>| FLOAT(M,D)    | 单精度，占用4个字节，M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=6 |<br>| DOUBLE(M,D)   | 双精度，占用8个字节，D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=15     |<br>| DECIMAL(M,D)  | 高精度小数，占用M+2个字节，D&lt;=M&lt;=65，0&lt;=D&lt;=30，最大取值范围与DOUBLE相同。 |<br>| DATE          | 日期型数据，格式’YYYY-MM-DD’                         |<br>| BLOB          | 二进制形式的长文本数据，最大可达4G                      |<br>| TEXT          | 长文本数据，最大可达4G      |</p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><ul><li><p>方式1：创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名; </span><br></pre></td></tr></table></figure></li><li><p>方式2：创建数据库并指定字符集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名 CHARACTER SET 字符集;</span><br></pre></td></tr></table></figure></li><li><p>方式3：判断数据库是否已经存在，不存在则创建数据库（<code>推荐</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS 数据库名; </span><br></pre></td></tr></table></figure></li></ul><p>如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p><blockquote><p>注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。</p></blockquote><h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><ul><li><p>查看当前所有的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES; #有一个S，代表多个数据库</span><br></pre></td></tr></table></figure></li><li><p>查看当前正在使用的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();  #使用的一个 mysql 中的全局函数</span><br></pre></td></tr></table></figure></li><li><p>查看指定库下所有的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES FROM 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>查看数据库的创建信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE DATABASE 数据库名;</span><br><span class="line">或者：</span><br><span class="line">SHOW CREATE DATABASE 数据库名\G</span><br></pre></td></tr></table></figure></li><li><p>使用/切换数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”</p></blockquote><h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h2><ul><li>更改数据库字符集<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE 数据库名 CHARACTER SET 字符集;  #比如：gbk、utf8等</span><br></pre></td></tr></table></figure></li></ul><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><ul><li><p>方式1：删除指定的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>方式2：删除指定的数据库（<code>推荐</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS 数据库名;</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p><strong>必须具备：</strong></p><ul><li>CREATE TABLE权限</li><li>存储空间</li></ul><p><strong>语法格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] 表名(</span><br><span class="line">字段1, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段2, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段3, 数据类型 [约束条件] [默认值],</span><br><span class="line">……</span><br><span class="line">[表约束条件]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p></blockquote><p><strong>必须指定：</strong></p><ul><li>表名</li><li>字段名，数据类型及长度</li></ul><p><strong>可选条件：</strong></p><ul><li>约束条件</li><li>默认值</li></ul><p>EG-1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">  -- int类型</span><br><span class="line">  emp_id INT,</span><br><span class="line">  -- 最多保存20个中英文字符</span><br><span class="line">  emp_name VARCHAR(20),</span><br><span class="line">  -- 总位数不超过15位</span><br><span class="line">  salary DOUBLE,</span><br><span class="line">  -- 日期类型</span><br><span class="line">  birthday DATE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>MySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11。也可以在创建数据表的时候指定数据的显示宽度。</p></blockquote><p>EG-2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE dept(</span><br><span class="line">    -- int类型，自增</span><br><span class="line">deptno INT(2) AUTO_INCREMENT,</span><br><span class="line">dname VARCHAR(14),</span><br><span class="line">loc VARCHAR(13),</span><br><span class="line">    -- 主键</span><br><span class="line">    PRIMARY KEY (deptno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>在MySQL 8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法。</p></blockquote><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><ul><li>使用 AS subquery 选项，<strong>将创建表和插入数据结合起来</strong></li><li>指定的列和子查询中的列要一一对应</li><li>通过列名和默认值定义列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp1 AS SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE dept80</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id, last_name, salary*12 ANNSAL, hire_date</span><br><span class="line">FROM    employees</span><br><span class="line">WHERE   department_id = 80;</span><br></pre></td></tr></table></figure><h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用<code>DESCRIBE/DESC</code>语句查看数据表结构，也支持使用<code>SHOW CREATE TABLE</code>语句查看数据表结构。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名\G</span><br></pre></td></tr></table></figure><p>使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>修改表指的是修改数据库中已经存在的数据表的结构。</p><p><strong>使用 ALTER TABLE 语句可以实现：</strong></p><ul><li>向已有的表中添加列</li><li>修改现有表中的列</li><li>删除现有表中的列</li><li>重命名现有表中的列</li></ul><h3 id="追加列"><a href="#追加列" class="headerlink" title="追加列"></a>追加列</h3><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】;</span><br></pre></td></tr></table></figure><p>EG：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE dept80 </span><br><span class="line">ADD job_id varchar(15);</span><br></pre></td></tr></table></figure><h2 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h2><ul><li><p>可以修改列的数据类型，长度、默认值和位置</p></li><li><p>修改字段数据类型、长度、默认值、位置的语法格式如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名2】;</span><br></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLEdept80</span><br><span class="line">MODIFY last_name VARCHAR(30);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLEdept80</span><br><span class="line">MODIFY salary double(9,2) default 1000;</span><br></pre></td></tr></table></figure><blockquote><p>对默认值的修改只影响今后对表的修改<br>此外，还可以通过此种方式修改列的约束。这里暂先不讲。</p></blockquote><h2 id="重命名列"><a href="#重命名列" class="headerlink" title="重命名列"></a>重命名列</h2><p>使用 CHANGE old_column  new_column  dataType子句重命名列。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE  dept80</span><br><span class="line">CHANGE department_name dept_name varchar(15); </span><br></pre></td></tr></table></figure><h2 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h2><p>删除表中某个字段的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 【COLUMN】字段名</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE  dept80</span><br><span class="line">DROP COLUMN  job_id; </span><br></pre></td></tr></table></figure><h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h2><ul><li><p>方式一：使用RENAME</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE emp</span><br><span class="line">TO myemp;</span><br></pre></td></tr></table></figure></li><li><p>方式二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER table dept</span><br><span class="line">RENAME [TO] detail_dept;  -- [TO]可以省略</span><br></pre></td></tr></table></figure></li><li><p>必须是对象的拥有者</p></li></ul><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><ul><li>在MySQL中，当一张数据表<code>没有与其他任何数据表形成关联关系</code>时，可以将当前数据表直接删除。</li><li>数据和结构都被删除</li><li>所有正在运行的相关事务被提交</li><li>所有相关索引被删除</li></ul><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];</span><br></pre></td></tr></table></figure><p><code>IF EXISTS</code>的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p><p>EG：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE dept80;</span><br></pre></td></tr></table></figure><blockquote><p>DROP TABLE 语句不能回滚</p></blockquote><h2 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h2><ul><li>TRUNCATE TABLE语句：<ul><li>删除表中所有的数据</li><li>释放表的存储空间</li></ul></li></ul><p>EG：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE detail_dept;</span><br></pre></td></tr></table></figure><ul><li>TRUNCATE语句<strong>不能回滚</strong>，而使用 DELETE 语句删除数据，可以回滚</li><li>对比：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = FALSE;</span><br><span class="line">  </span><br><span class="line">DELETE FROM emp2; </span><br><span class="line">#TRUNCATE TABLE emp2;</span><br><span class="line">  </span><br><span class="line">SELECT * FROM emp2;</span><br><span class="line">  </span><br><span class="line">ROLLBACK;</span><br><span class="line">  </span><br><span class="line">SELECT * FROM emp2;</span><br></pre></td></tr></table></figure><blockquote><p>阿里开发规范：</p><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。 </p><p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></blockquote><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><strong>阿里规范《Java开发手册》规范</strong></p><ul><li><p>【<code>强制</code>】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><ul><li>正例：aliyun_admin，rdc_config，level3_name </li><li>反例：AliyunAdmin，rdcConfig，level_3_name</li></ul></li><li><p>【<code>强制</code>】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p></li><li><p>【<code>强制</code>】表必备三字段：id, gmt_create, gmt_modified。 </p><ul><li>说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新</li></ul></li><li><p>【<code>推荐</code>】表的命名最好是遵循 “业务名称_表的作用”。 </p><ul><li>正例：alipay_task 、 force_project、 trade_config</li></ul></li><li><p>【<code>推荐</code>】库名与应用名称尽量一致。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 </p><ul><li>正例：无符号值可以避免误存负数，且扩大了表示范围。</li></ul></li></ul><p><strong>如何理解清空表、删除表等操作需谨慎？</strong><br><code>表删除</code>操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行<code>备份</code>，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。</p><p>同样的，在使用 <code>ALTER TABLE</code> 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的<code>备份</code>，因为数据库的改变是<code>无法撤销</code>的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p><p><strong>MySQL8新特性—DDL的原子化</strong><br>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即<code>DDL操作要么成功要么回滚</code>。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本中创建数据库和数据表，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE mytest;</span><br><span class="line"></span><br><span class="line">USE mytest;</span><br><span class="line"></span><br><span class="line">CREATE TABLE book1(</span><br><span class="line">book_id INT ,</span><br><span class="line">book_name VARCHAR(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>（1）在MySQL 5.7版本中，测试步骤如下：<br>删除数据表book1和数据表book2，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE book1,book2;</span><br><span class="line">ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27;</span><br></pre></td></tr></table></figure><p>再次查询数据库中的数据表名称，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。</p><p>（2）在MySQL 8.0版本中，测试步骤如下：<br>删除数据表book1和数据表book2，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE book1,book2;</span><br><span class="line">ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27;</span><br></pre></td></tr></table></figure><p>再次查询数据库中的数据表名称，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_mytest |</span><br><span class="line">+------------------+</span><br><span class="line">| book1            |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出，数据表book1并没有被删除。</p><h1 id="表之增删改"><a href="#表之增删改" class="headerlink" title="表之增删改"></a>表之增删改</h1><h1 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h1><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="mysql" scheme="https://up-bear.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot-注解</title>
    <link href="https://up-bear.github.io/2021/11/15/springboot-zhu-jie/"/>
    <id>https://up-bear.github.io/2021/11/15/springboot-zhu-jie/</id>
    <published>2021-11-15T12:44:24.000Z</published>
    <updated>2022-01-19T13:06:20.171Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>注释类，向SpringBoot表示该类为一个配置类。该注解有一个属性proxyBeanMethods，默认为true，表示该类被SpringBoot所代理，可以理解为该被SpringBoot托管。<br>@Configuration配置类本身也是一个组件，组件ID为类名（首字母小写）。</p><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>用来注释方法，要和 “能将类作为组件添加到容器中” 的注解组合使用，例如@Configuration和@Conpoment。表示向IOC容器中添加一个组件，组件ID默认为方法名，组件实例为方法的返回值。<br>当@Configuration的 proxyBeanMethods=true 时，当使用类对象调用注解了@Bean的方法时，SpringBoot会去容器中寻找该组件，返回该组件的引用，而不是重新构造一个对象实例。多次从获取时，仍然引用的是容器中组件实例，即该方法的返回值保持单实例。<br>当@Configuration的proxyBeanMethods=false时，表示配置类不会由SpringBoot所代理，使用类对象调用注解@Bean方法时，SpringBoot不会去容器中寻找组件，而是直接创建一个实例，每次调用都会创建不同的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(&quot;haha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext app = SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">        System.out.println(app.containsBean(<span class="string">&quot;haha&quot;</span>));</span><br><span class="line">        System.out.println(app.containsBean(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：<img src="/2021/11/15/springboot-zhu-jie/01.png" class="" title="输出结果"></p><h4 id="组件依赖："><a href="#组件依赖：" class="headerlink" title="组件依赖："></a>组件依赖：</h4><p>小结：注解@Bean和@Configuration表示在SpringBoot启动时，像容器中添加一个组件。但是如果proxyBeanMethods=true，表示该类被SpringBoot代理。<br>注意：如果使用普通方式，通过构造方法创建是实例时，和注解@Configuration、@Bean没有任何关系。</p><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>注释类。表示向容器中添加组件。<br>使用方式：@Import(“<em><strong>class”, “</strong></em>.class”)，组件名为全类名</p><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>标注在类上，表示将该类作为一个组件添加到Spring容器中。</p><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>@ConfigurationProperties注解可以和@Component搭配（同一类中），也可以和@EnableConfigurationProperties搭配（不同类中）。<br>@ConfigurationProperties将类的属性和配置文件中的属性进行绑定。如果该类只有@ConfigurationProperties注解而没有@Component注解，那么配置绑定功能是无法实现的，因为该类没有被作为组件添加到Spring容器中（不能享受Spring容器带来的强大功能），此时可以在其他类中使用@EnableConfigurationProperties注解，将类添加到容器中，开启配置绑定功能。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web;</span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.web&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">        <span class="comment">//和配置文件application.properties中的 spring.web.resources.static-locations 进行绑定</span></span><br><span class="line"><span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h3><p>对只有@ConfigurationProperties注解而没有@Component注解的配置类，使用@EnableConfigurationProperties将配置类添加到容器中。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.servlet;</span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class,</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.web.ResourceProperties.class, WebProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span>, <span class="title">ServletContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.servlet;</span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数自动封装"><a href="#参数自动封装" class="headerlink" title="参数自动封装"></a>参数自动封装</h3><p>表单的字段会被自动封装到参数对象中。表单name属性的值要和对象的属性名一致，否则会封装失败，造成对象的属性值为null的情况。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/form_createManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createManager</span><span class="params">(Manager manager)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(managerService.isExitsByManagerName(manager.getName()))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/createManager.html&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            managerService.add(manager);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/listManager.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/form_createManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;手机&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phone&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;邮箱&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://up-bear.github.io/categories/SpringBoot/"/>
    
    
    <category term="注解" scheme="https://up-bear.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>前端杂记</title>
    <link href="https://up-bear.github.io/2021/10/30/qian-duan-za-ji/"/>
    <id>https://up-bear.github.io/2021/10/30/qian-duan-za-ji/</id>
    <published>2021-10-30T07:17:24.000Z</published>
    <updated>2023-03-13T15:20:21.872Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h4 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h4><p>textarea标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cols:字符列数</span><br><span class="line">rows:字符行数</span><br><span class="line">readonly:值true/false 是否设为只读</span><br></pre></td></tr></table></figure><p>去除首行缩进：将首尾标签放在同一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea&gt;hello&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>去除下拉斜线：添加属性 resize: none</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea style=&quot;resize: none;&quot;&gt;hello&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>去除滚动条：添加属性 overflow: hidden</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea style=&quot;overflow: hidden;&quot;&gt;hello&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>去除边框：添加属性border: none</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea style=&quot;border: none;&quot;&gt;hello&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>去除点击文本时的边框：添加属性 outline: none</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea style=&quot;outline: none;&quot;&gt;hello&lt;/textarea</span><br></pre></td></tr></table></figure><p>显示高度自适应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea  autoHeight=&quot;true&quot; readonly=&quot;readonly&quot; style=&quot;resize: none; border: none; overflow: hidden; outline: </span><br><span class="line">none;&quot;&gt;qwerrtyuiopasdfghjklzxcnm1234567890qwertyuiopasdfghjklzxcvbnm</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $.fn.autoHeight = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">autoHeight</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                elem.style.height = <span class="string">&#x27;auto&#x27;</span>;</span><br><span class="line">                elem.scrollTop = <span class="number">0</span>; <span class="comment">//防抖动</span></span><br><span class="line">                elem.style.height = elem.scrollHeight + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                autoHeight(<span class="built_in">this</span>);</span><br><span class="line">                $(<span class="built_in">this</span>).on(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    autoHeight(<span class="built_in">this</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);     </span><br><span class="line">&#125;                </span><br><span class="line">   $(<span class="string">&#x27;textarea[autoHeight]&#x27;</span>).autoHeight();    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>textarea自适应小问题：实际textarea的宽度比文字行数多了一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--单个媒体对象 start--&gt;</span><br><span class="line">&lt;div class=&quot;media&quot;&gt;</span><br><span class="line">&lt;div class=&quot;media-left&quot;&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;</span><br><span class="line">&lt;img class=&quot;media-object&quot; src=&quot;../images/72534562.jpg&quot; alt=&quot;头像&quot; width=&quot;64px&quot; height=&quot;64px&quot;&gt;</span><br><span class="line">&lt;h5 style=&quot;margin: 0px;text-align: center;&quot;&gt;用户名&lt;/h5&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;media-body&quot;&gt;</span><br><span class="line">&lt;h4 class=&quot;media-heading&quot;&gt;Media heading&lt;/h4&gt;</span><br><span class="line">&lt;textarea cols=&quot;50&quot; rows=&quot;3&quot; style=&quot;resize: none; border: none; overflow: hidden; outline: none;&quot; readonly=&quot;true&quot;&gt;Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo.&lt;/textarea&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--单个媒体对象 end--&gt;</span><br></pre></td></tr></table></figure><h1 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h1><h3 id="动态包含页面"><a href="#动态包含页面" class="headerlink" title="动态包含页面"></a>动态包含页面</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="string">&quot;#head&quot;</span>).load(<span class="string">&quot;public/head.html&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="IDEA创建SpringBoot项目"><a href="#IDEA创建SpringBoot项目" class="headerlink" title="IDEA创建SpringBoot项目"></a>IDEA创建SpringBoot项目</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>重定向的默认访问路径是Resource/templates,想要访问Resource/static下的静态资源返回字符串要明确添加redirect，例如 return “redirect:html/hello.html”</p><h3 id="bootstrap-amp-thymeleaf"><a href="#bootstrap-amp-thymeleaf" class="headerlink" title="bootstrap&amp;thymeleaf"></a>bootstrap&amp;thymeleaf</h3><p>二者不兼容：bootstrap静态页面经由thymeleaf动态打开后静态页面样式消失</p><h3 id="动态创建列表"><a href="#动态创建列表" class="headerlink" title="动态创建列表"></a>动态创建列表</h3><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;管理者名称&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;手机&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">    &lt;tr th:each=&quot;manager : $&#123;manager_list&#125;&quot;&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;manager.getName()&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;manager.phone&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><ol><li>向request中放入一个名manager_list的List类型对象。<br> 向Request、Model、ModelAndView中放入数据，都是一样的效果，因为三者最终都将数据放入了同一个地方（雷神SpringBoot2中有讲）</li><li>使用Thymeleaf取数据，显示在列表中。<br> ${manager_list}:取出request中key为manager_list的对象<br> ${manager.getName()}和${manager.phone}两种方法都可以获取对象manager的属性</li></ol><h3 id="Thymeleaf常见错误"><a href="#Thymeleaf常见错误" class="headerlink" title="Thymeleaf常见错误"></a>Thymeleaf常见错误</h3><ol><li>路径拼写错误。<br> 使用了Thymeleaf模板，默认使用了@Controller类的字符串返回类型会被当作转发请求，且返回的字符串不需要带后缀”.html’，因为Thymeleaf会默认去寻找html文件。如果想使用重定向，需要使用：return “redirect:请求路径”。</li><li>thymeleaf获取request、session中的参数错误。<br> 使用thymeleaf表达式 ${…} 获取数据时，一定要确保在到达该页面前一定已经向对应的request、session中放入了要取的数据，否则也会造成错误。<br> 使用 ${对象.属性} 或 ${对象.方法} 获取数据时，一定确保属性名和方法名和Java类中的保持一致，即使少了一个字母也会报错</li></ol><h3 id="background-image-url-拼接"><a href="#background-image-url-拼接" class="headerlink" title="background-image: url() 拼接"></a>background-image: url() 拼接</h3><p>设置背景</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:style</span>=<span class="string">&quot;&#x27;background:url(&#x27; + @&#123;/&lt;path-to-image&gt;&#125; + &#x27;);&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据属性值改变背景</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;media-object resource-card-image&quot;</span>  <span class="attr">th:style</span>=<span class="string">&quot;&#x27;background:url(&#x27; + @&#123;($&#123;collect.webLogo&#125;==&#x27;&#x27; ? &#x27;img/favicon.png&#x27; : $&#123;collect.webLogo&#125;)&#125; + &#x27;)&#x27;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="行内写法（表达式内联）"><a href="#行内写法（表达式内联）" class="headerlink" title="行内写法（表达式内联）"></a>行内写法（表达式内联）</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Hello, [[$&#123;session.user.name&#125;]]!&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>禁用内联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p th:inline=&quot;none&quot;&gt;A double array looks like this: [[1, 2, 3], [4, 5]]!&lt;/p&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://up-bear.github.io/categories/SpringBoot/"/>
    
    <category term="html" scheme="https://up-bear.github.io/categories/html/"/>
    
    
    <category term="bootstrap" scheme="https://up-bear.github.io/tags/bootstrap/"/>
    
    <category term="thymeleaf" scheme="https://up-bear.github.io/tags/thymeleaf/"/>
    
  </entry>
  
  <entry>
    <title>my-first-blog</title>
    <link href="https://up-bear.github.io/2021/10/17/my-first-blog/"/>
    <id>https://up-bear.github.io/2021/10/17/my-first-blog/</id>
    <published>2021-10-17T08:30:51.000Z</published>
    <updated>2021-12-04T14:40:54.038Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Hexo-GitHub-搭建个人博客"><a href="#Hexo-GitHub-搭建个人博客" class="headerlink" title="Hexo + GitHub 搭建个人博客"></a>Hexo + GitHub 搭建个人博客</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><pre><code>npm、git</code></pre><h2 id="使用命令（均在git-bash下执行）"><a href="#使用命令（均在git-bash下执行）" class="headerlink" title="使用命令（均在git bash下执行）"></a>使用命令（均在git bash下执行）</h2><p>安装Hexo博客框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>初始化项目文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init 文件夹名称（后面不跟文件名称时，需要自己创建文件，并在切换到对应文件路径下执行该命令</span><br></pre></td></tr></table></figure><p>安装npm依赖。执行上条命令时，会提示dependencies 下载失败。按照提示运行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">有时使用npm下载不成，可以使用cnpm install，多运行几次就好了（亲试）</span><br></pre></td></tr></table></figure><p>本地预览博客是否搭建成功。执行以下两条命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g#编译静态文件</span><br><span class="line">hexo s#本地预览</span><br></pre></td></tr></table></figure><p>访问 <a class="link"   href="http://localhost:4000/" >http://localhost:4000/<i class="fas fa-external-link-alt"></i></a> 。出现以下页面表示本地搭建成功。</p><p><img src="https://gitee.com/lsc180/images/raw/master/img/20201105103838.png" alt="img"></p><h2 id="上线到Github"><a href="#上线到Github" class="headerlink" title="上线到Github"></a>上线到Github</h2><p>准备工作：获取SSH密钥<br>    查看本地有无SSH密钥<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><br>    如果没有则生成密钥。<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;#会提示你设置密钥文件名称，和密码，两者都可以为空，直接回车</span><br></pre></td></tr></table></figure><br>    再次查看密钥文件，查询结果出现***.ssh文件表示成功，同样会显示密钥路径。<br>Github设置SSH密钥<br>    在setting中选中SSH and GPG keys，点击New SSH key，密钥名称任取，密钥内容使用记事本打开生成的密钥文件，复制过去，就ok了。<br>安装Github部署插件<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><br>Github创建新库 username.github.io。修改项目目录下的配置文件。如下所示。<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repo: git@github.com:up-bear/up-bear.github.io.git</span><br><span class="line"> branch: master</span><br></pre></td></tr></table></figure><br>部署命令<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br><span class="line">每次修改博客后，需要使用以下命令重新部署</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><br>访问博客网址username.github.io。</p>    <div id="aplayer-UpibEFhC" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="523845661" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="blog" scheme="https://up-bear.github.io/categories/blog/"/>
    
    
  </entry>
  
</feed>
