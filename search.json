[{"title":"Java基础","url":"/2021/11/17/java-ji-chu/","content":"JDK版本：jdk11\n静态方法不能通过对象调用，只能通过类名调用。\n静态方法可被子类继承。\n类的int属性如果没有赋初值，则在创建类对象时，会被赋值为0。    JPA可能就是根据对象的id是否为0来判断表中是否存在该对象的记录，从而决定save方法是插入还是修改操作。类的String类型的属性不会再创建对象时被赋默认值，为null。    类的对象类型属性，创建时不会赋予默认值，为null。\n字符串关于字符串，在JVM的底层好像有一个字符串常量池。\npublic class Test &#123;    A a;    static class A&#123;        int id;        String name;        public void setName(String name) &#123;            this.name = name;        &#125;        public String getName() &#123;            return name;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public int getId() &#123;            return id;        &#125;    &#125;    public static void main(String[] args) &#123;         A a = new A();         a.setName(&quot;name&quot;);        System.out.println(a.getName());         Test.alter1(a);        System.out.println(a.getName());        System.out.println();        String s = &quot;hello&quot;;        System.out.println(s);        alter2(s);        System.out.println(s);    &#125;    static void alter1(A a)&#123;        a.name = &quot;alterA&quot;;    &#125;    static void alter2(String str)&#123;        str = &quot;hi&quot;;    &#125;&#125;\n运行结果：\n","categories":["java"]},{"title":"Java实体类","url":"/2022/03/10/java-shi-ti-lei/","content":"实体类的属性名称不能和数据库的保留字相同，否则会导致数据表创建错误。Mysql保留字有：    call\n","categories":["mysql","Java"]},{"title":"SpringBoot-JPA","url":"/2021/12/04/springboot-jpa/","content":"pom依赖配置jpa本身配置&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;\n引入驱动依赖（mysql数据库操作必配）&lt;dependency&gt;\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;\n\nmysql数据库链接#数据库连接spring.datasource.url=jdbc:mysql://127.0.0.1:3306/admin?characterEncoding=UTF-8spring.datasource.username=用户名spring.datasource.password=用户密码#mysql驱动spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n使用步骤一、创建实体类实体类标注注解：@Entity、@Table。注意导入的包为：javax.persistence.*\n@Entity@Table(name = &quot;user&quot;)public class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column    int id;    @Column    String userName;    @Column    String name;    @Column    String headImg;    //性别    @Column    String gender;    @Column    String phone;    @Column    String email;    String password;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getId() &#123;        return id;    &#125;    public void setUserName(String userName) &#123;        this.userName = userName;    &#125;    public String getUserName() &#123;        return userName;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setHeadImg(String headImg) &#123;        this.headImg = headImg;    &#125;    public String getHeadImg() &#123;        return headImg;    &#125;    public void setGender(String gender) &#123;        this.gender = gender;    &#125;    public String getGender() &#123;        return gender;    &#125;    public void setPhone(String phone) &#123;        this.phone = phone;    &#125;    public String getPhone() &#123;        return phone;    &#125;    public void setEmail(String email) &#123;        this.email = email;    &#125;    public String getEmail() &#123;        return email;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public String getPassword() &#123;        return password;    &#125;&#125;\nJPA默认的字段命名规则是驼峰转换，eg：UserName –&gt; user_name。\nJPA配置修改#设置自动更新表结构spring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect#在控制台显示sql语句spring.jpa.show-sql= true\n\n二、继承JpaRepository接口//User对应要操作的数据表实体类，Integer是int类型的封装类，固定不变public interface UserDAO extends JpaRepository&lt;User, Integer&gt; &#123;&#125;\n\n三、使用接口类进行CRUD操作当UserDAO继承了JpaRepository后，可以在其它类中注入UserDAO，使用UserDAO进行简单的crud操作。在类UserService标注注解@Service的作用是，向容器中添加该类的组件，之后可以在其它地方使用注解@Autowired注入该类对象。\n@Servicepublic class UserService &#123;    @Autowired    UserDAO userDAO;    public void add(User user)&#123;        userDAO.save(user);    &#125; &#125;\nJPA注入：    使用注解@Autowired。    内部使用了@Autowired的类，在外面不能使用new创建该类对象，而是使用@Autowired注入对象，否则会导致JPA注入失败，报空指针异常。    eg：UserController类中使用了new UserService创建对象，导致UserService类中UserDAO注入失败，userDAO为null\n@Controllerpublic class UserController &#123;    @RequestMapping(&quot;/hello&quot;)    @ResponseBody    public void hi()&#123;        new UserService().add(new User());    &#125;&#125;\n\n正确用法是使用@Autowired注入UserService对象，如下所示\n@Controllerpublic class UserController &#123;    @Autowired    UserService userService;    @RequestMapping(&quot;/hello&quot;)    @ResponseBody    public void hi()&#123;        userService.add(new User());    &#125;&#125;","categories":["mysql","SpringBoot"],"tags":["JPA"]},{"title":"SpringBoot-方法参数","url":"/2021/12/02/springboot-fang-fa-can-shu/","content":"方法参数封装","categories":["SpringBoot"]},{"title":"SpringBoot-注解","url":"/2021/11/15/springboot-zhu-jie/","content":"@Configuration注释类，向SpringBoot表示该类为一个配置类。该注解有一个属性proxyBeanMethods，默认为true，表示该类被SpringBoot所代理，可以理解为该被SpringBoot托管。@Configuration配置类本身也是一个组件，组件ID为类名（首字母小写）。\n@Bean用来注释方法，要和 “能将类作为组件添加到容器中” 的注解组合使用，例如@Configuration和@Conpoment。表示向IOC容器中添加一个组件，组件ID默认为方法名，组件实例为方法的返回值。当@Configuration的 proxyBeanMethods=true 时，当使用类对象调用注解了@Bean的方法时，SpringBoot会去容器中寻找该组件，返回该组件的引用，而不是重新构造一个对象实例。多次从获取时，仍然引用的是容器中组件实例，即该方法的返回值保持单实例。当@Configuration的proxyBeanMethods=false时，表示配置类不会由SpringBoot所代理，使用类对象调用注解@Bean方法时，SpringBoot不会去容器中寻找组件，而是直接创建一个实例，每次调用都会创建不同的实例。\n@Configuration(&quot;haha&quot;)public class test &#123;    @Bean    public User user()&#123;        return new User();    &#125;&#125;@SpringBootApplicationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext app = SpringApplication.run(DemoApplication.class, args);        System.out.println(app.containsBean(&quot;haha&quot;));        System.out.println(app.containsBean(&quot;user&quot;));    &#125;&#125;\n输出结果为：\n组件依赖：小结：注解@Bean和@Configuration表示在SpringBoot启动时，像容器中添加一个组件。但是如果proxyBeanMethods=true，表示该类被SpringBoot代理。注意：如果使用普通方式，通过构造方法创建是实例时，和注解@Configuration、@Bean没有任何关系。\n@Import注释类。表示向容器中添加组件。使用方式：@Import(“class”, “.class”)，组件名为全类名\n@Component标注在类上，表示将该类作为一个组件添加到Spring容器中。\n@ConfigurationProperties@ConfigurationProperties注解可以和@Component搭配（同一类中），也可以和@EnableConfigurationProperties搭配（不同类中）。@ConfigurationProperties将类的属性和配置文件中的属性进行绑定。如果该类只有@ConfigurationProperties注解而没有@Component注解，那么配置绑定功能是无法实现的，因为该类没有被作为组件添加到Spring容器中（不能享受Spring容器带来的强大功能），此时可以在其他类中使用@EnableConfigurationProperties注解，将类添加到容器中，开启配置绑定功能。代码示例：\npackage org.springframework.boot.autoconfigure.web;@ConfigurationProperties(&quot;spring.web&quot;)public class WebProperties &#123;\tpublic static class Resources &#123;        //和配置文件application.properties中的 spring.web.resources.static-locations 进行绑定\t\tprivate String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;\t&#125;&#125;\n\n@EnableConfigurationProperties对只有@ConfigurationProperties注解而没有@Component注解的配置类，使用@EnableConfigurationProperties将配置类添加到容器中。代码示例：\npackage org.springframework.boot.autoconfigure.web.servlet;@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,\t\tValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123;\t@Configuration(proxyBeanMethods = false)\t@Import(EnableWebMvcConfiguration.class)\t@EnableConfigurationProperties(&#123; WebMvcProperties.class,\t\t\torg.springframework.boot.autoconfigure.web.ResourceProperties.class, WebProperties.class &#125;)\t@Order(0)\tpublic static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware &#123;\t\t&#125;&#125;package org.springframework.boot.autoconfigure.web.servlet;@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)public class WebMvcProperties &#123;&#125;\n\n参数自动封装表单的字段会被自动封装到参数对象中。表单name属性的值要和对象的属性名一致，否则会封装失败，造成对象的属性值为null的情况。代码示例：\n@GetMapping(&quot;/form_createManager&quot;)    public String createManager(Manager manager)&#123;        if(managerService.isExitsByManagerName(manager.getName()))&#123;            return &quot;redirect:/createManager.html&quot;;        &#125;else &#123;            managerService.add(manager);            return &quot;redirect:/listManager.html&quot;;        &#125;    &#125;\n&lt;form action=&quot;/form_createManager&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;姓名&quot; name=&quot;name&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;手机&quot; name=&quot;phone&quot;&gt;    &lt;input type=&quot;email&quot; placeholder=&quot;邮箱&quot; name=&quot;email&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;","categories":["SpringBoot"],"tags":["注解"]},{"title":"Hello World","url":"/2021/10/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"aplayer","url":"/2021/10/30/aplayer/","content":"使用aplayer播放器\n安装aplayer使用命令fs    npm install aplayer –save\n文章添加音乐在文章头部Front-matter中添加语句，否则不成功    aplayer: true在文章正文中添加以下语句。（具体字段属性请参考官方文档）\n方法2：使用hexo-tag-aplayer插件实现安装插件    npm install –save hexo-tag-aplayer在hexo的配置文件 _config.yml 中添加以下语句。    aplayer:        true在文章正文添加以下语句。（具体字段属性请参考官方文档）使用hexo-tag-aplayer有个小问题，音乐播放列表列表不能折叠。添加”listfolded:true”后音乐页面直接不能显示了。\n\n\t\t\t\n\t\t\t\tconsole.error(\"Error: [hexo-tag-aplayer] Specified asset file not found (caffeine.mp3)\");\n\t\t\t\n\nwocao\n","categories":["blog"],"tags":["aplayer"]},{"title":"my-first-blog","url":"/2021/10/17/my-first-blog/","content":"Hexo + GitHub 搭建个人博客环境准备npm、git\n\n使用命令（均在git bash下执行）安装Hexo博客框架\nnpm install hexo-cli -g\n初始化项目文件夹\nhexo init 文件夹名称（后面不跟文件名称时，需要自己创建文件，并在切换到对应文件路径下执行该命令\n安装npm依赖。执行上条命令时，会提示dependencies 下载失败。按照提示运行命令。\nnpm install有时使用npm下载不成，可以使用cnpm install，多运行几次就好了（亲试）\n本地预览博客是否搭建成功。执行以下两条命令。\nhexo g\t#编译静态文件hexo s\t#本地预览\n访问 http://localhost:4000/ 。出现以下页面表示本地搭建成功。\n\n上线到Github准备工作：获取SSH密钥    查看本地有无SSH密钥    cd ~/.ssh    如果没有则生成密钥。    ssh-keygen -t rsa -C &quot;你的邮箱&quot;\t\t#会提示你设置密钥文件名称，和密码，两者都可以为空，直接回车    再次查看密钥文件，查询结果出现***.ssh文件表示成功，同样会显示密钥路径。Github设置SSH密钥    在setting中选中SSH and GPG keys，点击New SSH key，密钥名称任取，密钥内容使用记事本打开生成的密钥文件，复制过去，就ok了。安装Github部署插件    npm install hexo-deployer-git --saveGithub创建新库 username.github.io。修改项目目录下的配置文件。如下所示。    deploy: \t\ttype: git \t\trepo: git@github.com:up-bear/up-bear.github.io.git\t\t branch: master部署命令    hexo d每次修改博客后，需要使用以下命令重新部署hexo cleanhexo ghexo d访问博客网址username.github.io。\n\n    ","categories":["blog"]},{"title":"html","url":"/2021/10/31/html/","content":"textareatextarea标签：\ncols:字符列数rows:字符行数readonly:值true/false 是否设为只读\n去除首行缩进：将首尾标签放在同一行\n&lt;textarea&gt;hello&lt;/textarea&gt;\n去除下拉斜线：添加属性 resize: none\n&lt;textarea style=&quot;resize: none;&quot;&gt;hello&lt;/textarea&gt;\n去除滚动条：添加属性 overflow: hidden\n&lt;textarea style=&quot;overflow: hidden;&quot;&gt;hello&lt;/textarea&gt;\n去除边框：添加属性border: none\n&lt;textarea style=&quot;border: none;&quot;&gt;hello&lt;/textarea&gt;\n去除点击文本时的边框：添加属性 outline: none\n&lt;textarea style=&quot;outline: none;&quot;&gt;hello&lt;/textarea\n显示高度自适应：\n&lt;textarea  autoHeight=&quot;true&quot; readonly=&quot;readonly&quot; style=&quot;resize: \t\tnone; border: none; overflow: hidden; outline: \tnone;&quot;&gt;qwerrtyuiopasdfghjklzxcnm1234567890qwertyuiopasdfghjklzxcvbnm&lt;/textarea&gt;\n$(function()&#123;        $.fn.autoHeight = function()&#123;                function autoHeight(elem)&#123;                elem.style.height = &#x27;auto&#x27;;                elem.scrollTop = 0; //防抖动                elem.style.height = elem.scrollHeight + &#x27;px&#x27;;            &#125;            this.each(function()&#123;                autoHeight(this);                $(this).on(&#x27;keyup&#x27;, function()&#123;                    autoHeight(this);                &#125;);            &#125;);     &#125;                   $(&#x27;textarea[autoHeight]&#x27;).autoHeight();    &#125;)\ntextarea自适应小问题：实际textarea的宽度比文字行数多了一行\n&lt;!--单个媒体对象 start--&gt;&lt;div class=&quot;media&quot;&gt;&lt;div class=&quot;media-left&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img class=&quot;media-object&quot; src=&quot;../images/72534562.jpg&quot; alt=&quot;头像&quot; width=&quot;64px&quot; height=&quot;64px&quot;&gt;&lt;h5 style=&quot;margin: 0px;text-align: center;&quot;&gt;用户名&lt;/h5&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;media-body&quot;&gt;&lt;h4 class=&quot;media-heading&quot;&gt;Media heading&lt;/h4&gt;&lt;textarea cols=&quot;50&quot; rows=&quot;3&quot; style=&quot;resize: none; border: none; overflow: hidden; outline: none;&quot; readonly=&quot;true&quot;&gt;Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo.&lt;/textarea&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--单个媒体对象 end--&gt;","categories":["html"]},{"title":"nginx初试","url":"/2022/04/06/nginx-chu-shi/","content":"Linux安装nginx，安装路径为 /usr/local/nginx 。启动及其他命令须在 sbin 目录下进行。常用命令\n启动nginx\t\t./nginx\t\t停止nginx\t\t./nginx\t-s stop\t重新加载nginx  ./nginx -s reload\n\n反向代理概念：客户端发送的请求经过中间件，然后派发到不同服务器的过程即为反向代理。正向代理代理的是客户端，特点是用户明确知道实际访问的服务器。反向代理代理的是服务器，特点是用户不知道实际要访问的服务器，服务器对用户来说是隐藏的，用户知道的是中间件。\n反向代理单个节点nginx.con配置\nserver &#123;\tlisten\t&quot;访问端口&quot;;\tserver_name:\t&quot;访问ip&quot;;\tlocation / &#123;\t\troot\thtml;\t\tindex\tindex.html index.html;\t\tproxy_name\t&quot;被代理的服务器ip:port&quot;;\t&#125;&#125;\n反向代理两个节点nginx.conf配置\nserver &#123;\tlisten\t&quot;访问端口&quot;;\tserver\t&quot;访问ip&quot;;\t\tlocation ~ /edu/ &#123;\t\tproxy_pass\thttp://op:port;\t&#125;\t\tlocation ~ /vod/ &#123;\t\tproxy_pass\thttp://ip:port;\t&#125;&#125;\n/edu/ 是正则表达式，nginx会根据客户端的访问路径，将请求派发到与正则表达式匹配的服务器。\n负载均衡概念：将请求派发到不同服务器上，减轻服务器的负担，提高系统的可用性和可靠性。\n默认轮询nginx.conf配置\nupstream myServer&#123;\tserver\tip:port;\tserver\tip:port;&#125;server&#123;\tlisten\tport;\tserver_name\t\tip;        location&#123;    \tproxy_pass\thttp://myServer;    \t    \troot\thtml;    \tindex\tindex.html\tindex.html;    &#125;&#125;\n分配权重nginx.conf配置\nupstream myServer&#123;\tserver\tip:port\t\tweight=10;\tserver\tip:port\t\tweight=5;\t&#125;server&#123;\tlisten\tport;\tserver_name\t\tip;        location&#123;    \tproxy_pass\thttp://myServer;    \t    \troot\thtml;    \tindex\tindex.html\tindex.html;    &#125;&#125;\nweight的值越大，请求被派发到该服务器的几率越大。\nip_hashnginx.conf配置\nupstream myServer&#123;\tip_hash;\tserver\tip:port;\tserver\tip:port;&#125;server&#123;\tlisten\tport;\tserver_name\t\tip;        location&#123;    \tproxy_pass\thttp://myServer;    \t    \troot\thtml;    \tindex\tindex.html\tindex.html;    &#125;&#125;\nnginx根据客户端的ip的hash值进行派发请求，此方法可以解决session问题。\nfairnginx.conf配置\nupstream myServer&#123;\tfair;\tserver\tip:port;\tserver\tip:port;&#125;server&#123;\tlisten\tport;\tserver_name\t\tip;        location&#123;    \tproxy_pass\thttp://myServer;    \t    \troot\thtml;    \tindex\tindex.html\tindex.html;    &#125;&#125;\nnginx根据服务器的响应时间来分配请求，响应时间越短越优先分配。\n动静分离看尚硅谷的nginx视频，感觉这部分讲的不是很好，和一般的反向代理差不多，但还是记录一下。本次测试是把静态资源放在nginx所在的主机下，在/myData/img 和 /myData/html 目录下放置静态资源。nginx.conf配置\nserver&#123;\tlisten\tport;\tserver_name\t\tip;        location&#123;    \tproxy_pass\thttp://myServer;    \t    \troot\thtml;    \tindex\tindex.html\tindex.html;    &#125;        #添加规则    location /html/ &#123;        root    /myData/;    &#125;    location /img/ &#123; \t\troot    /myData/; \t\t#访问/img/会把该目录下的资源列出来\t\tautoindex       on;    &#125;&#125;\n","categories":["nginx"]},{"title":"Java实体类和Mysql表结构","url":"/2021/11/26/mysql/","content":"mysql和实体类布尔类型mysql中没有布尔类型的数据，在实体类中的属性尽量使用布尔变量的封装类型Boolean\n@Entity@Table(name = &quot;a&quot;)public class A &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column    int id;    @Column    Boolean flag;        //set、get方法省略&#125;\n表结构中flag字段的类型为：\n字符串mysql中，字符串为空和为null，两者并不相等。字符串为空对应 “” 。要想查询数据表中字符串为空的记录，要传入参数 “” ,而不是 null\n\n\n索引（主键也是一种索引？在执行sql语句 show index from myTest 时，主键也被列了出来）\n\n\n创建索引创建表时创建索引：\ncreate table myTest(id int NOT NULL,name varchar(255) NOT NULL,age int(3) NOT NULL,weight int(3) NOT NULL,PRIMARY KEY (id),key in_myTest_weight(weight));\n创建表后添加索引：方式一\ncreate index in_sqltest_age on sqltest(age);\t//in_sqltest_age 索引名， sqltest 表名， age 字段名\n方式二\nalter table sqltest add index in_sqltest_name(name);\t//sqltest 表名， in_sqltest_name 索引名， name 字段名\n删除索引alter table sqltest drop index in_sqltest_age;\t//sqltest 表名， in_sqltest_age 索引名\n\n普通索引：index； 唯一索引：unique index。唯一索引即被索引的列中数据的值是唯一的，不允许重复。当列中的数据有重复时，创建唯一索引会失败；同样当创建好唯一索引后，插入重复数据的记录也会插入失败。\n唯一约束 UNIQUE创建表时添加 UNIQUE 约束\nCREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),UNIQUE (Id_P));\n创建表时添加多个 UNIQUE 约束\nCREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName));\n创建表后添加 UNIQUE 约束\nalter table sqltest add unique (name);\n创建表后添加多个 UNIQUE 约束\nalter table sqltest add unique (name, age);","categories":["mysql"],"tags":["实体类"]},{"title":"thymeleaf","url":"/2021/10/30/thymeleaf/","content":"动态包含页面&lt;script&gt;    $(&quot;#head&quot;).load(&quot;public/head.html&quot;);&lt;/script&gt;\nIDEA创建SpringBoot项目重定向重定向的默认访问路径是Resource/templates,想要访问Resource/static下的静态资源返回字符串要明确添加redirect，例如 return “redirect:html/hello.html”\nbootstrap&amp;thymeleaf二者不兼容：bootstrap静态页面经由thymeleaf动态打开后静态页面样式消失\n动态创建列表代码示例：\n&lt;table&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;管理者名称&lt;/th&gt;        &lt;th&gt;手机&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr th:each=&quot;manager : $&#123;manager_list&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;manager.getName()&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;manager.phone&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;\n\n向request中放入一个名manager_list的List类型对象。 向Request、Model、ModelAndView中放入数据，都是一样的效果，因为三者最终都将数据放入了同一个地方（雷神SpringBoot2中有讲）\n使用Thymeleaf取数据，显示在列表中。 ${manager_list}:取出request中key为manager_list的对象 ${manager.getName()}和${manager.phone}两种方法都可以获取对象manager的属性\n\nThymeleaf常见错误\n路径拼写错误。 使用了Thymeleaf模板，默认使用了@Controller类的字符串返回类型会被当作转发请求，且返回的字符串不需要带后缀”.html’，因为Thymeleaf会默认去寻找html文件。如果想使用重定向，需要使用：return “redirect:请求路径”。\nthymeleaf获取request、session中的参数错误。 使用thymeleaf表达式 ${…} 获取数据时，一定要确保在到达该页面前一定已经向对应的request、session中放入了要取的数据，否则也会造成错误。 使用 ${对象.属性} 或 ${对象.方法} 获取数据时，一定确保属性名和方法名和Java类中的保持一致，即使少了一个字母也会报错\n\nbackground-image: url() 拼接设置背景\n&lt;div th:style=&quot;&#x27;background:url(&#x27; + @&#123;/&lt;path-to-image&gt;&#125; + &#x27;);&#x27;&quot;&gt;&lt;/div&gt;\n根据属性值改变背景\n&lt;div class=&quot;media-object resource-card-image&quot;  th:style=&quot;&#x27;background:url(&#x27; + @&#123;($&#123;collect.webLogo&#125;==&#x27;&#x27; ? &#x27;img/favicon.png&#x27; : $&#123;collect.webLogo&#125;)&#125; + &#x27;)&#x27;&quot; &gt;&lt;/div&gt;\n\n行内写法（表达式内联）语法：\n&lt;p&gt;Hello, [[$&#123;session.user.name&#125;]]!&lt;/p&gt;\n禁用内联：\n&lt;p th:inline=&quot;none&quot;&gt;A double array looks like this: [[1, 2, 3], [4, 5]]!&lt;/p&gt;","categories":["SpringBoot","html"],"tags":["bootstrap","thymeleaf"]},{"title":"注解与反射","url":"/2021/11/16/zhu-jie-yu-fan-she/","content":"注解Annotation作用：注释和解释（狂神说的，很喜欢，简洁）。被人用来注释代码，并交给JVM去解释执行。\n定义：\n@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation&#123;    public String value();&#125;\n以上就简单自定义了一个注解。在定义注解的时候可以使用其他注解。\n元注解：用来注解注解的注解。四个元注解：\n@Target 确定注解可以使用的地方，如类、接口、方法等@Retention 可以理解为注解的&quot;生命周期&quot;@Documented 此注解会被javadoc工具提取成文档@Inherited 允许子类继承父类中的注解\n\n反射Reflection个人理解：通过Class类去操纵对象的过程就称为反射。代码示例：\n\n","categories":["java"],"tags":["注解","反射"]},{"title":"开发问题汇总","url":"/2022/03/17/kai-fa-wen-ti-hui-zong/","content":"问题1——请路径参数获取问题使用ajax发送请求，在请求路径中拼接了一个参数 calledName ，在后台 controller 方法中使用 request.getAttribute(“calledName”) 获取 calledName ，结果为 null 。换一种方法使用 @RequestParam 注解却能获取到 calledName 的值。原因尚未知，在以后的开发中尽量使用 @RequestParam 注解获取参数值。请求路径中拼接参数的方式，GET 和 POST 都可以使用。\n问题2——ajax回调函数的返回数据data使用 $.ajax() 方式发送 ajax 请求，其中 datatype 的值设为 json，发现最终回调函数不能正常使用，将 datatype 这一参数设置不写，（后台 controller 方法注解是有 @RequestBody 的），回调函数能够正常使用。\n"},{"title":"重载与重写","url":"/2021/11/16/chong-zai-yu-chong-xie/","content":"重载描述：一个类中，同一个方法名，有用多个参数类型或数量不同的方法实现，则称之为方法重载。代码示例：\npublic class A&#123;\tpublic void methodA()&#123;&#125;;\tpublic void methodA(int a)&#123;&#125;;    public void methodA(String str)&#123;&#125;;&#125;\n\n继承定义：\npublic class B extends A&#123;\t&#125;\n类B继承了类A，B拥有A的所有方法（构造方法除外）和属性。类B可以对父类A的方法进行重写，还可以声明父类A没有的属性。构造方法：当父类有多个构造方法时，子类必须声明一个参数列表（可以是无参类型）和父类相同的构造方法，并在方法体的第一行调用父类的其中一个构造方法。注意，当父类只有默认无参构造方法时，子类的默认无参构造方法中默认调用了父类的无参构造方法。当以一个类声明了构造方法，默认的无参构造方法便不存在了。代码示例：\n示例一：public class Father &#123;    public Father()&#123;        System.out.println(&quot;Father&quot;);    &#125;    public Father(String name, String age)&#123;        System.out.println(name + age);    &#125;&#125;class Son extends Father&#123;    public Son(String name) &#123;        super();    &#125;&#125;示例二：public class Father &#123;    public Father()&#123;        System.out.println(&quot;Father&quot;);    &#125;    public Father(String name, String age)&#123;        System.out.println(name + age);    &#125;&#125;class Son extends Father&#123;\t//有默认的无参构造器，而且会默认调用父类的无参构造器\t\tpublic static void main(String[] args)&#123;\t\tnew Son();\t&#125;&#125;输出：Father示例三：public class Father &#123;    public Father(String name)&#123;        System.out.println(name);    &#125;    public Father(String name, String age)&#123;        System.out.println(name + age);    &#125;&#125;class Son extends Father&#123;\tpublic Son(String name)&#123;\t\tsuper(name + &quot;age&quot;);\t&#125;&#125;\n\n重写描述：子类继承父类，并对继承的父类方法进行重新实现的过程，称之为方法重写。\n代码示例\npublic class Father&#123;\tpublic String method1()&#123;\t\treturn &quot;father&quot;;\t&#125;&#125;public class Son extends Father&#123;\tpublic String method1()&#123;\t\treturn &quot;son&quot;\t&#125;&#125;\n\n向上转型与向下转型向上转型描述：把子类的对象实例赋值给父类的引用。代码示例：\npublic class Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;father&quot;);\t&#125;&#125;public class B extends Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;son&quot;);\t&#125;\t\tpublic static void main(String[] args)&#123;\t\tFather f = new Son();\t//向上转型,将子类实例赋值给父类引用。可以理解为把子类对象向上转换成父类对象。 \t\tf.method1();\t//输出结果为&quot;son&quot;,而不是&quot;father&quot;\t&#125;&#125;\n通过向上转型的获得的对象引用，在调用方法时，只能调用父类中已有的方法，但执行的方法体是子类的方法。\n易混淆情况：\npublic class Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;father&quot;);\t&#125;\t\tpublic void method2()&#123;\t\tSystem.out.println(&quot;father.method2&quot;);\t&#125;&#125;public class B extends Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;son&quot;);\t&#125;\t\tpublic static void main(String[] args)&#123;\t\tFather f = new Son();\t//向上转型,将子类实例赋值给父类引用。可以理解为把子类对象向上转换成父类对象。 \t\tf.method2();\t//输出结果为&quot;father.method2&quot;,method2()方法没有被子类B重写，是从父类A中继承过来的，也是类B的方法不要理解为method2不是B的方法。\t&#125;&#125;\n\n代码示例：\npublic class Father &#123;    public String method1()&#123;        return &quot;father&quot;;    &#125;&#125;class Son extends Father&#123;    public String method1()&#123;        return &quot;son&quot;;    &#125;    public String method2()&#123;        return &quot;Son.method2&quot;;    &#125;    public static void main(String[] args)&#123;        Father f = new Son();        //System.out.println(f.method2());\t该行会提示报错，因为f此时是Father类型，没有method2()方法        System.out.println(((Son)f).method2());\t//此时再使用向下转型，便不会报错。输出结果为&quot;Son.method2&quot;    &#125;&#125;\n\n向上转型经典例题class A &#123;    public String show(D obj) &#123;        return (&quot;A and D&quot;);    &#125;    public String show(A obj) &#123;        return (&quot;A and A&quot;);    &#125;&#125;class B extends A&#123;    public String show(B obj)&#123;        return (&quot;B and B&quot;);    &#125;    public String show(A obj)&#123;        return (&quot;B and A&quot;);    &#125;&#125;class C extends B&#123;&#125;class D extends B&#123;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        A a1 = new A();        A a2 = new B();        B b = new B();        C c = new C();        D d = new D();        System.out.println(&quot;1--&quot; + a1.show(b));        System.out.println(&quot;2--&quot; + a1.show(c));        System.out.println(&quot;3--&quot; + a1.show(d));        System.out.println(&quot;4--&quot; + a2.show(b));        System.out.println(&quot;5--&quot; + a2.show(c));        System.out.println(&quot;6--&quot; + a2.show(d));        System.out.println(&quot;7--&quot; + b.show(b));        System.out.println(&quot;8--&quot; + b.show(c));        System.out.println(&quot;9--&quot; + b.show(d));    &#125;&#125;//结果：//1--A and A//2--A and A//3--A and D//4--B and A//5--B and A//6--A and D//7--B and B//8--B and B//9--A and D//能看懂这个结果么？先自分析一下。\n这个例子是非常复杂的啦，要想完全理解后面几个输出结果还要知道一条重要知识：\n继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)(其实按照我前面的理解，感觉这一条原则不要也行，因为子类没有重写的方法是默认继承自父类的，验证了一下例题也没问题)\n对于输出4，a2.show(b))的输出结果是”B and A”。对象a2是A类型，但是指向B类型实例，为向上转型。a2可执行的方法名为类A中的方法，public String show(D obj)和public String show(A obj)；\n继承链第一步：this.show(O)显然不行，因为对象b是B类型，可执行方法中没有符合要求的。继承链第二步：super.show(O)，显然没有符合要求的。继承链第三步：this.show((super)O)，即shou((A) b)，执行类B中的方法show(A obj)，输出&quot;B and A&quot;\n对于输出5，分析同输出4，略。对于输出6，a2.show(d))的输出结果为”A and D”，也很好理解。\n继承链第一步：this.show(O)显然可以，因为类B继承了类A的public String show(D obj)方法，\n\n\n\n参考博文\n","categories":["java"]},{"title":"SpringBoot源码笔记","url":"/2022/01/19/springboot-yuan-ma-bi-ji/","content":"静态资源默认路径项目资源文件夹resources下：/META-INF/resources/、/resources/、/static/、/public/ 共四个路径。即使是使用了thymeleaf模板的情况下，放在以上路径下的静态资源仍然可以被访问，而且在这些路径下的html页面中使用thymeleaf语法同样有效。（thymeleaf似乎值对拦截再templates路径下的资源访问进行拦截设置）源码探究：\npackage org.springframework.boot.autoconfigure.web;@ConfigurationProperties(&quot;spring.web&quot;)public class WebProperties &#123;\tpublic static class Resources &#123;\t\tprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;\t&#125;&#125;\n自定义资源路径注解@ConfigurationProperties(“spring.web”)，WebProperties类下的属性和配置文件进行了绑定，在配置文件application.properties中即可自定义静态资源访问路径。\n##由于CLASSPATH_RESOURCE_LOCATIONS被final修饰，所以不能修改##类属性和配置文件的对应规则：spring.web为注解设置前缀，resource对应内部类Resources的类名，static-locations对应类属性staticLocationsspring.web.resources.static-locations = 自定义资源路径\n源码探究：\npackage org.springframework.boot.autoconfigure.web;@ConfigurationProperties(&quot;spring.web&quot;)public class WebProperties &#123;\tpublic static class Resources &#123;\t\tprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;\t\tprivate String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;\t&#125;&#125;\n\n资源访问前缀默认访问前缀：/源码探究：\n@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)public class WebMvcProperties &#123;\tpublic static class Servlet &#123;\t\t/**\t\t * Path of the dispatcher servlet. Setting a custom value for this property is not\t\t * compatible with the PathPatternParser matching strategy.\t\t */\t\tprivate String path = &quot;/&quot;;\t&#125;&#125;\n自定义访问前缀：\nspring.web.servlet.path = 自定义前缀（注意要“/”结尾）\n\n\nweb请求处理过程所有web请求都会进入到 org.springframework.web.servlet 包下的 DispatcherServlet 类的 doDispatch(HttpServletRequest request, HttpServletResponse response) 方法中\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\tHttpServletRequest processedRequest = request;\tHandlerExecutionChain mappedHandler = null;\t    boolean multipartRequestParsed = false;\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\t\ttry &#123;\t\t\tModelAndView mv = null;\t\tException dispatchException = null;\t\ttry &#123;\t\t\tprocessedRequest = checkMultipart(request);\t\t\tmultipartRequestParsed = (processedRequest != request);\t\t\t// Determine handler for the current request.\t\t\t//***获取映射处理器，进入该方法可以看到所有的请求路径映射***\t\t\tmappedHandler = getHandler(processedRequest);\t\t\tif (mappedHandler == null) &#123;\t\t\t\tnoHandlerFound(processedRequest, response);\t\t\t\treturn;\t\t\t&#125;\t\t\t// Determine handler adapter for the current request.\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\t\t\t// Process last-modified header, if supported by the handler.\t\t\tString method = request.getMethod();\t\t\tboolean isGet = HttpMethod.GET.matches(method);\t\t\tif (isGet || HttpMethod.HEAD.matches(method)) &#123;\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;\t\t\t\treturn;\t\t\t&#125;\t\t\t//***（1）***             //***真正要开始处理请求映射的方法***\t\t\t// Actually invoke the handler.\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\t\t\tif (asyncManager.isConcurrentHandlingStarted()) &#123;\t\t\t\treturn;\t\t\t&#125;\t\t\tapplyDefaultViewName(processedRequest, mv);\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\t\t&#125;\t\tcatch (Exception ex) &#123;\t\t\tdispatchException = ex;\t\t&#125;\t\tcatch (Throwable err) &#123;\t\t\t// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\t\t\tdispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);\t\t&#125;\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\t&#125;\tcatch (Exception ex) &#123;\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\t&#125;\tcatch (Throwable err) &#123;\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\t\t\tnew NestedServletException(&quot;Handler processing failed&quot;, err));\t&#125;\tfinally &#123;\t\tif (asyncManager.isConcurrentHandlingStarted()) &#123;\t\t\t// Instead of postHandle and afterCompletion\t\t\tif (mappedHandler != null) &#123;\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\t\t\t&#125;\t\t&#125;\t\telse &#123;\t\t\t// Clean up any resources used by a multipart request.\t\t\tif (multipartRequestParsed) &#123;\t\t\t\tcleanupMultipart(processedRequest);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n执行 mappedHandler = getHandler(processedRequest) ，进入到 getHandler() 方法\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;\tif (this.handlerMappings != null) &#123;\t\t//***mapping中包含了所有的请求路径，和请求路径映射的方法。\t\tfor (HandlerMapping mapping : this.handlerMappings) &#123;\t\t\tHandlerExecutionChain handler = mapping.getHandler(request);\t\t\tif (handler != null) &#123;\t\t\t\treturn handler;\t\t\t&#125;\t\t&#125;\t&#125;\treturn null;&#125;\nthis.handlerMappings:    mapping:    包含了所有请求路径和请求路径的映射方法        \n执行 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()) 时，会进入到 AbstractHandlerMethodAdapter 类的 handle(HttpServletRequest request, HttpServletResponse response, Object handler) 方法中（共有四个HandleMethodAdapter， 分别是…）。\npublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\t\t\tthrows Exception &#123;\t\treturn handleInternal(request, response, (HandlerMethod) handler);\t&#125;\n接着进入到 RequestMappingHandlerAdapter 类的 handleInternal(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod) 方法\nprotected ModelAndView handleInternal(HttpServletRequest request,\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;\tModelAndView mav;\tcheckRequest(request);\t// Execute invokeHandlerMethod in synchronized block if required.\tif (this.synchronizeOnSession) &#123;\t\tHttpSession session = request.getSession(false);\t\tif (session != null) &#123;\t\t\tObject mutex = WebUtils.getSessionMutex(session);\t\t\tsynchronized (mutex) &#123;\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\t\t\t&#125;\t\t&#125;\t\telse &#123;\t\t\t// No HttpSession available -&gt; no mutex necessary\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\t\t&#125;\t&#125;\telse &#123;         //***(2)***         //***开始进入请求方法执行流程***\t\t// No synchronization on session demanded at all...\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\t&#125;\t\tif (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;\t\tif (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;\t\t\tapplyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\t\t&#125;\t\telse &#123;\t\t\tprepareResponse(response);\t\t&#125;\t&#125;\treturn mav;&#125;\n\n执行 mav = invokeHandlerMethod(request, response, handlerMethod) 进入到同类中的 invokeHandlerMethod(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod) 方法。\nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;\tServletWebRequest webRequest = new ServletWebRequest(request, response);\ttry &#123;\t\tWebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\t\tModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\t\tServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\t\tif (this.argumentResolvers != null) &#123;\t\t\t\t\t\t  //***设置请求方法的参数解析器***invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\t\t&#125;\t\tif (this.returnValueHandlers != null) &#123;//***设置请求方法的返回值处理器***invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\t\t&#125;\t\tinvocableMethod.setDataBinderFactory(binderFactory);\t\tinvocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\t\tmavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\t\tmodelFactory.initModel(webRequest, mavContainer, invocableMethod);\t\tmavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\t\tAsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\t\tasyncWebRequest.setTimeout(this.asyncRequestTimeout);\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\t\tasyncManager.setTaskExecutor(this.taskExecutor);\t\tasyncManager.setAsyncWebRequest(asyncWebRequest);\t\tasyncManager.registerCallableInterceptors(this.callableInterceptors);\t\tasyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\t\tif (asyncManager.hasConcurrentResult()) &#123;\t\t\tObject result = asyncManager.getConcurrentResult();\t\t\tmavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];\t\t\tasyncManager.clearConcurrentResult();\t\t\tLogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;\t\t\t\tString formatted = LogFormatUtils.formatValue(result, !traceOn);\t\t\t\treturn &quot;Resume with async result [&quot; + formatted + &quot;]&quot;;\t\t\t&#125;);\t\t\tinvocableMethod = invocableMethod.wrapConcurrentResult(result);\t\t&#125;        //***(3)***        //***开始处理请求方法的参数、试图等\t\tinvocableMethod.invokeAndHandle(webRequest, mavContainer);\t\tif (asyncManager.isConcurrentHandlingStarted()) &#123;\t\t\treturn null;\t\t&#125;\t\treturn getModelAndView(mavContainer, modelFactory, webRequest);\t&#125;\tfinally &#123;\t\twebRequest.requestCompleted();&#125;\n请求方法参数解析器 ：请求方法返回值处理器：\n执行 invocableMethod.invokeAndHandle(webRequest, mavContainer)，进入到 ServletInvocableHandlerMethod 类下的 invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,Object… providedArgs) 方法。\npublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\t\tObject... providedArgs) throws Exception &#123;    //***(4)***    //***对请求方法选择支持的参数类型解析器（可能不准确）***\tObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\tsetResponseStatus(webRequest);\tif (returnValue == null) &#123;\t\tif (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123;\t\t\tdisableContentCachingIfNecessary(webRequest);\t\t\tmavContainer.setRequestHandled(true);\t\t\treturn;\t\t&#125;\t&#125;\telse if (StringUtils.hasText(getResponseStatusReason())) &#123;\t\tmavContainer.setRequestHandled(true);\t\treturn;\t&#125;\tmavContainer.setRequestHandled(false);\tAssert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;);\ttry &#123;\t\tthis.returnValueHandlers.handleReturnValue(\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\t&#125;\tcatch (Exception ex) &#123;\t\tif (logger.isTraceEnabled()) &#123;\t\t\tlogger.trace(formatErrorForReturnValue(returnValue), ex);\t\t&#125;\t\tthrow ex;\t&#125;&#125;\n\n执行 Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs) ，进入 InvocableHandlerMethod 类下的 invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object… providedArgs) 方法。\npublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\t\tObject... providedArgs) throws Exception &#123;\t//***(5)***\tObject[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\tif (logger.isTraceEnabled()) &#123;\t\tlogger.trace(&quot;Arguments: &quot; + Arrays.toString(args));\t&#125;\treturn doInvoke(args);&#125;\n\n执行 Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs) ，进入到同类下的 getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object… providedArgs) 方法。\nprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\t\tObject... providedArgs) throws Exception &#123;\tMethodParameter[] parameters = getMethodParameters();\tif (ObjectUtils.isEmpty(parameters)) &#123;\t\treturn EMPTY_ARGS;\t&#125;\t\t//***(6)***\t//***开始遍历请求方法的参数列表,按照参数列表的数量创建一个对象数组args，args中的的每个元素后来都会转化为对应的参数列表中的对象类型***\tObject[] args = new Object[parameters.length];\tfor (int i = 0; i &lt; parameters.length; i++) &#123;\t\tMethodParameter parameter = parameters[i];\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\t\targs[i] = findProvidedArgument(parameter, providedArgs);\t\tif (args[i] != null) &#123;\t\t\tcontinue;\t\t&#125;\t\t//***(7)***\t\t//判断resolvers中是否有支持当前参数的resolver\t\tif (!this.resolvers.supportsParameter(parameter)) &#123;\t\t\tthrow new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));\t\t&#125;\t\ttry &#123;\t\t\t//***(8)***\t\t\t//***获取参数类型的对象数组***\t\t\targs[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\t\t&#125;\t\tcatch (Exception ex) &#123;\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\tString exMsg = ex.getMessage();\t\t\t\tif (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\t\t\t\t&#125;\t\t\t&#125;\t\t\tthrow ex;\t\t&#125;\t&#125;\treturn args;&#125;\n\n执行 args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory) \npublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;\t//***(9)***\t//***获取参数解析器***\tHandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);\tif (resolver == null) &#123;\t\tthrow new IllegalArgumentException(&quot;Unsupported parameter type [&quot; +\t\t\t\tparameter.getParameterType().getName() + &quot;]. supportsParameter should be called first.&quot;);\t&#125;\t\t//***这一部像是递归，还没搞懂该行的作用***\treturn resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);&#125;\n\n执行 HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter) \nprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123;\tHandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);\tif (result == null) &#123;\t\t//***(10)***\t\t//***遍历所有的参数类型解析器，找到支持该参数的解析器***\t\tfor (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123;\t\t\tif (resolver.supportsParameter(parameter)) &#123;\t\t\t\tresult = resolver;\t\t\t\tthis.argumentResolverCache.put(parameter, result);\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;\treturn result;&#125;\n\n\n内容协商机制内容协商：协商浏览器能接受的数据类型和服务端能生产的数据类型（数据类型值的是数据的格式，例如XML和JSON等）在SpringBoot中，内容协商流程发生在返回值处理器中。请求的响应过程中，会得到支持请求路径映射的方法返回值的返回值处理器HandlerMethodReturnValueHandler ，接着进入到 HandlerMethodReturnValueHandler 具体实现类中，执行 handleReturnValue() 方法。以 RequestResponseBodyMethodProcessor 为例。\npublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;\t\tmavContainer.setRequestHandled(true);\t\tServletServerHttpRequest inputMessage = createInputMessage(webRequest);\t\tServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\t\t// Try even with null return value. ResponseBodyAdvice could get involved.\t\twriteWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\t&#125;\n进入 writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage) \nprotected &lt;T&gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;\t\tObject body;\t\tClass&lt;?&gt; valueType;\t\tType targetType;\t\tif (value instanceof CharSequence) &#123;\t\t\tbody = value.toString();\t\t\tvalueType = String.class;\t\t\ttargetType = String.class;\t\t&#125;\t\telse &#123;\t\t\tbody = value;\t\t\tvalueType = getReturnValueType(body, returnType);\t\t\ttargetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\t\t&#125;\t\tif (isResourceType(value, returnType)) &#123;\t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, &quot;bytes&quot;);\t\t\tif (value != null &amp;&amp; inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null &amp;&amp;\t\t\t\t\toutputMessage.getServletResponse().getStatus() == 200) &#123;\t\t\t\tResource resource = (Resource) value;\t\t\t\ttry &#123;\t\t\t\t\tList&lt;HttpRange&gt; httpRanges = inputMessage.getHeaders().getRange();\t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\t\t\t\t\tbody = HttpRange.toResourceRegions(httpRanges, resource);\t\t\t\t\tvalueType = body.getClass();\t\t\t\t\ttargetType = RESOURCE_REGION_LIST_TYPE;\t\t\t\t&#125;\t\t\t\tcatch (IllegalArgumentException ex) &#123;\t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, &quot;bytes */&quot; + resource.contentLength());\t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tMediaType selectedMediaType = null;\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\t\tboolean isContentTypePreset = contentType != null &amp;&amp; contentType.isConcrete();\t\tif (isContentTypePreset) &#123;\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\tlogger.debug(&quot;Found &#x27;Content-Type:&quot; + contentType + &quot;&#x27; in response&quot;);\t\t\t&#125;\t\t\tselectedMediaType = contentType;\t\t&#125;\t\telse &#123;\t\t\tHttpServletRequest request = inputMessage.getServletRequest();\t\t\tList&lt;MediaType&gt; acceptableTypes;\t\t\ttry &#123;\t\t\t\t//***得到浏览器可接受的媒体类型***\t\t\t\t//***进入getAcceptableMediaTypes方法，可获取使用哪种内容协商策略ContentNegotiationStrategy***\t\t\t\tacceptableTypes = getAcceptableMediaTypes(request);\t\t\t&#125;\t\t\tcatch (HttpMediaTypeNotAcceptableException ex) &#123;\t\t\t\tint series = outputMessage.getServletResponse().getStatus() / 100;\t\t\t\tif (body == null || series == 4 || series == 5) &#123;\t\t\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\t\t\tlogger.debug(&quot;Ignoring error response content (if any). &quot; + ex);\t\t\t\t\t&#125;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t\tthrow ex;\t\t\t&#125;\t\t\t\t\t\t//***得到服务端可生产的媒体类型***\t\t\tList&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\t\t\tif (body != null &amp;&amp; producibleTypes.isEmpty()) &#123;\t\t\t\tthrow new HttpMessageNotWritableException(\t\t\t\t\t\t&quot;No converter found for return value of type: &quot; + valueType);\t\t\t&#125;\t\t\t\t\t\t//***遍历两种媒体类型，得到双方可以匹配的媒体类型***\t\t\tList&lt;MediaType&gt; mediaTypesToUse = new ArrayList&lt;&gt;();\t\t\tfor (MediaType requestedType : acceptableTypes) &#123;\t\t\t\tfor (MediaType producibleType : producibleTypes) &#123;\t\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) &#123;\t\t\t\t\t\tmediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (mediaTypesToUse.isEmpty()) &#123;\t\t\t\tif (body != null) &#123;\t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleTypes);\t\t\t\t&#125;\t\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\t\tlogger.debug(&quot;No match for &quot; + acceptableTypes + &quot;, supported: &quot; + producibleTypes);\t\t\t\t&#125;\t\t\t\treturn;\t\t\t&#125;\t\t\t\t\t\t//***按照权重等规则进行排序***\t\t\tMediaType.sortBySpecificityAndQuality(mediaTypesToUse);\t\t\t//***确定最佳匹配的媒体类型***\t\t\tfor (MediaType mediaType : mediaTypesToUse) &#123;\t\t\t\tif (mediaType.isConcrete()) &#123;\t\t\t\t\tselectedMediaType = mediaType;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\telse if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) &#123;\t\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\tlogger.debug(&quot;Using &#x27;&quot; + selectedMediaType + &quot;&#x27;, given &quot; +\t\t\t\t\t\tacceptableTypes + &quot; and supported &quot; + producibleTypes);\t\t\t&#125;\t\t&#125;\t\tif (selectedMediaType != null) &#123;\t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\t\t\t//***根据最终匹配的媒体类型，遍历寻找支持的消息转换器Converter\t\t\tfor (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123;\t\t\t\tGenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?\t\t\t\t\t\t(GenericHttpMessageConverter&lt;?&gt;) converter : null);\t\t\t\tif (genericConverter != null ?\t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :\t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) &#123;\t\t\t\t\tbody = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\t\t\t\t\t\t\t(Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),\t\t\t\t\t\t\tinputMessage, outputMessage);\t\t\t\t\tif (body != null) &#123;\t\t\t\t\t\tObject theBody = body;\t\t\t\t\t\tLogFormatUtils.traceDebug(logger, traceOn -&gt;\t\t\t\t\t\t\t\t&quot;Writing [&quot; + LogFormatUtils.formatValue(theBody, !traceOn) + &quot;]&quot;);\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\t\t\t\t\t\tif (genericConverter != null) &#123;\t\t\t\t\t\t//***执行消息转换器的 write 方法***\t\t\t\t\t\t\tgenericConverter.write(body, targetType, selectedMediaType, outputMessage);\t\t\t\t\t\t&#125;\t\t\t\t\t\telse &#123;\t\t\t\t\t\t//***执行消息转换器的 write 方法***\t\t\t\t\t\t\t((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t\telse &#123;\t\t\t\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\t\t\t\tlogger.debug(&quot;Nothing to write: null body&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tif (body != null) &#123;\t\t\tSet&lt;MediaType&gt; producibleMediaTypes =\t\t\t\t\t(Set&lt;MediaType&gt;) inputMessage.getServletRequest()\t\t\t\t\t\t\t.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\t\t\tif (isContentTypePreset || !CollectionUtils.isEmpty(producibleMediaTypes)) &#123;\t\t\t\tthrow new HttpMessageNotWritableException(\t\t\t\t\t\t&quot;No converter for [&quot; + valueType + &quot;] with preset Content-Type &#x27;&quot; + contentType + &quot;&#x27;&quot;);\t\t\t&#125;\t\t\tthrow new HttpMediaTypeNotAcceptableException(getSupportedMediaTypes(body.getClass()));\t\t&#125;\t&#125;\nacceptableTypes = getAcceptableMediaTypes(request) ，确定内容协商策略，进而根据策略获取浏览器可接受的媒体类型\nprivate List&lt;MediaType&gt; getAcceptableMediaTypes(HttpServletRequest request)\t\t\tthrows HttpMediaTypeNotAcceptableException &#123;\t\treturn this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));\t&#125;\npublic List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException &#123;\t\tfor (ContentNegotiationStrategy strategy : this.strategies) &#123;\t\t\tList&lt;MediaType&gt; mediaTypes = strategy.resolveMediaTypes(request);\t\t\tif (mediaTypes.equals(MEDIA_TYPE_ALL_LIST)) &#123;\t\t\t\tcontinue;\t\t\t&#125;\t\t\treturn mediaTypes;\t\t&#125;\t\treturn MEDIA_TYPE_ALL_LIST;\t&#125;\n此时只有一种默认的协商策略，基于request请求头的协商策略：HeaderContentNegotiationStrategy。也可以添加其他的内容协商策略，如在配置文件中开启基于请求参数的协商策略，也可以自定义协商策略。\n\n\n消息转换器Converter：\n开启支持XML格式数据：导入依赖\n&lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;            &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt;\n\n开启基于请求参数的内容协商策略，配置文件中配置相应属性值。此时发送的请求中要附带一个 format 的字段，例如 http://localhost:8080/test/person?format=json 和http://localhost:8080/test/person?format=xml\nspring.contentnegotiation.favor-parameter=true\n\n自定义内容协商策略\n"},{"title":"ideas","url":"/2022/04/15/ideas/","content":"redis实现单点的登录单点登录：我的理解单点登录是同一个账号只能在一台设备上登陆。思路：redis中有种数据类型 bitmap 二进制位来进行记录，只有0、1两种状态。可以根据用户 id 来将对应的位设为1，每次登陆时检查与 id 相对应的位是否为0。退出登录时要将对应的位设置为 0。\n"},{"title":"SpringCloud学习笔记","url":"/2022/07/15/springcloud-xue-xi-bi-ji/","content":"EureKaEureKa注册中心\nmaven依赖&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\t&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;\n使用注解@EnableEureKa编写Application启动类\n添加配置信息server:\tport: 10086spring:\tapplication:\t\tname: eurekaservereureka:\tclient:\t\tservice-url:\t\t\tdefaultZone: http://127.0.0.1:10086/eureka/\nEureKa服务者注册\nmaven依赖&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\t&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n添加配置信息server:\tport: 10086spring:\tapplication:\t\tname: client1eureka:\tclient:\t\tservice-url:\t\t\tdefaultZone: http://127.0.0.1:10086/client1/\nEureKa消费者注册步骤同服务者注册。但需添加http请求模块，以便于向其他微服务模块发送请求。@Bean@LoadBalanced\t//一个微服务模块有多个实例时，开启负载均衡public RestTemplate restTemplate()&#123;\treturn new RestTemplate();&#125;\n发送请求时，使用注册时的服务名代替 ip 和端口，egString url = &quot;http://servicename/user/&quot; + order.getUserId();\nRibbonEureKa的负载均衡组件。选择负载均衡策略方式一：手动添加负载均衡组件 IRule。这种配置方式是全局的，无论调用哪一个微服务都会采用该策略。//选择随机策略的组件@Beanpublic IRule randomRule()&#123;\treturn new RandomRule();&#125;\n方式二：配置文件方式。该方式只对被配置的微服务生效。userservice:\tribbon:\t\tNFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\n加载方式Ribbon默认采用懒加载方式，即接受到第一次请求后才开始加载。开启饥饿加载，即启动时加载。ribbon:\teager-load:\t\tenabled: true #开启饥饿加载\t\tclients: userservice #指定劝userservice这个服务饥饿加载\nNacos\n下载Nacos\n项目父工程引入依赖&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;    &lt;type&gt;pom&lt;/type&gt;    &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;\n微服务引入Nacos依赖&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;\n微服务配置Nacosspring:\tcloud:\t\tnacos:\t\t\tserver-addr: localhost:8848\nNacos集群Nacos默认优先访问同一集群下的微服务，多个微服务实例间是随机访问。当本地微服务不可用时会发生跨集群访问。集群配置spring:\tcloud:\t\tnacos:\t\t\tserver-addr: localhost:8848\t\t\tdiscovery:\t\t\t\tcluster-name: HZ #集群名称\n设置负载均衡方式userservice:\tribbon:\t\tNFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule\nNacos环境隔离在Nacos控制台进行环境管理，不同环境下的微服务之间是相互隔离的，无法访问。配置临时实例为true，开启注册中心主动询问微服务实例状态，频率较高，对服务器的开销比较大。临时实例为false，微服务实例主动向注册中心发送心跳信息，频率较低，开销较小。与EureKa不同，如果Nacos注册中心发现有一个微服务实例不可用，则会主动向消费者推送信息，更新微服务实例列表。Nacos配置管理远程环境配置\n在Nacos控制台创建配置文件 eg：userservice-dev.yml\n在微服务实例中添加bootstrap.yml文件，将需要从 application.yml 剥离的配置信息改到 bootstrap.yml ，例如Nacos地址，微服务名称等（springboot 会优先加载 bootstrap.yml，然后再加载 application.yml）\n配置热更新方式一：使用 @Value 和 @RefreshScope 刷新方式二：使用 @ConfigurationProperties 实现远程共享配置多个实例间共享设置，eg：userservice.yml配置生效优先级：远程环境配置 &gt; 远程共享配置 &gt; 本地配置\n集群搭建\n搭建MySQL集群并初始化数据库表\n下载解压nacos\n修改集群配置（节点信息）、数据库配置\n分别启动多个nacos节点\nnginx反向代理Feign较RestTemplate更为强大的http客户端。使用步骤：\n引入 maven 依赖&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\t&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;\n启动类添加 @EnableFeignClients 注解\n编写 FeignClient 接口@FeignClient(&quot;userservice&quot;)public interface UserClient &#123;\t@GetMapping(&quot;/user/&#123;id&#125;&quot;) \tUser findById(@PathVariable(&quot;id&quot;) Long id);&#125;\n使用 FeginClientFeign日志级别方式一：配置文件方式\n全局生效feign:\tclient:\t\tconfig:\t\t\tdefault: #对所有微服务生效\t\t\t\tloggerLevel: FULL #  日志级别 \n局部生效feign:\tclient:\t\tconfig:\t\t\tuserservice: #只对userservice生效\t\t\t\tloggerLevel: FULL #  日志级别 \n方式二：代码方式public class FeignClientConfiguration &#123;\t@Bean\tpublic Logger.Level feignLogLevel()&#123;\t\treturn Logger.Level.BASIC;\t&#125;&#125;\n全局配置，则把它放到@EnableFeignClients这个注解中：@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)\n局部配置，则把它放到@FeignClient这个注解中：@FeignClient(value = &quot;userservice&quot;, configuration = FeignClientConfiguration.class) \n设置Feign底层Http客户端Feign底层的客户端实现： URLConnection：默认实现，不支持连接池 Apache HttpClient ：支持连接池 OKHttp：支持连接池配置HttpClient\n引入maven依赖&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt;\t&lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;\t&lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt;\n配置连接池feign:\tclient:\t\tconfig:\t\t\tdefault: # default全局的配置\t\t\tloggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息\thttpclient:\t\tenabled: true # 开启feign对HttpClient的支持\t\tmax-connections: 200 # 最大的连接数\t\tmax-connections-per-route: 50 # 每个路径的最大连接数\n抽取FeignClient模块ps：也可以选择继承父接口的方式。\n首先创建一个module，命名为feign-api，然后引入feign的starter依赖\n将order-service中编写的UserClient、User等要抽取的内容都复制到feign-api项目中\n在order-service（需要使用feign-api）中引入feign-api的依赖\n修改order-service，改成导入feign-api中的包\n指定加载FeignClient类//方式一@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)\t//扫描FeignClient所在整个模块//方式二@EnableFeignClients(clients = &#123;UserClient.class&#125;)\t//直接指定加载FeignClient\n重启测试网关Gateway使用步骤：\n创建项目，引入依赖&lt;!--网关依赖--&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\t&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt;\t&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\t&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;\n编写路由配置及nacos地址server:  port: 10010 # 网关端口spring:  application:    name: gateway # 服务名称  cloud:    nacos:      server-addr: localhost:8848 # nacos地址    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求\nGateway路由断言工厂Gateway提供多种断言工厂——Route Predicate Factory，对进入的请求进行判断。\n路由过滤器GatewayFilter对进入网关的请求和微服务返回的响应做处理。\neg: 给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!spring:\tcloud:\t\tgateway:\t\t\troutes: # 网关路由配置                - id: user-service                  uri: lb://userservice                  predicates:                    - Path=/user/**                  filters: # 过滤器                    - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头\n默认过滤器：对所有的路由都生效，将过滤器工厂写到default下。spring:\tapplication:\t\tname: gateway # 服务名称\tcloud:\t\tnacos:\t\t\tserver-addr: localhost:8848 # nacos地址\t\t\tgateway:\t\t\t\troutes: # 网关路由配置                    - id: user-service                       uri: lb://userservice                      predicates:                        - Path=/user/**                    - id: order-service                      uri: lb://orderservice                      predicates:                        - Path=/order/**\t\t\t\tdefault-filters: # 默认过滤器，会对所有的路由请求都生效\t\t\t\t\t\t\t- AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头\n自定义全局过滤器GlobalFilter处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。自定义过滤器的代码处理逻辑，需要实现GlobalFilter接口。public interface GlobalFilter &#123;\t/**\t*  处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理    *    * @param exchange 请求上下文，里面可以获取Request、Response等信息    * @param chain 用来把请求委托给下一个过滤器     * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束    */    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125;/*** 定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件* 参数中是否有authorization* authorization参数值是否为admin,如果同时满足则放行，否则拦截*/@Order(-1)\t//让类实现Ordered接口，实现接口方法与使用注解效果是一样的@Componentpublic class AuthorizeFilter implements GlobalFilter &#123;\t@Override\tpublic Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        // 1.获取请求参数        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();        // 2.获取authorization参数        String auth = params.getFirst(&quot;authorization&quot;);        // 3.校验        if (&quot;admin&quot;.equals(auth)) &#123;        // 放行        return chain.filter(exchange);        &#125;        // 4.拦截        // 4.1.禁止访问 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);        // 4.2.结束处理        return exchange.getResponse().setComplete();\t&#125;&#125;\n过滤器执行顺序\norder值越小，优先级越高\n当order值一样时，顺序是defaultFilter最先，然后是局部的路由过滤器，最后是全局过滤器跨域问题浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题。解决方案：CORSspring:\tcloud:\t\tgateway:\t\t\tglobalcors: # 全局的跨域处理\t\t\t\tadd-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\t\t\t\tcorsConfigurations:\t\t\t\t\t&#x27;[/**]&#x27;:\t\t\t\t\t\tallowedOrigins: # 允许哪些网站的跨域请求\t\t\t\t\t\t\t- &quot;http://localhost:8090&quot;\t\t\t\t\t\t\t- &quot;http://www.leyou.com&quot;\t\t\t\t\t\tallowedMethods: # 允许的跨域ajax的请求方式                        \t- &quot;GET&quot;                                   \t- &quot;POST&quot;                        \t- &quot;DELETE&quot;                        \t- &quot;PUT&quot;                        \t- &quot;OPTIONS&quot;\t\t\t\t\t\tallowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息\t\t\t\t\t\tallowCredentials: true # 是否允许携带cookie     \t\t\t\t\t\t\tmaxAge: 360000 # 这次跨域检测的有效期\nDocker基本操作\n拉取镜像docker pull nginx\t//不写版本号默认拉取最新版\n查看镜像docker images\n删除镜像docker rmi nginx:latest````4. 保存、导入镜像\ndocker save -o [保存的目标文件名称] [镜像名称]eg:docker save -o nginx.tar nginx:latest5. 加载镜像\ndocker load -i nginx.tar## 容器操作&#123;% asset_img 004.jpg %&#125;- 运行：进程正常运行- 暂停：进程暂停，CPU不再运行，并不释放内存- 停止：进程终止，回收进程占用的内存、CPU等资源1. 创建容器\ndocker run –name containerName -p 80:80 -d nginxps:containName 为容器所取名称\n\n-p 映射端口，左侧为主机端口，右侧为容器端口-d 后台运行容器nginx 要运行的镜像名称\n&#123;% asset_img 005.jpg %&#125;2. 暂停容器\ndocker pause containerName\n3. 容器取消暂停状态，恢复运行\ndocker unpause containerName\n4. 停止容器\ndocker stop containerName\n5. 容器取消停止，再次运行\ndocker start containerName\n6. 删除容器\ndocker rm containerName\n7. 进入容器\ndocker exec -it mn bashps:-it 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互mn 进入的容器的名称bash 进入容器后执行的命令，bash是一个linux终端交互命令\n8. 查看容器日志\ndocker logsps:-f 持续查看日志\n9. 查看容器状态\ndocker psps:-a 查看所有容器（包括已停止）\n## 数据卷**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。&#123;% asset_img 006.jpg %&#125;一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了1. 创建数据卷\ndocker volume create html\n2. 查看所有数据卷\ndocker volume ls\n3. 查看数据卷详细信息\ndocker volume inspect html\n4. 删除数据卷删除未使用的数据卷\ndocker volume prune \n删除指定数据卷\ndocker volume rm html\n5. 挂载数据卷\ndocker run   –name mn   -v html:/root/html   -p 8080:80   nginx ps:-v html:/root/htm 把html数据卷挂载到容器内的/root/html这个目录中\n6. 容器直接挂载主机目录\ndocker run   –name mn   -v [宿主机目录]:[容器内目录]   -p 8080:80   nginx \\\n&#123;% asset_img 007.jpg %&#125;## Dockerfile**Dockerfile**就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。&#123;% asset_img 008.jpg %&#125;Dockerfile文件告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。&#123;% asset_img 009.jpg %&#125;### 构建镜像新建文件夹及准备好相关文件。&#123;% asset_img 010.jpg %&#125;Dockerfile内容如下\n指定基础镜像  FROM ubuntu:16.04\n配置环境变量，JDK的安装目录  ENV JAVA_DIR=/usr/local\n拷贝jdk和java项目的包  COPY ./jdk8.tar.gz $JAVA_DIR/  COPY ./docker-demo.jar /tmp/app.jar\n安装JDK  RUN cd $JAVA_DIR    &amp;&amp; tar -xf ./jdk8.tar.gz    &amp;&amp; mv ./jdk1.8.0_144 ./java8\n配置环境变量  ENV JAVA_HOME=$JAVA_DIR/java8  ENV PATH=$PATH:$JAVA_HOME/bin\n暴露端口  EXPOSE 8090\n入口，java项目的启动命令  ENTRYPOINT java -jar /tmp/app.jar\n### 基于镜像构建镜像由于Docker的分层结构，因此我们可以在别人镜像的基础上制作自己的镜像。基于java:8-alpine镜像，将一个Java项目构建为镜像。- 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile- 拷贝课前资料提供的docker-demo.jar到这个目录中- 编写Dockerfile文件：  - 基于java:8-alpine作为基础镜像  - 将app.jar拷贝到镜像中  - 暴露端口  - 编写入口ENTRYPOINT\nFROM java:8-alpine\nCOPY ./app.jar /tmp/app.jar\nEXPOSE 8090\nENTRYPOINT java -jar /tmp/app.jar\n\n## DockerComposeDocker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！### DockerCompose下载安装详细见官网https://docs.docker.com/compose/### 部署集群案例eg：将之前学习的cloud-demo微服务集群利用DockerCompose部署- 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件- 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名- 使用maven打包工具，将项目中的每个微服务都打包为app.jar- 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中- 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署#### 1. compose文件查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：&#123;% asset_img 011.jpg %&#125;```yamlversion: &quot;3.2&quot;services:  nacos:    image: nacos/nacos-server    environment:      MODE: standalone    ports:      - &quot;8848:8848&quot;  mysql:    image: mysql:5.7.25    environment:      MYSQL_ROOT_PASSWORD: 123    volumes:      - &quot;$PWD/mysql/data:/var/lib/mysql&quot;      - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;  userservice:    build: ./user-service  orderservice:    build: ./order-service  gateway:    build: ./gateway    ports:      - &quot;10010:10010&quot;\n共有5个service服务：\n\nnacos：作为注册中心和配置中心\nimage: nacos/nacos-server： 基于nacos/nacos-server镜像构建\nenvironment：环境变量\nMODE: standalone：单点模式启动\n\n\nports：端口映射，这里暴露了8848端口\n\n\nmysql：数据库\nimage: mysql:5.7.25：镜像版本是mysql:5.7.25\nenvironment：环境变量\nMYSQL_ROOT_PASSWORD: 123：设置数据库root账户的密码为123\n\n\nvolumes：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据\n\n\nuserservice、orderservice、gateway：都是基于Dockerfile临时构建的mysql目录中可已经准备好了cloud_order、cloud_user表。查看微服务目录，可以看到都包含Dockerfile文件：FROM java:8-alpineCOPY ./app.jar /tmp/app.jarENTRYPOINT java -jar /tmp/app.jar\n2. 修改微服务配置因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。spring:  datasource:    url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false    username: root    password: 123    driver-class-name: com.mysql.jdbc.Driver  application:    name: orderservice  cloud:    nacos:      server-addr: nacos:8848 # nacos服务地址\n3. 打包接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：&lt;build&gt;  &lt;!-- 服务打包的最终名称 --&gt;  &lt;finalName&gt;app&lt;/finalName&gt;  &lt;plugins&gt;    &lt;plugin&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;    &lt;/plugin&gt;  &lt;/plugins&gt;&lt;/build&gt;\n\n4. 拷贝jar包到部署目录编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，不要搞错。eg：order-service\n5. 部署最后将文件整个cloud-demo文件夹上传到虚拟机中，由DockerCompose部署。可上传到任意目录。部署：进入cloud-demo目录，然后运行下面的命令：docker-compose up -d\nDocker镜像仓库简化版镜像仓库docker run -d \\    --restart=always \\    --name registry\t\\    -p 5000:5000 \\    -v registry-data:/var/lib/registry \\    registry\n命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像。\n\n图形界面镜像仓库使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：\nversion: &#x27;3.0&#x27;services:  registry:    image: registry    volumes:      - ./registry-data:/var/lib/registry  ui:    image: joxit/docker-registry-ui:static    ports:      - 8080:80    environment:      - REGISTRY_TITLE=传智教育私有仓库      - REGISTRY_URL=http://registry:5000    depends_on:      - registry\n配置Docker信任地址我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：\n# 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker\nRabbitMQ安装部署详情请参考官方网站https://www.rabbitmq.com/\n单机部署方式一：镜像安装\ndocker pull rabbitmq:3-management\n方式二：本地文件下载文件后上传到虚拟机，使用以下命令加载镜像\ndocker load -i mq.tar\n运行MQ容器安装成功后，可使用以下命令来运行容器\ndocker run \\ -e RABBITMQ_DEFAULT_USER=itcast \\ -e RABBITMQ_DEFAULT_PASS=123321 \\ --name mq \\ --hostname mq1 \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq:3-management\n集群安装在RabbitMQ的官方文档中，讲述了两种集群的配置方式：\n\n普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。\n镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。详细信息请参考参考官方网站https://www.rabbitmq.com/基本介绍RabbitMQ角色：\n\n\npublisher：生产者\nconsumer：消费者\nexchange个：交换机，负责消息路由\nqueue：队列，存储消息\nvirtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离RabbitMQ基本模型：\n\n"}]