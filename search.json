[{"title":"Java基础","url":"/2021/11/17/java-ji-chu/","content":"JDK版本：jdk11\n静态方法不能通过对象调用，只能通过类名调用。\n静态方法可被子类继承。\n类的int属性如果没有赋初值，则在创建类对象时，会被赋值为0。    JPA可能就是根据对象的id是否为0来判断表中是否存在该对象的记录，从而决定save方法是插入还是修改操作。类的String类型的属性不会再创建对象时被赋默认值，为null。    类的对象类型属性，创建时不会赋予默认值，为null。\n字符串关于字符串，在JVM的底层好像有一个字符串常量池。\npublic class Test &#123;    A a;    static class A&#123;        int id;        String name;        public void setName(String name) &#123;            this.name = name;        &#125;        public String getName() &#123;            return name;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public int getId() &#123;            return id;        &#125;    &#125;    public static void main(String[] args) &#123;         A a = new A();         a.setName(&quot;name&quot;);        System.out.println(a.getName());         Test.alter1(a);        System.out.println(a.getName());        System.out.println();        String s = &quot;hello&quot;;        System.out.println(s);        alter2(s);        System.out.println(s);    &#125;    static void alter1(A a)&#123;        a.name = &quot;alterA&quot;;    &#125;    static void alter2(String str)&#123;        str = &quot;hi&quot;;    &#125;&#125;\n运行结果：\n","categories":["java"]},{"title":"Java实体类","url":"/2022/03/10/java-shi-ti-lei/","content":"实体类的属性名称不能和数据库的保留字相同，否则会导致数据表创建错误。Mysql保留字有：    call\n","categories":["mysql","Java"]},{"title":"SpringBoot-JPA","url":"/2021/12/04/springboot-jpa/","content":"pom依赖配置jpa本身配置&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;\n引入驱动依赖（mysql数据库操作必配）&lt;dependency&gt;\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;\n\nmysql数据库链接#数据库连接spring.datasource.url=jdbc:mysql://127.0.0.1:3306/admin?characterEncoding=UTF-8spring.datasource.username=用户名spring.datasource.password=用户密码#mysql驱动spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n使用步骤一、创建实体类实体类标注注解：@Entity、@Table。注意导入的包为：javax.persistence.*\n@Entity@Table(name = &quot;user&quot;)public class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column    int id;    @Column    String userName;    @Column    String name;    @Column    String headImg;    //性别    @Column    String gender;    @Column    String phone;    @Column    String email;    String password;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getId() &#123;        return id;    &#125;    public void setUserName(String userName) &#123;        this.userName = userName;    &#125;    public String getUserName() &#123;        return userName;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setHeadImg(String headImg) &#123;        this.headImg = headImg;    &#125;    public String getHeadImg() &#123;        return headImg;    &#125;    public void setGender(String gender) &#123;        this.gender = gender;    &#125;    public String getGender() &#123;        return gender;    &#125;    public void setPhone(String phone) &#123;        this.phone = phone;    &#125;    public String getPhone() &#123;        return phone;    &#125;    public void setEmail(String email) &#123;        this.email = email;    &#125;    public String getEmail() &#123;        return email;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public String getPassword() &#123;        return password;    &#125;&#125;\nJPA默认的字段命名规则是驼峰转换，eg：UserName –&gt; user_name。\nJPA配置修改#设置自动更新表结构spring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect#在控制台显示sql语句spring.jpa.show-sql= true\n\n二、继承JpaRepository接口//User对应要操作的数据表实体类，Integer是int类型的封装类，固定不变public interface UserDAO extends JpaRepository&lt;User, Integer&gt; &#123;&#125;\n\n三、使用接口类进行CRUD操作当UserDAO继承了JpaRepository后，可以在其它类中注入UserDAO，使用UserDAO进行简单的crud操作。在类UserService标注注解@Service的作用是，向容器中添加该类的组件，之后可以在其它地方使用注解@Autowired注入该类对象。\n@Servicepublic class UserService &#123;    @Autowired    UserDAO userDAO;    public void add(User user)&#123;        userDAO.save(user);    &#125; &#125;\nJPA注入：    使用注解@Autowired。    内部使用了@Autowired的类，在外面不能使用new创建该类对象，而是使用@Autowired注入对象，否则会导致JPA注入失败，报空指针异常。    eg：UserController类中使用了new UserService创建对象，导致UserService类中UserDAO注入失败，userDAO为null\n@Controllerpublic class UserController &#123;    @RequestMapping(&quot;/hello&quot;)    @ResponseBody    public void hi()&#123;        new UserService().add(new User());    &#125;&#125;\n\n正确用法是使用@Autowired注入UserService对象，如下所示\n@Controllerpublic class UserController &#123;    @Autowired    UserService userService;    @RequestMapping(&quot;/hello&quot;)    @ResponseBody    public void hi()&#123;        userService.add(new User());    &#125;&#125;","categories":["mysql","SpringBoot"],"tags":["JPA"]},{"title":"SpringBoot-方法参数","url":"/2021/12/02/springboot-fang-fa-can-shu/","content":"方法参数封装","categories":["SpringBoot"]},{"title":"SpringBoot-注解","url":"/2021/11/15/springboot-zhu-jie/","content":"@Configuration注释类，向SpringBoot表示该类为一个配置类。该注解有一个属性proxyBeanMethods，默认为true，表示该类被SpringBoot所代理，可以理解为该被SpringBoot托管。@Configuration配置类本身也是一个组件，组件ID为类名（首字母小写）。\n@Bean用来注释方法，要和 “能将类作为组件添加到容器中” 的注解组合使用，例如@Configuration和@Conpoment。表示向IOC容器中添加一个组件，组件ID默认为方法名，组件实例为方法的返回值。当@Configuration的 proxyBeanMethods=true 时，当使用类对象调用注解了@Bean的方法时，SpringBoot会去容器中寻找该组件，返回该组件的引用，而不是重新构造一个对象实例。多次从获取时，仍然引用的是容器中组件实例，即该方法的返回值保持单实例。当@Configuration的proxyBeanMethods=false时，表示配置类不会由SpringBoot所代理，使用类对象调用注解@Bean方法时，SpringBoot不会去容器中寻找组件，而是直接创建一个实例，每次调用都会创建不同的实例。\n@Configuration(&quot;haha&quot;)public class test &#123;    @Bean    public User user()&#123;        return new User();    &#125;&#125;@SpringBootApplicationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext app = SpringApplication.run(DemoApplication.class, args);        System.out.println(app.containsBean(&quot;haha&quot;));        System.out.println(app.containsBean(&quot;user&quot;));    &#125;&#125;\n输出结果为：\n组件依赖：小结：注解@Bean和@Configuration表示在SpringBoot启动时，像容器中添加一个组件。但是如果proxyBeanMethods=true，表示该类被SpringBoot代理。注意：如果使用普通方式，通过构造方法创建是实例时，和注解@Configuration、@Bean没有任何关系。\n@Import注释类。表示向容器中添加组件。使用方式：@Import(“class”, “.class”)，组件名为全类名\n@Component标注在类上，表示将该类作为一个组件添加到Spring容器中。\n@ConfigurationProperties@ConfigurationProperties注解可以和@Component搭配（同一类中），也可以和@EnableConfigurationProperties搭配（不同类中）。@ConfigurationProperties将类的属性和配置文件中的属性进行绑定。如果该类只有@ConfigurationProperties注解而没有@Component注解，那么配置绑定功能是无法实现的，因为该类没有被作为组件添加到Spring容器中（不能享受Spring容器带来的强大功能），此时可以在其他类中使用@EnableConfigurationProperties注解，将类添加到容器中，开启配置绑定功能。代码示例：\npackage org.springframework.boot.autoconfigure.web;@ConfigurationProperties(&quot;spring.web&quot;)public class WebProperties &#123;\tpublic static class Resources &#123;        //和配置文件application.properties中的 spring.web.resources.static-locations 进行绑定\t\tprivate String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;\t&#125;&#125;\n\n@EnableConfigurationProperties对只有@ConfigurationProperties注解而没有@Component注解的配置类，使用@EnableConfigurationProperties将配置类添加到容器中。代码示例：\npackage org.springframework.boot.autoconfigure.web.servlet;@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,\t\tValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123;\t@Configuration(proxyBeanMethods = false)\t@Import(EnableWebMvcConfiguration.class)\t@EnableConfigurationProperties(&#123; WebMvcProperties.class,\t\t\torg.springframework.boot.autoconfigure.web.ResourceProperties.class, WebProperties.class &#125;)\t@Order(0)\tpublic static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware &#123;\t\t&#125;&#125;package org.springframework.boot.autoconfigure.web.servlet;@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)public class WebMvcProperties &#123;&#125;\n\n参数自动封装表单的字段会被自动封装到参数对象中。表单name属性的值要和对象的属性名一致，否则会封装失败，造成对象的属性值为null的情况。代码示例：\n@GetMapping(&quot;/form_createManager&quot;)    public String createManager(Manager manager)&#123;        if(managerService.isExitsByManagerName(manager.getName()))&#123;            return &quot;redirect:/createManager.html&quot;;        &#125;else &#123;            managerService.add(manager);            return &quot;redirect:/listManager.html&quot;;        &#125;    &#125;\n&lt;form action=&quot;/form_createManager&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;姓名&quot; name=&quot;name&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;手机&quot; name=&quot;phone&quot;&gt;    &lt;input type=&quot;email&quot; placeholder=&quot;邮箱&quot; name=&quot;email&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;","categories":["SpringBoot"],"tags":["注解"]},{"title":"Hello World","url":"/2021/10/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"aplayer","url":"/2021/10/30/aplayer/","content":"使用aplayer播放器\n安装aplayer使用命令fs    npm install aplayer –save\n文章添加音乐在文章头部Front-matter中添加语句，否则不成功    aplayer: true在文章正文中添加以下语句。（具体字段属性请参考官方文档）\n方法2：使用hexo-tag-aplayer插件实现安装插件    npm install –save hexo-tag-aplayer在hexo的配置文件 _config.yml 中添加以下语句。    aplayer:        true在文章正文添加以下语句。（具体字段属性请参考官方文档）使用hexo-tag-aplayer有个小问题，音乐播放列表列表不能折叠。添加”listfolded:true”后音乐页面直接不能显示了。\n\n\t\t\t\n\t\t\t\tconsole.error(\"Error: [hexo-tag-aplayer] Specified asset file not found (caffeine.mp3)\");\n\t\t\t\n\nwocao\n","categories":["blog"],"tags":["aplayer"]},{"title":"my-first-blog","url":"/2021/10/17/my-first-blog/","content":"Hexo + GitHub 搭建个人博客环境准备npm、git\n\n使用命令（均在git bash下执行）安装Hexo博客框架\nnpm install hexo-cli -g\n初始化项目文件夹\nhexo init 文件夹名称（后面不跟文件名称时，需要自己创建文件，并在切换到对应文件路径下执行该命令\n安装npm依赖。执行上条命令时，会提示dependencies 下载失败。按照提示运行命令。\nnpm install有时使用npm下载不成，可以使用cnpm install，多运行几次就好了（亲试）\n本地预览博客是否搭建成功。执行以下两条命令。\nhexo g\t#编译静态文件hexo s\t#本地预览\n访问 http://localhost:4000/ 。出现以下页面表示本地搭建成功。\n\n上线到Github准备工作：获取SSH密钥    查看本地有无SSH密钥    cd ~/.ssh    如果没有则生成密钥。    ssh-keygen -t rsa -C &quot;你的邮箱&quot;\t\t#会提示你设置密钥文件名称，和密码，两者都可以为空，直接回车    再次查看密钥文件，查询结果出现***.ssh文件表示成功，同样会显示密钥路径。Github设置SSH密钥    在setting中选中SSH and GPG keys，点击New SSH key，密钥名称任取，密钥内容使用记事本打开生成的密钥文件，复制过去，就ok了。安装Github部署插件    npm install hexo-deployer-git --saveGithub创建新库 username.github.io。修改项目目录下的配置文件。如下所示。    deploy: \t\ttype: git \t\trepo: git@github.com:up-bear/up-bear.github.io.git\t\t branch: master部署命令    hexo d每次修改博客后，需要使用以下命令重新部署hexo cleanhexo ghexo d访问博客网址username.github.io。\n\n    ","categories":["blog"]},{"title":"html","url":"/2021/10/31/html/","content":"textareatextarea标签：\ncols:字符列数rows:字符行数readonly:值true/false 是否设为只读\n去除首行缩进：将首尾标签放在同一行\n&lt;textarea&gt;hello&lt;/textarea&gt;\n去除下拉斜线：添加属性 resize: none\n&lt;textarea style=&quot;resize: none;&quot;&gt;hello&lt;/textarea&gt;\n去除滚动条：添加属性 overflow: hidden\n&lt;textarea style=&quot;overflow: hidden;&quot;&gt;hello&lt;/textarea&gt;\n去除边框：添加属性border: none\n&lt;textarea style=&quot;border: none;&quot;&gt;hello&lt;/textarea&gt;\n去除点击文本时的边框：添加属性 outline: none\n&lt;textarea style=&quot;outline: none;&quot;&gt;hello&lt;/textarea\n显示高度自适应：\n&lt;textarea  autoHeight=&quot;true&quot; readonly=&quot;readonly&quot; style=&quot;resize: \t\tnone; border: none; overflow: hidden; outline: \tnone;&quot;&gt;qwerrtyuiopasdfghjklzxcnm1234567890qwertyuiopasdfghjklzxcvbnm&lt;/textarea&gt;\n$(function()&#123;        $.fn.autoHeight = function()&#123;                function autoHeight(elem)&#123;                elem.style.height = &#x27;auto&#x27;;                elem.scrollTop = 0; //防抖动                elem.style.height = elem.scrollHeight + &#x27;px&#x27;;            &#125;            this.each(function()&#123;                autoHeight(this);                $(this).on(&#x27;keyup&#x27;, function()&#123;                    autoHeight(this);                &#125;);            &#125;);     &#125;                   $(&#x27;textarea[autoHeight]&#x27;).autoHeight();    &#125;)\ntextarea自适应小问题：实际textarea的宽度比文字行数多了一行\n&lt;!--单个媒体对象 start--&gt;&lt;div class=&quot;media&quot;&gt;&lt;div class=&quot;media-left&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img class=&quot;media-object&quot; src=&quot;../images/72534562.jpg&quot; alt=&quot;头像&quot; width=&quot;64px&quot; height=&quot;64px&quot;&gt;&lt;h5 style=&quot;margin: 0px;text-align: center;&quot;&gt;用户名&lt;/h5&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;media-body&quot;&gt;&lt;h4 class=&quot;media-heading&quot;&gt;Media heading&lt;/h4&gt;&lt;textarea cols=&quot;50&quot; rows=&quot;3&quot; style=&quot;resize: none; border: none; overflow: hidden; outline: none;&quot; readonly=&quot;true&quot;&gt;Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo.&lt;/textarea&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--单个媒体对象 end--&gt;","categories":["html"]},{"title":"nginx初试","url":"/2022/04/06/nginx-chu-shi/","content":"Linux安装nginx，安装路径为 /usr/local/nginx 。启动及其他命令须在 sbin 目录下进行。常用命令\n启动nginx\t\t./nginx\t\t停止nginx\t\t./nginx\t-s stop\t重新加载nginx  ./nginx -s reload\n\n反向代理概念：客户端发送的请求经过中间件，然后派发到不同服务器的过程即为反向代理。正向代理代理的是客户端，特点是用户明确知道实际访问的服务器。反向代理代理的是服务器，特点是用户不知道实际要访问的服务器，服务器对用户来说是隐藏的，用户知道的是中间件。\n反向代理单个节点nginx.con配置\nserver &#123;\tlisten\t&quot;访问端口&quot;;\tserver_name:\t&quot;访问ip&quot;;\tlocation / &#123;\t\troot\thtml;\t\tindex\tindex.html index.html;\t\tproxy_name\t&quot;被代理的服务器ip:port&quot;;\t&#125;&#125;\n反向代理两个节点nginx.conf配置\nserver &#123;\tlisten\t&quot;访问端口&quot;;\tserver\t&quot;访问ip&quot;;\t\tlocation ~ /edu/ &#123;\t\tproxy_pass\thttp://op:port;\t&#125;\t\tlocation ~ /vod/ &#123;\t\tproxy_pass\thttp://ip:port;\t&#125;&#125;\n/edu/ 是正则表达式，nginx会根据客户端的访问路径，将请求派发到与正则表达式匹配的服务器。\n负载均衡概念：将请求派发到不同服务器上，减轻服务器的负担，提高系统的可用性和可靠性。\n默认轮询nginx.conf配置\nupstream myServer&#123;\tserver\tip:port;\tserver\tip:port;&#125;server&#123;\tlisten\tport;\tserver_name\t\tip;        location&#123;    \tproxy_pass\thttp://myServer;    \t    \troot\thtml;    \tindex\tindex.html\tindex.html;    &#125;&#125;\n分配权重nginx.conf配置\nupstream myServer&#123;\tserver\tip:port\t\tweight=10;\tserver\tip:port\t\tweight=5;\t&#125;server&#123;\tlisten\tport;\tserver_name\t\tip;        location&#123;    \tproxy_pass\thttp://myServer;    \t    \troot\thtml;    \tindex\tindex.html\tindex.html;    &#125;&#125;\nweight的值越大，请求被派发到该服务器的几率越大。\nip_hashnginx.conf配置\nupstream myServer&#123;\tip_hash;\tserver\tip:port;\tserver\tip:port;&#125;server&#123;\tlisten\tport;\tserver_name\t\tip;        location&#123;    \tproxy_pass\thttp://myServer;    \t    \troot\thtml;    \tindex\tindex.html\tindex.html;    &#125;&#125;\nnginx根据客户端的ip的hash值进行派发请求，此方法可以解决session问题。\nfairnginx.conf配置\nupstream myServer&#123;\tfair;\tserver\tip:port;\tserver\tip:port;&#125;server&#123;\tlisten\tport;\tserver_name\t\tip;        location&#123;    \tproxy_pass\thttp://myServer;    \t    \troot\thtml;    \tindex\tindex.html\tindex.html;    &#125;&#125;\nnginx根据服务器的响应时间来分配请求，响应时间越短越优先分配。\n动静分离看尚硅谷的nginx视频，感觉这部分讲的不是很好，和一般的反向代理差不多，但还是记录一下。本次测试是把静态资源放在nginx所在的主机下，在/myData/img 和 /myData/html 目录下放置静态资源。nginx.conf配置\nserver&#123;\tlisten\tport;\tserver_name\t\tip;        location&#123;    \tproxy_pass\thttp://myServer;    \t    \troot\thtml;    \tindex\tindex.html\tindex.html;    &#125;        #添加规则    location /html/ &#123;        root    /myData/;    &#125;    location /img/ &#123; \t\troot    /myData/; \t\t#访问/img/会把该目录下的资源列出来\t\tautoindex       on;    &#125;&#125;\n","categories":["nginx"]},{"title":"Java实体类和Mysql表结构","url":"/2021/11/26/mysql/","content":"mysql和实体类布尔类型mysql中没有布尔类型的数据，在实体类中的属性尽量使用布尔变量的封装类型Boolean\n@Entity@Table(name = &quot;a&quot;)public class A &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column    int id;    @Column    Boolean flag;        //set、get方法省略&#125;\n表结构中flag字段的类型为：\n字符串mysql中，字符串为空和为null，两者并不相等。字符串为空对应 “” 。要想查询数据表中字符串为空的记录，要传入参数 “” ,而不是 null\n\n\n索引（主键也是一种索引？在执行sql语句 show index from myTest 时，主键也被列了出来）\n\n\n创建索引创建表时创建索引：\ncreate table myTest(id int NOT NULL,name varchar(255) NOT NULL,age int(3) NOT NULL,weight int(3) NOT NULL,PRIMARY KEY (id),key in_myTest_weight(weight));\n创建表后添加索引：方式一\ncreate index in_sqltest_age on sqltest(age);\t//in_sqltest_age 索引名， sqltest 表名， age 字段名\n方式二\nalter table sqltest add index in_sqltest_name(name);\t//sqltest 表名， in_sqltest_name 索引名， name 字段名\n删除索引alter table sqltest drop index in_sqltest_age;\t//sqltest 表名， in_sqltest_age 索引名\n\n普通索引：index； 唯一索引：unique index。唯一索引即被索引的列中数据的值是唯一的，不允许重复。当列中的数据有重复时，创建唯一索引会失败；同样当创建好唯一索引后，插入重复数据的记录也会插入失败。\n唯一约束 UNIQUE创建表时添加 UNIQUE 约束\nCREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),UNIQUE (Id_P));\n创建表时添加多个 UNIQUE 约束\nCREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName));\n创建表后添加 UNIQUE 约束\nalter table sqltest add unique (name);\n创建表后添加多个 UNIQUE 约束\nalter table sqltest add unique (name, age);","categories":["mysql"],"tags":["实体类"]},{"title":"thymeleaf","url":"/2021/10/30/thymeleaf/","content":"动态包含页面&lt;script&gt;    $(&quot;#head&quot;).load(&quot;public/head.html&quot;);&lt;/script&gt;\nIDEA创建SpringBoot项目重定向重定向的默认访问路径是Resource/templates,想要访问Resource/static下的静态资源返回字符串要明确添加redirect，例如 return “redirect:html/hello.html”\nbootstrap&amp;thymeleaf二者不兼容：bootstrap静态页面经由thymeleaf动态打开后静态页面样式消失\n动态创建列表代码示例：\n&lt;table&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;管理者名称&lt;/th&gt;        &lt;th&gt;手机&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr th:each=&quot;manager : $&#123;manager_list&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;manager.getName()&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;manager.phone&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;\n\n向request中放入一个名manager_list的List类型对象。 向Request、Model、ModelAndView中放入数据，都是一样的效果，因为三者最终都将数据放入了同一个地方（雷神SpringBoot2中有讲）\n使用Thymeleaf取数据，显示在列表中。 ${manager_list}:取出request中key为manager_list的对象 ${manager.getName()}和${manager.phone}两种方法都可以获取对象manager的属性\n\nThymeleaf常见错误\n路径拼写错误。 使用了Thymeleaf模板，默认使用了@Controller类的字符串返回类型会被当作转发请求，且返回的字符串不需要带后缀”.html’，因为Thymeleaf会默认去寻找html文件。如果想使用重定向，需要使用：return “redirect:请求路径”。\nthymeleaf获取request、session中的参数错误。 使用thymeleaf表达式 ${…} 获取数据时，一定要确保在到达该页面前一定已经向对应的request、session中放入了要取的数据，否则也会造成错误。 使用 ${对象.属性} 或 ${对象.方法} 获取数据时，一定确保属性名和方法名和Java类中的保持一致，即使少了一个字母也会报错\n\nbackground-image: url() 拼接设置背景\n&lt;div th:style=&quot;&#x27;background:url(&#x27; + @&#123;/&lt;path-to-image&gt;&#125; + &#x27;);&#x27;&quot;&gt;&lt;/div&gt;\n根据属性值改变背景\n&lt;div class=&quot;media-object resource-card-image&quot;  th:style=&quot;&#x27;background:url(&#x27; + @&#123;($&#123;collect.webLogo&#125;==&#x27;&#x27; ? &#x27;img/favicon.png&#x27; : $&#123;collect.webLogo&#125;)&#125; + &#x27;)&#x27;&quot; &gt;&lt;/div&gt;\n\n行内写法（表达式内联）语法：\n&lt;p&gt;Hello, [[$&#123;session.user.name&#125;]]!&lt;/p&gt;\n禁用内联：\n&lt;p th:inline=&quot;none&quot;&gt;A double array looks like this: [[1, 2, 3], [4, 5]]!&lt;/p&gt;","categories":["SpringBoot","html"],"tags":["bootstrap","thymeleaf"]},{"title":"注解与反射","url":"/2021/11/16/zhu-jie-yu-fan-she/","content":"注解Annotation作用：注释和解释（狂神说的，很喜欢，简洁）。被人用来注释代码，并交给JVM去解释执行。\n定义：\n@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation&#123;    public String value();&#125;\n以上就简单自定义了一个注解。在定义注解的时候可以使用其他注解。\n元注解：用来注解注解的注解。四个元注解：\n@Target 确定注解可以使用的地方，如类、接口、方法等@Retention 可以理解为注解的&quot;生命周期&quot;@Documented 此注解会被javadoc工具提取成文档@Inherited 允许子类继承父类中的注解\n\n反射Reflection个人理解：通过Class类去操纵对象的过程就称为反射。代码示例：\n\n","categories":["java"],"tags":["注解","反射"]},{"title":"开发问题汇总","url":"/2022/03/17/kai-fa-wen-ti-hui-zong/","content":"问题1——请路径参数获取问题使用ajax发送请求，在请求路径中拼接了一个参数 calledName ，在后台 controller 方法中使用 request.getAttribute(“calledName”) 获取 calledName ，结果为 null 。换一种方法使用 @RequestParam 注解却能获取到 calledName 的值。原因尚未知，在以后的开发中尽量使用 @RequestParam 注解获取参数值。请求路径中拼接参数的方式，GET 和 POST 都可以使用。\n问题2——ajax回调函数的返回数据data使用 $.ajax() 方式发送 ajax 请求，其中 datatype 的值设为 json，发现最终回调函数不能正常使用，将 datatype 这一参数设置不写，（后台 controller 方法注解是有 @RequestBody 的），回调函数能够正常使用。\n"},{"title":"重载与重写","url":"/2021/11/16/chong-zai-yu-chong-xie/","content":"重载描述：一个类中，同一个方法名，有用多个参数类型或数量不同的方法实现，则称之为方法重载。代码示例：\npublic class A&#123;\tpublic void methodA()&#123;&#125;;\tpublic void methodA(int a)&#123;&#125;;    public void methodA(String str)&#123;&#125;;&#125;\n\n继承定义：\npublic class B extends A&#123;\t&#125;\n类B继承了类A，B拥有A的所有方法（构造方法除外）和属性。类B可以对父类A的方法进行重写，还可以声明父类A没有的属性。构造方法：当父类有多个构造方法时，子类必须声明一个参数列表（可以是无参类型）和父类相同的构造方法，并在方法体的第一行调用父类的其中一个构造方法。注意，当父类只有默认无参构造方法时，子类的默认无参构造方法中默认调用了父类的无参构造方法。当以一个类声明了构造方法，默认的无参构造方法便不存在了。代码示例：\n示例一：public class Father &#123;    public Father()&#123;        System.out.println(&quot;Father&quot;);    &#125;    public Father(String name, String age)&#123;        System.out.println(name + age);    &#125;&#125;class Son extends Father&#123;    public Son(String name) &#123;        super();    &#125;&#125;示例二：public class Father &#123;    public Father()&#123;        System.out.println(&quot;Father&quot;);    &#125;    public Father(String name, String age)&#123;        System.out.println(name + age);    &#125;&#125;class Son extends Father&#123;\t//有默认的无参构造器，而且会默认调用父类的无参构造器\t\tpublic static void main(String[] args)&#123;\t\tnew Son();\t&#125;&#125;输出：Father示例三：public class Father &#123;    public Father(String name)&#123;        System.out.println(name);    &#125;    public Father(String name, String age)&#123;        System.out.println(name + age);    &#125;&#125;class Son extends Father&#123;\tpublic Son(String name)&#123;\t\tsuper(name + &quot;age&quot;);\t&#125;&#125;\n\n重写描述：子类继承父类，并对继承的父类方法进行重新实现的过程，称之为方法重写。\n代码示例\npublic class Father&#123;\tpublic String method1()&#123;\t\treturn &quot;father&quot;;\t&#125;&#125;public class Son extends Father&#123;\tpublic String method1()&#123;\t\treturn &quot;son&quot;\t&#125;&#125;\n\n向上转型与向下转型向上转型描述：把子类的对象实例赋值给父类的引用。代码示例：\npublic class Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;father&quot;);\t&#125;&#125;public class B extends Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;son&quot;);\t&#125;\t\tpublic static void main(String[] args)&#123;\t\tFather f = new Son();\t//向上转型,将子类实例赋值给父类引用。可以理解为把子类对象向上转换成父类对象。 \t\tf.method1();\t//输出结果为&quot;son&quot;,而不是&quot;father&quot;\t&#125;&#125;\n通过向上转型的获得的对象引用，在调用方法时，只能调用父类中已有的方法，但执行的方法体是子类的方法。\n易混淆情况：\npublic class Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;father&quot;);\t&#125;\t\tpublic void method2()&#123;\t\tSystem.out.println(&quot;father.method2&quot;);\t&#125;&#125;public class B extends Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;son&quot;);\t&#125;\t\tpublic static void main(String[] args)&#123;\t\tFather f = new Son();\t//向上转型,将子类实例赋值给父类引用。可以理解为把子类对象向上转换成父类对象。 \t\tf.method2();\t//输出结果为&quot;father.method2&quot;,method2()方法没有被子类B重写，是从父类A中继承过来的，也是类B的方法不要理解为method2不是B的方法。\t&#125;&#125;\n\n代码示例：\npublic class Father &#123;    public String method1()&#123;        return &quot;father&quot;;    &#125;&#125;class Son extends Father&#123;    public String method1()&#123;        return &quot;son&quot;;    &#125;    public String method2()&#123;        return &quot;Son.method2&quot;;    &#125;    public static void main(String[] args)&#123;        Father f = new Son();        //System.out.println(f.method2());\t该行会提示报错，因为f此时是Father类型，没有method2()方法        System.out.println(((Son)f).method2());\t//此时再使用向下转型，便不会报错。输出结果为&quot;Son.method2&quot;    &#125;&#125;\n\n向上转型经典例题class A &#123;    public String show(D obj) &#123;        return (&quot;A and D&quot;);    &#125;    public String show(A obj) &#123;        return (&quot;A and A&quot;);    &#125;&#125;class B extends A&#123;    public String show(B obj)&#123;        return (&quot;B and B&quot;);    &#125;    public String show(A obj)&#123;        return (&quot;B and A&quot;);    &#125;&#125;class C extends B&#123;&#125;class D extends B&#123;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        A a1 = new A();        A a2 = new B();        B b = new B();        C c = new C();        D d = new D();        System.out.println(&quot;1--&quot; + a1.show(b));        System.out.println(&quot;2--&quot; + a1.show(c));        System.out.println(&quot;3--&quot; + a1.show(d));        System.out.println(&quot;4--&quot; + a2.show(b));        System.out.println(&quot;5--&quot; + a2.show(c));        System.out.println(&quot;6--&quot; + a2.show(d));        System.out.println(&quot;7--&quot; + b.show(b));        System.out.println(&quot;8--&quot; + b.show(c));        System.out.println(&quot;9--&quot; + b.show(d));    &#125;&#125;//结果：//1--A and A//2--A and A//3--A and D//4--B and A//5--B and A//6--A and D//7--B and B//8--B and B//9--A and D//能看懂这个结果么？先自分析一下。\n这个例子是非常复杂的啦，要想完全理解后面几个输出结果还要知道一条重要知识：\n继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)(其实按照我前面的理解，感觉这一条原则不要也行，因为子类没有重写的方法是默认继承自父类的，验证了一下例题也没问题)\n对于输出4，a2.show(b))的输出结果是”B and A”。对象a2是A类型，但是指向B类型实例，为向上转型。a2可执行的方法名为类A中的方法，public String show(D obj)和public String show(A obj)；\n继承链第一步：this.show(O)显然不行，因为对象b是B类型，可执行方法中没有符合要求的。继承链第二步：super.show(O)，显然没有符合要求的。继承链第三步：this.show((super)O)，即shou((A) b)，执行类B中的方法show(A obj)，输出&quot;B and A&quot;\n对于输出5，分析同输出4，略。对于输出6，a2.show(d))的输出结果为”A and D”，也很好理解。\n继承链第一步：this.show(O)显然可以，因为类B继承了类A的public String show(D obj)方法，\n\n\n\n参考博文\n","categories":["java"]},{"title":"SpringBoot源码笔记","url":"/2022/01/19/springboot-yuan-ma-bi-ji/","content":"静态资源默认路径项目资源文件夹resources下：/META-INF/resources/、/resources/、/static/、/public/ 共四个路径。即使是使用了thymeleaf模板的情况下，放在以上路径下的静态资源仍然可以被访问，而且在这些路径下的html页面中使用thymeleaf语法同样有效。（thymeleaf似乎值对拦截再templates路径下的资源访问进行拦截设置）源码探究：\npackage org.springframework.boot.autoconfigure.web;@ConfigurationProperties(&quot;spring.web&quot;)public class WebProperties &#123;\tpublic static class Resources &#123;\t\tprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;\t&#125;&#125;\n自定义资源路径注解@ConfigurationProperties(“spring.web”)，WebProperties类下的属性和配置文件进行了绑定，在配置文件application.properties中即可自定义静态资源访问路径。\n##由于CLASSPATH_RESOURCE_LOCATIONS被final修饰，所以不能修改##类属性和配置文件的对应规则：spring.web为注解设置前缀，resource对应内部类Resources的类名，static-locations对应类属性staticLocationsspring.web.resources.static-locations = 自定义资源路径\n源码探究：\npackage org.springframework.boot.autoconfigure.web;@ConfigurationProperties(&quot;spring.web&quot;)public class WebProperties &#123;\tpublic static class Resources &#123;\t\tprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;\t\tprivate String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;\t&#125;&#125;\n\n资源访问前缀默认访问前缀：/源码探究：\n@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)public class WebMvcProperties &#123;\tpublic static class Servlet &#123;\t\t/**\t\t * Path of the dispatcher servlet. Setting a custom value for this property is not\t\t * compatible with the PathPatternParser matching strategy.\t\t */\t\tprivate String path = &quot;/&quot;;\t&#125;&#125;\n自定义访问前缀：\nspring.web.servlet.path = 自定义前缀（注意要“/”结尾）\n\n\nweb请求处理过程所有web请求都会进入到 org.springframework.web.servlet 包下的 DispatcherServlet 类的 doDispatch(HttpServletRequest request, HttpServletResponse response) 方法中\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\tHttpServletRequest processedRequest = request;\tHandlerExecutionChain mappedHandler = null;\t    boolean multipartRequestParsed = false;\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\t\ttry &#123;\t\t\tModelAndView mv = null;\t\tException dispatchException = null;\t\ttry &#123;\t\t\tprocessedRequest = checkMultipart(request);\t\t\tmultipartRequestParsed = (processedRequest != request);\t\t\t// Determine handler for the current request.\t\t\t//***获取映射处理器，进入该方法可以看到所有的请求路径映射***\t\t\tmappedHandler = getHandler(processedRequest);\t\t\tif (mappedHandler == null) &#123;\t\t\t\tnoHandlerFound(processedRequest, response);\t\t\t\treturn;\t\t\t&#125;\t\t\t// Determine handler adapter for the current request.\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\t\t\t// Process last-modified header, if supported by the handler.\t\t\tString method = request.getMethod();\t\t\tboolean isGet = HttpMethod.GET.matches(method);\t\t\tif (isGet || HttpMethod.HEAD.matches(method)) &#123;\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;\t\t\t\treturn;\t\t\t&#125;\t\t\t//***（1）***             //***真正要开始处理请求映射的方法***\t\t\t// Actually invoke the handler.\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\t\t\tif (asyncManager.isConcurrentHandlingStarted()) &#123;\t\t\t\treturn;\t\t\t&#125;\t\t\tapplyDefaultViewName(processedRequest, mv);\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\t\t&#125;\t\tcatch (Exception ex) &#123;\t\t\tdispatchException = ex;\t\t&#125;\t\tcatch (Throwable err) &#123;\t\t\t// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\t\t\tdispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);\t\t&#125;\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\t&#125;\tcatch (Exception ex) &#123;\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\t&#125;\tcatch (Throwable err) &#123;\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\t\t\tnew NestedServletException(&quot;Handler processing failed&quot;, err));\t&#125;\tfinally &#123;\t\tif (asyncManager.isConcurrentHandlingStarted()) &#123;\t\t\t// Instead of postHandle and afterCompletion\t\t\tif (mappedHandler != null) &#123;\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\t\t\t&#125;\t\t&#125;\t\telse &#123;\t\t\t// Clean up any resources used by a multipart request.\t\t\tif (multipartRequestParsed) &#123;\t\t\t\tcleanupMultipart(processedRequest);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n执行 mappedHandler = getHandler(processedRequest) ，进入到 getHandler() 方法\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;\tif (this.handlerMappings != null) &#123;\t\t//***mapping中包含了所有的请求路径，和请求路径映射的方法。\t\tfor (HandlerMapping mapping : this.handlerMappings) &#123;\t\t\tHandlerExecutionChain handler = mapping.getHandler(request);\t\t\tif (handler != null) &#123;\t\t\t\treturn handler;\t\t\t&#125;\t\t&#125;\t&#125;\treturn null;&#125;\nthis.handlerMappings:    mapping:    包含了所有请求路径和请求路径的映射方法        \n执行 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()) 时，会进入到 AbstractHandlerMethodAdapter 类的 handle(HttpServletRequest request, HttpServletResponse response, Object handler) 方法中（共有四个HandleMethodAdapter， 分别是…）。\npublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\t\t\tthrows Exception &#123;\t\treturn handleInternal(request, response, (HandlerMethod) handler);\t&#125;\n接着进入到 RequestMappingHandlerAdapter 类的 handleInternal(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod) 方法\nprotected ModelAndView handleInternal(HttpServletRequest request,\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;\tModelAndView mav;\tcheckRequest(request);\t// Execute invokeHandlerMethod in synchronized block if required.\tif (this.synchronizeOnSession) &#123;\t\tHttpSession session = request.getSession(false);\t\tif (session != null) &#123;\t\t\tObject mutex = WebUtils.getSessionMutex(session);\t\t\tsynchronized (mutex) &#123;\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\t\t\t&#125;\t\t&#125;\t\telse &#123;\t\t\t// No HttpSession available -&gt; no mutex necessary\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\t\t&#125;\t&#125;\telse &#123;         //***(2)***         //***开始进入请求方法执行流程***\t\t// No synchronization on session demanded at all...\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\t&#125;\t\tif (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;\t\tif (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;\t\t\tapplyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\t\t&#125;\t\telse &#123;\t\t\tprepareResponse(response);\t\t&#125;\t&#125;\treturn mav;&#125;\n\n执行 mav = invokeHandlerMethod(request, response, handlerMethod) 进入到同类中的 invokeHandlerMethod(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod) 方法。\nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;\tServletWebRequest webRequest = new ServletWebRequest(request, response);\ttry &#123;\t\tWebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\t\tModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\t\tServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\t\tif (this.argumentResolvers != null) &#123;\t\t\t\t\t\t  //***设置请求方法的参数解析器***invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\t\t&#125;\t\tif (this.returnValueHandlers != null) &#123;//***设置请求方法的返回值处理器***invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\t\t&#125;\t\tinvocableMethod.setDataBinderFactory(binderFactory);\t\tinvocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\t\tmavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\t\tmodelFactory.initModel(webRequest, mavContainer, invocableMethod);\t\tmavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\t\tAsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\t\tasyncWebRequest.setTimeout(this.asyncRequestTimeout);\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\t\tasyncManager.setTaskExecutor(this.taskExecutor);\t\tasyncManager.setAsyncWebRequest(asyncWebRequest);\t\tasyncManager.registerCallableInterceptors(this.callableInterceptors);\t\tasyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\t\tif (asyncManager.hasConcurrentResult()) &#123;\t\t\tObject result = asyncManager.getConcurrentResult();\t\t\tmavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];\t\t\tasyncManager.clearConcurrentResult();\t\t\tLogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;\t\t\t\tString formatted = LogFormatUtils.formatValue(result, !traceOn);\t\t\t\treturn &quot;Resume with async result [&quot; + formatted + &quot;]&quot;;\t\t\t&#125;);\t\t\tinvocableMethod = invocableMethod.wrapConcurrentResult(result);\t\t&#125;        //***(3)***        //***开始处理请求方法的参数、试图等\t\tinvocableMethod.invokeAndHandle(webRequest, mavContainer);\t\tif (asyncManager.isConcurrentHandlingStarted()) &#123;\t\t\treturn null;\t\t&#125;\t\treturn getModelAndView(mavContainer, modelFactory, webRequest);\t&#125;\tfinally &#123;\t\twebRequest.requestCompleted();&#125;\n请求方法参数解析器 ：请求方法返回值处理器：\n执行 invocableMethod.invokeAndHandle(webRequest, mavContainer)，进入到 ServletInvocableHandlerMethod 类下的 invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,Object… providedArgs) 方法。\npublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\t\tObject... providedArgs) throws Exception &#123;    //***(4)***    //***对请求方法选择支持的参数类型解析器（可能不准确）***\tObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\tsetResponseStatus(webRequest);\tif (returnValue == null) &#123;\t\tif (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123;\t\t\tdisableContentCachingIfNecessary(webRequest);\t\t\tmavContainer.setRequestHandled(true);\t\t\treturn;\t\t&#125;\t&#125;\telse if (StringUtils.hasText(getResponseStatusReason())) &#123;\t\tmavContainer.setRequestHandled(true);\t\treturn;\t&#125;\tmavContainer.setRequestHandled(false);\tAssert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;);\ttry &#123;\t\tthis.returnValueHandlers.handleReturnValue(\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\t&#125;\tcatch (Exception ex) &#123;\t\tif (logger.isTraceEnabled()) &#123;\t\t\tlogger.trace(formatErrorForReturnValue(returnValue), ex);\t\t&#125;\t\tthrow ex;\t&#125;&#125;\n\n执行 Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs) ，进入 InvocableHandlerMethod 类下的 invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object… providedArgs) 方法。\npublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\t\tObject... providedArgs) throws Exception &#123;\t//***(5)***\tObject[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\tif (logger.isTraceEnabled()) &#123;\t\tlogger.trace(&quot;Arguments: &quot; + Arrays.toString(args));\t&#125;\treturn doInvoke(args);&#125;\n\n执行 Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs) ，进入到同类下的 getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object… providedArgs) 方法。\nprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\t\tObject... providedArgs) throws Exception &#123;\tMethodParameter[] parameters = getMethodParameters();\tif (ObjectUtils.isEmpty(parameters)) &#123;\t\treturn EMPTY_ARGS;\t&#125;\t\t//***(6)***\t//***开始遍历请求方法的参数列表,按照参数列表的数量创建一个对象数组args，args中的的每个元素后来都会转化为对应的参数列表中的对象类型***\tObject[] args = new Object[parameters.length];\tfor (int i = 0; i &lt; parameters.length; i++) &#123;\t\tMethodParameter parameter = parameters[i];\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\t\targs[i] = findProvidedArgument(parameter, providedArgs);\t\tif (args[i] != null) &#123;\t\t\tcontinue;\t\t&#125;\t\t//***(7)***\t\t//判断resolvers中是否有支持当前参数的resolver\t\tif (!this.resolvers.supportsParameter(parameter)) &#123;\t\t\tthrow new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));\t\t&#125;\t\ttry &#123;\t\t\t//***(8)***\t\t\t//***获取参数类型的对象数组***\t\t\targs[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\t\t&#125;\t\tcatch (Exception ex) &#123;\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\tString exMsg = ex.getMessage();\t\t\t\tif (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\t\t\t\t&#125;\t\t\t&#125;\t\t\tthrow ex;\t\t&#125;\t&#125;\treturn args;&#125;\n\n执行 args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory) \npublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;\t//***(9)***\t//***获取参数解析器***\tHandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);\tif (resolver == null) &#123;\t\tthrow new IllegalArgumentException(&quot;Unsupported parameter type [&quot; +\t\t\t\tparameter.getParameterType().getName() + &quot;]. supportsParameter should be called first.&quot;);\t&#125;\t\t//***这一部像是递归，还没搞懂该行的作用***\treturn resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);&#125;\n\n执行 HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter) \nprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123;\tHandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);\tif (result == null) &#123;\t\t//***(10)***\t\t//***遍历所有的参数类型解析器，找到支持该参数的解析器***\t\tfor (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123;\t\t\tif (resolver.supportsParameter(parameter)) &#123;\t\t\t\tresult = resolver;\t\t\t\tthis.argumentResolverCache.put(parameter, result);\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;\treturn result;&#125;\n\n\n内容协商机制内容协商：协商浏览器能接受的数据类型和服务端能生产的数据类型（数据类型值的是数据的格式，例如XML和JSON等）在SpringBoot中，内容协商流程发生在返回值处理器中。请求的响应过程中，会得到支持请求路径映射的方法返回值的返回值处理器HandlerMethodReturnValueHandler ，接着进入到 HandlerMethodReturnValueHandler 具体实现类中，执行 handleReturnValue() 方法。以 RequestResponseBodyMethodProcessor 为例。\npublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;\t\tmavContainer.setRequestHandled(true);\t\tServletServerHttpRequest inputMessage = createInputMessage(webRequest);\t\tServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\t\t// Try even with null return value. ResponseBodyAdvice could get involved.\t\twriteWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\t&#125;\n进入 writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage) \nprotected &lt;T&gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;\t\tObject body;\t\tClass&lt;?&gt; valueType;\t\tType targetType;\t\tif (value instanceof CharSequence) &#123;\t\t\tbody = value.toString();\t\t\tvalueType = String.class;\t\t\ttargetType = String.class;\t\t&#125;\t\telse &#123;\t\t\tbody = value;\t\t\tvalueType = getReturnValueType(body, returnType);\t\t\ttargetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\t\t&#125;\t\tif (isResourceType(value, returnType)) &#123;\t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, &quot;bytes&quot;);\t\t\tif (value != null &amp;&amp; inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null &amp;&amp;\t\t\t\t\toutputMessage.getServletResponse().getStatus() == 200) &#123;\t\t\t\tResource resource = (Resource) value;\t\t\t\ttry &#123;\t\t\t\t\tList&lt;HttpRange&gt; httpRanges = inputMessage.getHeaders().getRange();\t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\t\t\t\t\tbody = HttpRange.toResourceRegions(httpRanges, resource);\t\t\t\t\tvalueType = body.getClass();\t\t\t\t\ttargetType = RESOURCE_REGION_LIST_TYPE;\t\t\t\t&#125;\t\t\t\tcatch (IllegalArgumentException ex) &#123;\t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, &quot;bytes */&quot; + resource.contentLength());\t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tMediaType selectedMediaType = null;\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\t\tboolean isContentTypePreset = contentType != null &amp;&amp; contentType.isConcrete();\t\tif (isContentTypePreset) &#123;\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\tlogger.debug(&quot;Found &#x27;Content-Type:&quot; + contentType + &quot;&#x27; in response&quot;);\t\t\t&#125;\t\t\tselectedMediaType = contentType;\t\t&#125;\t\telse &#123;\t\t\tHttpServletRequest request = inputMessage.getServletRequest();\t\t\tList&lt;MediaType&gt; acceptableTypes;\t\t\ttry &#123;\t\t\t\t//***得到浏览器可接受的媒体类型***\t\t\t\t//***进入getAcceptableMediaTypes方法，可获取使用哪种内容协商策略ContentNegotiationStrategy***\t\t\t\tacceptableTypes = getAcceptableMediaTypes(request);\t\t\t&#125;\t\t\tcatch (HttpMediaTypeNotAcceptableException ex) &#123;\t\t\t\tint series = outputMessage.getServletResponse().getStatus() / 100;\t\t\t\tif (body == null || series == 4 || series == 5) &#123;\t\t\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\t\t\tlogger.debug(&quot;Ignoring error response content (if any). &quot; + ex);\t\t\t\t\t&#125;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t\tthrow ex;\t\t\t&#125;\t\t\t\t\t\t//***得到服务端可生产的媒体类型***\t\t\tList&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\t\t\tif (body != null &amp;&amp; producibleTypes.isEmpty()) &#123;\t\t\t\tthrow new HttpMessageNotWritableException(\t\t\t\t\t\t&quot;No converter found for return value of type: &quot; + valueType);\t\t\t&#125;\t\t\t\t\t\t//***遍历两种媒体类型，得到双方可以匹配的媒体类型***\t\t\tList&lt;MediaType&gt; mediaTypesToUse = new ArrayList&lt;&gt;();\t\t\tfor (MediaType requestedType : acceptableTypes) &#123;\t\t\t\tfor (MediaType producibleType : producibleTypes) &#123;\t\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) &#123;\t\t\t\t\t\tmediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (mediaTypesToUse.isEmpty()) &#123;\t\t\t\tif (body != null) &#123;\t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleTypes);\t\t\t\t&#125;\t\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\t\tlogger.debug(&quot;No match for &quot; + acceptableTypes + &quot;, supported: &quot; + producibleTypes);\t\t\t\t&#125;\t\t\t\treturn;\t\t\t&#125;\t\t\t\t\t\t//***按照权重等规则进行排序***\t\t\tMediaType.sortBySpecificityAndQuality(mediaTypesToUse);\t\t\t//***确定最佳匹配的媒体类型***\t\t\tfor (MediaType mediaType : mediaTypesToUse) &#123;\t\t\t\tif (mediaType.isConcrete()) &#123;\t\t\t\t\tselectedMediaType = mediaType;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\telse if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) &#123;\t\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\tlogger.debug(&quot;Using &#x27;&quot; + selectedMediaType + &quot;&#x27;, given &quot; +\t\t\t\t\t\tacceptableTypes + &quot; and supported &quot; + producibleTypes);\t\t\t&#125;\t\t&#125;\t\tif (selectedMediaType != null) &#123;\t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\t\t\t//***根据最终匹配的媒体类型，遍历寻找支持的消息转换器Converter\t\t\tfor (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123;\t\t\t\tGenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?\t\t\t\t\t\t(GenericHttpMessageConverter&lt;?&gt;) converter : null);\t\t\t\tif (genericConverter != null ?\t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :\t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) &#123;\t\t\t\t\tbody = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\t\t\t\t\t\t\t(Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),\t\t\t\t\t\t\tinputMessage, outputMessage);\t\t\t\t\tif (body != null) &#123;\t\t\t\t\t\tObject theBody = body;\t\t\t\t\t\tLogFormatUtils.traceDebug(logger, traceOn -&gt;\t\t\t\t\t\t\t\t&quot;Writing [&quot; + LogFormatUtils.formatValue(theBody, !traceOn) + &quot;]&quot;);\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\t\t\t\t\t\tif (genericConverter != null) &#123;\t\t\t\t\t\t//***执行消息转换器的 write 方法***\t\t\t\t\t\t\tgenericConverter.write(body, targetType, selectedMediaType, outputMessage);\t\t\t\t\t\t&#125;\t\t\t\t\t\telse &#123;\t\t\t\t\t\t//***执行消息转换器的 write 方法***\t\t\t\t\t\t\t((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t\telse &#123;\t\t\t\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\t\t\t\tlogger.debug(&quot;Nothing to write: null body&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tif (body != null) &#123;\t\t\tSet&lt;MediaType&gt; producibleMediaTypes =\t\t\t\t\t(Set&lt;MediaType&gt;) inputMessage.getServletRequest()\t\t\t\t\t\t\t.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\t\t\tif (isContentTypePreset || !CollectionUtils.isEmpty(producibleMediaTypes)) &#123;\t\t\t\tthrow new HttpMessageNotWritableException(\t\t\t\t\t\t&quot;No converter for [&quot; + valueType + &quot;] with preset Content-Type &#x27;&quot; + contentType + &quot;&#x27;&quot;);\t\t\t&#125;\t\t\tthrow new HttpMediaTypeNotAcceptableException(getSupportedMediaTypes(body.getClass()));\t\t&#125;\t&#125;\nacceptableTypes = getAcceptableMediaTypes(request) ，确定内容协商策略，进而根据策略获取浏览器可接受的媒体类型\nprivate List&lt;MediaType&gt; getAcceptableMediaTypes(HttpServletRequest request)\t\t\tthrows HttpMediaTypeNotAcceptableException &#123;\t\treturn this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));\t&#125;\npublic List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException &#123;\t\tfor (ContentNegotiationStrategy strategy : this.strategies) &#123;\t\t\tList&lt;MediaType&gt; mediaTypes = strategy.resolveMediaTypes(request);\t\t\tif (mediaTypes.equals(MEDIA_TYPE_ALL_LIST)) &#123;\t\t\t\tcontinue;\t\t\t&#125;\t\t\treturn mediaTypes;\t\t&#125;\t\treturn MEDIA_TYPE_ALL_LIST;\t&#125;\n此时只有一种默认的协商策略，基于request请求头的协商策略：HeaderContentNegotiationStrategy。也可以添加其他的内容协商策略，如在配置文件中开启基于请求参数的协商策略，也可以自定义协商策略。\n\n\n消息转换器Converter：\n开启支持XML格式数据：导入依赖\n&lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;            &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt;\n\n开启基于请求参数的内容协商策略，配置文件中配置相应属性值。此时发送的请求中要附带一个 format 的字段，例如 http://localhost:8080/test/person?format=json 和http://localhost:8080/test/person?format=xml\nspring.contentnegotiation.favor-parameter=true\n\n自定义内容协商策略\n"}]