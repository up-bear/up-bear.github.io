[{"title":"Java基础","url":"/2021/11/17/java-ji-chu/","content":"JDK版本：jdk11\n静态方法不能通过对象调用，只能通过类名调用。\n静态方法可被子类继承。\n类的int属性如果没有赋初值，则在创建类对象时，会被赋值为0。    JPA可能就是根据对象的id是否为0来判断表中是否存在该对象的记录，从而决定save方法是插入还是修改操作。类的String类型的属性不会再创建对象时被赋默认值，为null。    类的对象类型属性，创建时不会赋予默认值，为null。\n字符串关于字符串，在JVM的底层好像有一个字符串常量池。\npublic class Test &#123;    A a;    static class A&#123;        int id;        String name;        public void setName(String name) &#123;            this.name = name;        &#125;        public String getName() &#123;            return name;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public int getId() &#123;            return id;        &#125;    &#125;    public static void main(String[] args) &#123;         A a = new A();         a.setName(&quot;name&quot;);        System.out.println(a.getName());         Test.alter1(a);        System.out.println(a.getName());        System.out.println();        String s = &quot;hello&quot;;        System.out.println(s);        alter2(s);        System.out.println(s);    &#125;    static void alter1(A a)&#123;        a.name = &quot;alterA&quot;;    &#125;    static void alter2(String str)&#123;        str = &quot;hi&quot;;    &#125;&#125;\n运行结果：\n","categories":["java"]},{"title":"SpringBoot-JPA","url":"/2021/12/04/springboot-jpa/","content":"pom依赖配置jpa本身配置&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;\n引入驱动依赖（mysql数据库操作必配）&lt;dependency&gt;\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;\n\nmysql数据库链接#数据库连接spring.datasource.url=jdbc:mysql://127.0.0.1:3306/admin?characterEncoding=UTF-8spring.datasource.username=用户名spring.datasource.password=用户密码#mysql驱动spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n使用步骤一、创建实体类实体类标注注解：@Entity、@Table。注意导入的包为：javax.persistence.*\n@Entity@Table(name = &quot;user&quot;)public class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column    int id;    @Column    String userName;    @Column    String name;    @Column    String headImg;    //性别    @Column    String gender;    @Column    String phone;    @Column    String email;    String password;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getId() &#123;        return id;    &#125;    public void setUserName(String userName) &#123;        this.userName = userName;    &#125;    public String getUserName() &#123;        return userName;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setHeadImg(String headImg) &#123;        this.headImg = headImg;    &#125;    public String getHeadImg() &#123;        return headImg;    &#125;    public void setGender(String gender) &#123;        this.gender = gender;    &#125;    public String getGender() &#123;        return gender;    &#125;    public void setPhone(String phone) &#123;        this.phone = phone;    &#125;    public String getPhone() &#123;        return phone;    &#125;    public void setEmail(String email) &#123;        this.email = email;    &#125;    public String getEmail() &#123;        return email;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public String getPassword() &#123;        return password;    &#125;&#125;\nJPA默认的字段命名规则是驼峰转换，eg：UserName –&gt; user_name。\nJPA配置修改#设置自动更新表结构spring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect#在控制台显示sql语句spring.jpa.show-sql= true\n\n二、继承JpaRepository接口//User对应要操作的数据表实体类，Integer是int类型的封装类，固定不变public interface UserDAO extends JpaRepository&lt;User, Integer&gt; &#123;&#125;\n\n三、使用接口类进行CRUD操作当UserDAO继承了JpaRepository后，可以在其它类中注入UserDAO，使用UserDAO进行简单的crud操作。在类UserService标注注解@Service的作用是，向容器中添加该类的组件，之后可以在其它地方使用注解@Autowired注入该类对象。\n@Servicepublic class UserService &#123;    @Autowired    UserDAO userDAO;    public void add(User user)&#123;        userDAO.save(user);    &#125; &#125;\nJPA注入：    使用注解@Autowired。    内部使用了@Autowired的类，在外面不能使用new创建该类对象，而是使用@Autowired注入对象，否则会导致JPA注入失败，报空指针异常。    eg：UserController类中使用了new UserService创建对象，导致UserService类中UserDAO注入失败，userDAO为null\n@Controllerpublic class UserController &#123;    @RequestMapping(&quot;/hello&quot;)    @ResponseBody    public void hi()&#123;        new UserService().add(new User());    &#125;&#125;\n\n正确用法是使用@Autowired注入UserService对象，如下所示\n@Controllerpublic class UserController &#123;    @Autowired    UserService userService;    @RequestMapping(&quot;/hello&quot;)    @ResponseBody    public void hi()&#123;        userService.add(new User());    &#125;&#125;","categories":["mysql","SpringBoot"],"tags":["JPA"]},{"title":"SpringBoot-方法参数","url":"/2021/12/02/springboot-fang-fa-can-shu/","content":"方法参数封装","categories":["SpringBoot"]},{"title":"aplayer","url":"/2021/10/30/aplayer/","content":"使用aplayer播放器\n安装aplayer使用命令fs    npm install aplayer –save\n文章添加音乐在文章头部Front-matter中添加语句，否则不成功    aplayer: true在文章正文中添加以下语句。（具体字段属性请参考官方文档）\n方法2：使用hexo-tag-aplayer插件实现安装插件    npm install –save hexo-tag-aplayer在hexo的配置文件 _config.yml 中添加以下语句。    aplayer:        true在文章正文添加以下语句。（具体字段属性请参考官方文档）使用hexo-tag-aplayer有个小问题，音乐播放列表列表不能折叠。添加”listfolded:true”后音乐页面直接不能显示了。\n\n\t\t\t\n\t\t\t\tconsole.error(\"Error: [hexo-tag-aplayer] Specified asset file not found (caffeine.mp3)\");\n\t\t\t\n\nwocao\n","categories":["blog"],"tags":["aplayer"]},{"title":"SpringBoot-注解","url":"/2021/11/15/springboot-zhu-jie/","content":"@Configuration和@Bean@Configuration注释类，向SpringBoot表示该类为一个配置类。该注解有一个属性proxyBeanMethods，默认为true，表示该类被SpringBoot所代理，可以理解为该被SpringBoot托管。@Configuration配置类本身也是一个组件，组件ID为类名（首字母小写）。\n@Bean注释方法，和@Configuration组合使用，表示向IOC容器中添加一个组件，组件ID默认为方法名，组件实例为方法的返回值。当@Configuration的proxyBeanMethods=true时，当使用类对象调用注解了@Bean的方法时，SpringBoot会去容器中寻找该组件，返回该组件的引用，而不是重新构造一个对象实例。多次从获取时，仍然引用的是容器中组件实例，即该方法的返回值保持单实例。当@Configuration的proxyBeanMethods=false时，表示配置类不会由SpringBoot所代理，使用类对象调用注解@Bean方法时，SpringBoot不会去容器中寻找组件，而是直接创建一个实例，每次调用都会创建不同的实例。\n@Configuration(&quot;haha&quot;)public class test &#123;    @Bean    public User user()&#123;        return new User();    &#125;&#125;@SpringBootApplicationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext app = SpringApplication.run(DemoApplication.class, args);        System.out.println(app.containsBean(&quot;haha&quot;));        System.out.println(app.containsBean(&quot;user&quot;));    &#125;&#125;\n输出结果为：\n组件依赖：小结：注解@Bean和@Configuration表示在SpringBoot启动时，像容器中添加一个组件。但是如果proxyBeanMethods=true，表示该类被SpringBoot代理。注意：如果使用普通方式，通过构造方法创建是实例时，和注解@Configuration、@Bean没有任何关系。\n@Import注释类。表示向容器中添加组件。使用方式：@Import(“class”, “.class”)，组件名为全类名\n参数自动封装表单的字段会被自动封装到参数对象中。表单name属性的值要和对象的属性名一致，否则会封装失败，造成对象的属性值为null的情况。代码示例：\njava代码@GetMapping(&quot;/form_createManager&quot;)    public String createManager(Manager manager)&#123;        if(managerService.isExitsByManagerName(manager.getName()))&#123;            return &quot;redirect:/createManager.html&quot;;        &#125;else &#123;            managerService.add(manager);            return &quot;redirect:/listManager.html&quot;;        &#125;    &#125;    html代码&lt;form action=&quot;/form_createManager&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;姓名&quot; name=&quot;name&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;手机&quot; name=&quot;phone&quot;&gt;    &lt;input type=&quot;email&quot; placeholder=&quot;邮箱&quot; name=&quot;email&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;","categories":["SpringBoot"],"tags":["注解"]},{"title":"Hello World","url":"/2021/10/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"html","url":"/2021/10/31/html/","content":"textareatextarea标签：\ncols:字符列数rows:字符行数readonly:值true/false 是否设为只读\n去除首行缩进：将首尾标签放在同一行\n&lt;textarea&gt;hello&lt;/textarea&gt;\n去除下拉斜线：添加属性 resize: none\n&lt;textarea style=&quot;resize: none;&quot;&gt;hello&lt;/textarea&gt;\n去除滚动条：添加属性 overflow: hidden\n&lt;textarea style=&quot;overflow: hidden;&quot;&gt;hello&lt;/textarea&gt;\n去除边框：添加属性border: none\n&lt;textarea style=&quot;border: none;&quot;&gt;hello&lt;/textarea&gt;\n去除点击文本时的边框：添加属性 outline: none\n&lt;textarea style=&quot;outline: none;&quot;&gt;hello&lt;/textarea\n显示高度自适应：\n&lt;textarea  autoHeight=&quot;true&quot; readonly=&quot;readonly&quot; style=&quot;resize: \t\tnone; border: none; overflow: hidden; outline: \tnone;&quot;&gt;qwerrtyuiopasdfghjklzxcnm1234567890qwertyuiopasdfghjklzxcvbnm&lt;/textarea&gt;\n$(function()&#123;        $.fn.autoHeight = function()&#123;                function autoHeight(elem)&#123;                elem.style.height = &#x27;auto&#x27;;                elem.scrollTop = 0; //防抖动                elem.style.height = elem.scrollHeight + &#x27;px&#x27;;            &#125;            this.each(function()&#123;                autoHeight(this);                $(this).on(&#x27;keyup&#x27;, function()&#123;                    autoHeight(this);                &#125;);            &#125;);     &#125;                   $(&#x27;textarea[autoHeight]&#x27;).autoHeight();    &#125;)\ntextarea自适应小问题：实际textarea的宽度比文字行数多了一行\n&lt;!--单个媒体对象 start--&gt;&lt;div class=&quot;media&quot;&gt;&lt;div class=&quot;media-left&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img class=&quot;media-object&quot; src=&quot;../images/72534562.jpg&quot; alt=&quot;头像&quot; width=&quot;64px&quot; height=&quot;64px&quot;&gt;&lt;h5 style=&quot;margin: 0px;text-align: center;&quot;&gt;用户名&lt;/h5&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;media-body&quot;&gt;&lt;h4 class=&quot;media-heading&quot;&gt;Media heading&lt;/h4&gt;&lt;textarea cols=&quot;50&quot; rows=&quot;3&quot; style=&quot;resize: none; border: none; overflow: hidden; outline: none;&quot; readonly=&quot;true&quot;&gt;Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo.&lt;/textarea&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--单个媒体对象 end--&gt;","categories":["html"]},{"title":"my-first-blog","url":"/2021/10/17/my-first-blog/","content":"Hexo + GitHub 搭建个人博客环境准备npm、git\n\n使用命令（均在git bash下执行）安装Hexo博客框架\nnpm install hexo-cli -g\n初始化项目文件夹\nhexo init 文件夹名称（后面不跟文件名称时，需要自己创建文件，并在切换到对应文件路径下执行该命令\n安装npm依赖。执行上条命令时，会提示dependencies 下载失败。按照提示运行命令。\nnpm install有时使用npm下载不成，可以使用cnpm install，多运行几次就好了（亲试）\n本地预览博客是否搭建成功。执行以下两条命令。\nhexo g\t#编译静态文件hexo s\t#本地预览\n访问 http://localhost:4000/ 。出现以下页面表示本地搭建成功。\n\n上线到Github准备工作：获取SSH密钥    查看本地有无SSH密钥    cd ~/.ssh    如果没有则生成密钥。    ssh-keygen -t rsa -C &quot;你的邮箱&quot;\t\t#会提示你设置密钥文件名称，和密码，两者都可以为空，直接回车    再次查看密钥文件，查询结果出现***.ssh文件表示成功，同样会显示密钥路径。Github设置SSH密钥    在setting中选中SSH and GPG keys，点击New SSH key，密钥名称任取，密钥内容使用记事本打开生成的密钥文件，复制过去，就ok了。安装Github部署插件    npm install hexo-deployer-git --saveGithub创建新库 username.github.io。修改项目目录下的配置文件。如下所示。    deploy: \t\ttype: git \t\trepo: git@github.com:up-bear/up-bear.github.io.git\t\t branch: master部署命令    hexo d每次修改博客后，需要使用以下命令重新部署hexo cleanhexo ghexo d访问博客网址username.github.io。\n\n    ","categories":["blog"]},{"title":"Java实体类和Mysql表结构","url":"/2021/11/26/mysql/","content":"mysql和实体类布尔类型mysql中没有布尔类型的数据，在实体类中的属性尽量使用布尔变量的封装类型Boolean\n@Entity@Table(name = &quot;a&quot;)public class A &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column    int id;    @Column    Boolean flag;        //set、get方法省略&#125;\n表结构中flag字段的类型为：\n字符串mysql中，字符串为空和为null，两者并不相等。字符串为空对应 “” 。要想查询数据表中字符串为空的记录，要传入参数 “” ,而不是 null\n","categories":["mysql"],"tags":["实体类"]},{"title":"注解与反射","url":"/2021/11/16/zhu-jie-yu-fan-she/","content":"注解Annotation作用：注释和解释（狂神说的，很喜欢，简洁）。被人用来注释代码，并交给JVM去解释执行。\n定义：\n@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation&#123;    public String value();&#125;\n以上就简单自定义了一个注解。在定义注解的时候可以使用其他注解。\n元注解：用来注解注解的注解。四个元注解：\n@Target 确定注解可以使用的地方，如类、接口、方法等@Retention 可以理解为注解的&quot;生命周期&quot;@Documented 此注解会被javadoc工具提取成文档@Inherited 允许子类继承父类中的注解\n\n反射Reflection个人理解：通过Class类去操纵对象的过程就称为反射。代码示例：\n\n","categories":["java"],"tags":["注解","反射"]},{"title":"thymeleaf","url":"/2021/10/30/thymeleaf/","content":"动态包含页面&lt;script&gt;    $(&quot;#head&quot;).load(&quot;public/head.html&quot;);&lt;/script&gt;\nIDEA创建SpringBoot项目重定向重定向的默认访问路径是Resource/templates,想要访问Resource/static下的静态资源返回字符串要明确添加redirect，例如 return “redirect:html/hello.html”\nbootstrap&amp;thymeleaf二者不兼容：bootstrap静态页面经由thymeleaf动态打开后静态页面样式消失\n动态创建列表代码示例：\n&lt;table&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;管理者名称&lt;/th&gt;        &lt;th&gt;手机&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr th:each=&quot;manager : $&#123;manager_list&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;manager.getName()&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;manager.phone&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;\n\n向request中放入一个名manager_list的List类型对象。 向Request、Model、ModelAndView中放入数据，都是一样的效果，因为三者最终都将数据放入了同一个地方（雷神SpringBoot2中有讲）\n使用Thymeleaf取数据，显示在列表中。 ${manager_list}:取出request中key为manager_list的对象 ${manager.getName()}和${manager.phone}两种方法都可以获取对象manager的属性\n\nThymeleaf常见错误\n路径拼写错误。 使用了Thymeleaf模板，默认使用了@Controller类的字符串返回类型会被当作转发请求，且返回的字符串不需要带后缀”.html’，因为Thymeleaf会默认去寻找html文件。如果想使用重定向，需要使用：return “redirect:请求路径”。\nthymeleaf获取request、session中的参数错误。 使用thymeleaf表达式 ${…} 获取数据时，一定要确保在到达该页面前一定已经向对应的request、session中放入了要取的数据，否则也会造成错误。 使用 ${对象.属性} 或 ${对象.方法} 获取数据时，一定确保属性名和方法名和Java类中的保持一致，即使少了一个字母也会报错\n\n","categories":["SpringBoot","html"],"tags":["bootstrap","thymeleaf"]},{"title":"重载与重写","url":"/2021/11/16/chong-zai-yu-chong-xie/","content":"重载描述：一个类中，同一个方法名，有用多个参数类型或数量不同的方法实现，则称之为方法重载。代码示例：\npublic class A&#123;\tpublic void methodA()&#123;&#125;;\tpublic void methodA(int a)&#123;&#125;;    public void methodA(String str)&#123;&#125;;&#125;\n\n继承定义：\npublic class B extends A&#123;\t&#125;\n类B继承了类A，B拥有A的所有方法（构造方法除外）和属性。类B可以对父类A的方法进行重写，还可以声明父类A没有的属性。构造方法：当父类有多个构造方法时，子类必须声明一个参数列表（可以是无参类型）和父类相同的构造方法，并在方法体的第一行调用父类的其中一个构造方法。注意，当父类只有默认无参构造方法时，子类的默认无参构造方法中默认调用了父类的无参构造方法。当以一个类声明了构造方法，默认的无参构造方法便不存在了。代码示例：\n示例一：public class Father &#123;    public Father()&#123;        System.out.println(&quot;Father&quot;);    &#125;    public Father(String name, String age)&#123;        System.out.println(name + age);    &#125;&#125;class Son extends Father&#123;    public Son(String name) &#123;        super();    &#125;&#125;示例二：public class Father &#123;    public Father()&#123;        System.out.println(&quot;Father&quot;);    &#125;    public Father(String name, String age)&#123;        System.out.println(name + age);    &#125;&#125;class Son extends Father&#123;\t//有默认的无参构造器，而且会默认调用父类的无参构造器\t\tpublic static void main(String[] args)&#123;\t\tnew Son();\t&#125;&#125;输出：Father示例三：public class Father &#123;    public Father(String name)&#123;        System.out.println(name);    &#125;    public Father(String name, String age)&#123;        System.out.println(name + age);    &#125;&#125;class Son extends Father&#123;\tpublic Son(String name)&#123;\t\tsuper(name + &quot;age&quot;);\t&#125;&#125;\n\n重写描述：子类继承父类，并对继承的父类方法进行重新实现的过程，称之为方法重写。\n代码示例\npublic class Father&#123;\tpublic String method1()&#123;\t\treturn &quot;father&quot;;\t&#125;&#125;public class Son extends Father&#123;\tpublic String method1()&#123;\t\treturn &quot;son&quot;\t&#125;&#125;\n\n向上转型与向下转型向上转型描述：把子类的对象实例赋值给父类的引用。代码示例：\npublic class Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;father&quot;);\t&#125;&#125;public class B extends Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;son&quot;);\t&#125;\t\tpublic static void main(String[] args)&#123;\t\tFather f = new Son();\t//向上转型,将子类实例赋值给父类引用。可以理解为把子类对象向上转换成父类对象。 \t\tf.method1();\t//输出结果为&quot;son&quot;,而不是&quot;father&quot;\t&#125;&#125;\n通过向上转型的获得的对象引用，在调用方法时，只能调用父类中已有的方法，但执行的方法体是子类的方法。\n易混淆情况：\npublic class Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;father&quot;);\t&#125;\t\tpublic void method2()&#123;\t\tSystem.out.println(&quot;father.method2&quot;);\t&#125;&#125;public class B extends Father&#123;\tpublic void method1()&#123;\t\tSystem.out.println(&quot;son&quot;);\t&#125;\t\tpublic static void main(String[] args)&#123;\t\tFather f = new Son();\t//向上转型,将子类实例赋值给父类引用。可以理解为把子类对象向上转换成父类对象。 \t\tf.method2();\t//输出结果为&quot;father.method2&quot;,method2()方法没有被子类B重写，是从父类A中继承过来的，也是类B的方法不要理解为method2不是B的方法。\t&#125;&#125;\n\n代码示例：\npublic class Father &#123;    public String method1()&#123;        return &quot;father&quot;;    &#125;&#125;class Son extends Father&#123;    public String method1()&#123;        return &quot;son&quot;;    &#125;    public String method2()&#123;        return &quot;Son.method2&quot;;    &#125;    public static void main(String[] args)&#123;        Father f = new Son();        //System.out.println(f.method2());\t该行会提示报错，因为f此时是Father类型，没有method2()方法        System.out.println(((Son)f).method2());\t//此时再使用向下转型，便不会报错。输出结果为&quot;Son.method2&quot;    &#125;&#125;\n\n向上转型经典例题class A &#123;    public String show(D obj) &#123;        return (&quot;A and D&quot;);    &#125;    public String show(A obj) &#123;        return (&quot;A and A&quot;);    &#125;&#125;class B extends A&#123;    public String show(B obj)&#123;        return (&quot;B and B&quot;);    &#125;    public String show(A obj)&#123;        return (&quot;B and A&quot;);    &#125;&#125;class C extends B&#123;&#125;class D extends B&#123;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        A a1 = new A();        A a2 = new B();        B b = new B();        C c = new C();        D d = new D();        System.out.println(&quot;1--&quot; + a1.show(b));        System.out.println(&quot;2--&quot; + a1.show(c));        System.out.println(&quot;3--&quot; + a1.show(d));        System.out.println(&quot;4--&quot; + a2.show(b));        System.out.println(&quot;5--&quot; + a2.show(c));        System.out.println(&quot;6--&quot; + a2.show(d));        System.out.println(&quot;7--&quot; + b.show(b));        System.out.println(&quot;8--&quot; + b.show(c));        System.out.println(&quot;9--&quot; + b.show(d));    &#125;&#125;//结果：//1--A and A//2--A and A//3--A and D//4--B and A//5--B and A//6--A and D//7--B and B//8--B and B//9--A and D//能看懂这个结果么？先自分析一下。\n这个例子是非常复杂的啦，要想完全理解后面几个输出结果还要知道一条重要知识：\n继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)(其实按照我前面的理解，感觉这一条原则不要也行，因为子类没有重写的方法是默认继承自父类的，验证了一下例题也没问题)\n对于输出4，a2.show(b))的输出结果是”B and A”。对象a2是A类型，但是指向B类型实例，为向上转型。a2可执行的方法名为类A中的方法，public String show(D obj)和public String show(A obj)；\n继承链第一步：this.show(O)显然不行，因为对象b是B类型，可执行方法中没有符合要求的。继承链第二步：super.show(O)，显然没有符合要求的。继承链第三步：this.show((super)O)，即shou((A) b)，执行类B中的方法show(A obj)，输出&quot;B and A&quot;\n对于输出5，分析同输出4，略。对于输出6，a2.show(d))的输出结果为”A and D”，也很好理解。\n继承链第一步：this.show(O)显然可以，因为类B继承了类A的public String show(D obj)方法，\n\n\n\n参考博文\n","categories":["java"]}]