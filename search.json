[{"title":"SpringBoot源码笔记","url":"/2022/01/19/springboot-yuan-ma-bi-ji/","content":"### 静态资源\n\n#### 默认路径\n项目资源文件夹resources下：/META-INF/resources/、/resources/、/static/、/public/ 共四个路径。即使是使用了thymeleaf模板的情况下，放在以上路径下的静态资源仍然可以被访问，而且在这些路径下的html页面中使用thymeleaf语法同样有效。（thymeleaf似乎值对拦截再templates路径下的资源访问进行拦截设置）\n源码探究：\n\n```java\npackage org.springframework.boot.autoconfigure.web;\n@ConfigurationProperties(\"spring.web\")\npublic class WebProperties {\n\tpublic static class Resources {\n\t\tprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\",\"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" };\n\t}\n}\n```\n##### 自定义资源路径\n注解@ConfigurationProperties(\"spring.web\")，WebProperties类下的属性和配置文件进行了绑定，在配置文件application.properties中即可自定义静态资源访问路径。\n```\n##由于CLASSPATH_RESOURCE_LOCATIONS被final修饰，所以不能修改\n##类属性和配置文件的对应规则：spring.web为注解设置前缀，resource对应内部类Resources的类名，static-locations对应类属性staticLocations\nspring.web.resources.static-locations = 自定义资源路径\n```\n源码探究：\n```java\npackage org.springframework.boot.autoconfigure.web;\n@ConfigurationProperties(\"spring.web\")\npublic class WebProperties {\n\tpublic static class Resources {\n\t\tprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\",\"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" };\n\t\tprivate String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;\n\t}\n}\n```\n\n#### 资源访问前缀\n默认访问前缀：/\n源码探究：\n\n```java\n@ConfigurationProperties(prefix = \"spring.mvc\")\npublic class WebMvcProperties {\n\tpublic static class Servlet {\n\t\t/**\n\t\t * Path of the dispatcher servlet. Setting a custom value for this property is not\n\t\t * compatible with the PathPatternParser matching strategy.\n\t\t */\n\t\tprivate String path = \"/\";\n\t}\n}\n```\n自定义访问前缀：\n```\nspring.web.servlet.path = 自定义前缀（注意要“/”结尾）\n```\n\n\n### web请求处理过程\n\n所有web请求都会进入到 org.springframework.web.servlet 包下的 DispatcherServlet 类的 doDispatch(HttpServletRequest request, HttpServletResponse response) 方法中\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\tHttpServletRequest processedRequest = request;\n\tHandlerExecutionChain mappedHandler = null;\t\n    boolean multipartRequestParsed = false;\n\n\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\t\n\ttry {\t\t\tModelAndView mv = null;\n\t\tException dispatchException = null;\n\n\t\ttry {\n\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t// Determine handler for the current request.\n\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\tif (mappedHandler == null) {\n\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine handler adapter for the current request.\n\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t// Process last-modified header, if supported by the handler.\n\t\t\tString method = request.getMethod();\n\t\t\tboolean isGet = HttpMethod.GET.matches(method);\n\t\t\tif (isGet || HttpMethod.HEAD.matches(method)) {\n\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//***（1）***\n             //***真正要开始处理请求映射的方法***\n\t\t\t// Actually invoke the handler.\n\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tdispatchException = ex;\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\t// As of 4.3, we're processing Errors thrown from handler methods as well,\n\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\n\t\t\tdispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n\t\t}\n\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t}\n\tcatch (Exception ex) {\n\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t}\n\tcatch (Throwable err) {\n\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\tnew NestedServletException(\"Handler processing failed\", err));\n\t}\n\tfinally {\n\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t// Instead of postHandle and afterCompletion\n\t\t\tif (mappedHandler != null) {\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Clean up any resources used by a multipart request.\n\t\t\tif (multipartRequestParsed) {\n\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n执行 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()) 时，会进入到 AbstractHandlerMethodAdapter 类的 handle(HttpServletRequest request, HttpServletResponse response, Object handler) 方法中（共有四个HandleMethodAdapter， 分别是...）。\n```java\npublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\t\treturn handleInternal(request, response, (HandlerMethod) handler);\n\t}\n```\n接着进入到 RequestMappingHandlerAdapter 类的 handleInternal(HttpServletRequest request,\nHttpServletResponse response, HandlerMethod handlerMethod) 方法\n```java\nprotected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n\tModelAndView mav;\n\tcheckRequest(request);\n\n\t// Execute invokeHandlerMethod in synchronized block if required.\n\tif (this.synchronizeOnSession) {\n\t\tHttpSession session = request.getSession(false);\n\t\tif (session != null) {\n\t\t\tObject mutex = WebUtils.getSessionMutex(session);\n\t\t\tsynchronized (mutex) {\n\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No HttpSession available -> no mutex necessary\n\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t}\n\t}\n\telse {\n         //***(2)***\n         //***开始进入请求方法执行流程***\n\t\t// No synchronization on session demanded at all...\n\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t}\n\t\tif (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n\t\tif (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n\t\t\tapplyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n\t\t}\n\t\telse {\n\t\t\tprepareResponse(response);\n\t\t}\n\t}\n\treturn mav;\n}\n```\n\n执行 mav = invokeHandlerMethod(request, response, handlerMethod) 进入到同类中的 invokeHandlerMethod(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod) 方法。\n```java\nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\tServletWebRequest webRequest = new ServletWebRequest(request, response);\n\ttry {\n\t\tWebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n\t\tModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\t\tServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n\t\tif (this.argumentResolvers != null) {\t\t\t\t\t\t  \n//***设置请求方法的参数解析器***\ninvocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n\t\t}\n\t\tif (this.returnValueHandlers != null) {\n//***设置请求方法的返回值处理器***\ninvocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n\t\t}\n\t\tinvocableMethod.setDataBinderFactory(binderFactory);\n\t\tinvocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tmavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n\t\tmodelFactory.initModel(webRequest, mavContainer, invocableMethod);\n\t\tmavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n\t\tAsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n\t\tasyncWebRequest.setTimeout(this.asyncRequestTimeout);\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\t\tasyncManager.setTaskExecutor(this.taskExecutor);\n\t\tasyncManager.setAsyncWebRequest(asyncWebRequest);\n\t\tasyncManager.registerCallableInterceptors(this.callableInterceptors);\n\t\tasyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n\t\tif (asyncManager.hasConcurrentResult()) {\n\t\t\tObject result = asyncManager.getConcurrentResult();\n\t\t\tmavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];\n\t\t\tasyncManager.clearConcurrentResult();\n\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\tString formatted = LogFormatUtils.formatValue(result, !traceOn);\n\t\t\t\treturn \"Resume with async result [\" + formatted + \"]\";\n\t\t\t});\n\t\t\tinvocableMethod = invocableMethod.wrapConcurrentResult(result);\n\t\t}\n        //***(3)***\n        //***开始处理请求方法的参数、试图等\n\t\tinvocableMethod.invokeAndHandle(webRequest, mavContainer);\n\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getModelAndView(mavContainer, modelFactory, webRequest);\n\t}\n\tfinally {\n\t\twebRequest.requestCompleted();\n}\n```\n请求方法参数解析器 ：{% asset_img 001.png %}\n请求方法返回值处理器：{% asset_img 002.png %}\n\n执行 invocableMethod.invokeAndHandle(webRequest, mavContainer)，进入到 ServletInvocableHandlerMethod 类下的 invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,Object... providedArgs) 方法。\n```java\npublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\tObject... providedArgs) throws Exception {\n    //***(4)***\n    //***对请求方法选择支持的参数类型解析器（可能不准确）***\n\tObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n\tsetResponseStatus(webRequest);\n\tif (returnValue == null) {\n\t\tif (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n\t\t\tdisableContentCachingIfNecessary(webRequest);\n\t\t\tmavContainer.setRequestHandled(true);\n\t\t\treturn;\n\t\t}\n\t}\n\telse if (StringUtils.hasText(getResponseStatusReason())) {\n\t\tmavContainer.setRequestHandled(true);\n\t\treturn;\n\t}\n\tmavContainer.setRequestHandled(false);\n\tAssert.state(this.returnValueHandlers != null, \"No return value handlers\");\n\ttry {\n\t\tthis.returnValueHandlers.handleReturnValue(\n\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n\t}\n\tcatch (Exception ex) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(formatErrorForReturnValue(returnValue), ex);\n\t\t}\n\t\tthrow ex;\n\t}\n}\n```\n\n执行 Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs) ，进入 InvocableHandlerMethod 类下的 invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object... providedArgs) 方法。\n```java\npublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\tObject... providedArgs) throws Exception {\n\t//***(5)***\n\tObject[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n\tif (logger.isTraceEnabled()) {\n\t\tlogger.trace(\"Arguments: \" + Arrays.toString(args));\n\t}\n\treturn doInvoke(args);\n}\n```\n\n执行 Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs) ，进入到通类下的 getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object... providedArgs) 方法。\n```java\nprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\tObject... providedArgs) throws Exception {\n\tMethodParameter[] parameters = getMethodParameters();\n\tif (ObjectUtils.isEmpty(parameters)) {\n\t\treturn EMPTY_ARGS;\n\t}\n\tObject[] args = new Object[parameters.length];\n\tfor (int i = 0; i < parameters.length; i++) {\n\t\tMethodParameter parameter = parameters[i];\n\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\targs[i] = findProvidedArgument(parameter, providedArgs);\n\t\tif (args[i] != null) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!this.resolvers.supportsParameter(parameter)) {\n\t\t\tthrow new IllegalStateException(formatArgumentError(parameter, \"No suitable resolver\"));\n\t\t}\n\t\ttry {\n\t\t\targs[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tString exMsg = ex.getMessage();\n\t\t\t\tif (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {\n\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\treturn args;\n}\n```\n暂时debug到此，睡了睡了。\n"},{"title":"SpringBoot-JPA","url":"/2021/12/04/springboot-jpa/","content":"### pom依赖配置\n#### jpa本身配置\n```\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n```\n#### 引入驱动依赖（mysql数据库操作必配）\n```\n<dependency>\n\t<groupId>mysql</groupId>\n\t<artifactId>mysql-connector-java</artifactId>\n</dependency>\n```\n\n#### mysql数据库链接\n```\n#数据库连接\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/admin?characterEncoding=UTF-8\nspring.datasource.username=用户名\nspring.datasource.password=用户密码\n#mysql驱动\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\n### 使用步骤\n#### 一、创建实体类\n实体类标注注解：@Entity、@Table。注意导入的包为：javax.persistence.*\n```java\n@Entity\n@Table(name = \"user\")\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column\n    int id;\n\n    @Column\n    String userName;\n\n    @Column\n    String name;\n\n    @Column\n    String headImg;\n\n    //性别\n    @Column\n    String gender;\n\n    @Column\n    String phone;\n\n    @Column\n    String email;\n\n    String password;\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setHeadImg(String headImg) {\n        this.headImg = headImg;\n    }\n\n    public String getHeadImg() {\n        return headImg;\n    }\n\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    public String getGender() {\n        return gender;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n}\n```\nJPA默认的字段命名规则是驼峰转换，eg：UserName --> user_name。\n\n#### JPA配置修改\n```\n#设置自动更新表结构\nspring.jpa.properties.hibernate.hbm2ddl.auto=update\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n#在控制台显示sql语句\nspring.jpa.show-sql= true\n```\n\n#### 二、继承JpaRepository接口\n```java\n//User对应要操作的数据表实体类，Integer是int类型的封装类，固定不变\npublic interface UserDAO extends JpaRepository<User, Integer> {}\n```\n\n#### 三、使用接口类进行CRUD操作\n当UserDAO继承了JpaRepository后，可以在其它类中注入UserDAO，使用UserDAO进行简单的crud操作。在类UserService标注注解@Service的作用是，向容器中添加该类的组件，之后可以在其它地方使用注解@Autowired注入该类对象。\n```java\n@Service\npublic class UserService {\n    @Autowired\n    UserDAO userDAO;\n\n    public void add(User user){\n        userDAO.save(user);\n    } \n}\n```\nJPA注入：\n\t使用注解@Autowired。\n\t内部使用了@Autowired的类，在外面不能使用new创建该类对象，而是使用@Autowired注入对象，否则会导致JPA注入失败，报空指针异常。\n\teg：UserController类中使用了new UserService创建对象，导致UserService类中UserDAO注入失败，userDAO为null\n\n```\n@Controller\npublic class UserController {\n    @RequestMapping(\"/hello\")\n    @ResponseBody\n    public void hi(){\n        new UserService().add(new User());\n    }\n}\n```\n\n正确用法是使用@Autowired注入UserService对象，如下所示\n```\n@Controller\npublic class UserController {\n\n    @Autowired\n    UserService userService;\n\n    @RequestMapping(\"/hello\")\n    @ResponseBody\n    public void hi(){\n        userService.add(new User());\n    }\n}\n```","tags":["JPA"],"categories":["mysql","SpringBoot"]},{"title":"SpringBoot-方法参数","url":"/2021/12/02/springboot-fang-fa-can-shu/","content":"### 方法参数封装\n","categories":["SpringBoot"]},{"title":"Java实体类和Mysql表结构","url":"/2021/11/26/mysql/","content":"### mysql和实体类\n#### 布尔类型\nmysql中没有布尔类型的数据，在实体类中的属性尽量使用布尔变量的封装类型Boolean\n```\n@Entity\n@Table(name = \"a\")\npublic class A {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column\n    int id;\n\n    @Column\n    Boolean flag;\n    \n    //set、get方法省略\n}\n```\n表结构中flag字段的类型为：{% asset_img 01.png %}\n\n#### 字符串\nmysql中，字符串为空和为null，两者并不相等。字符串为空对应 \"\" 。\n要想查询数据表中字符串为空的记录，要传入参数 \"\" ,而不是 null\n{% asset_img 02.png %}","tags":["实体类"],"categories":["mysql"]},{"title":"Java基础","url":"/2021/11/17/java-ji-chu/","content":"JDK版本：jdk11\n\n静态方法不能通过对象调用，只能通过类名调用。\n\n静态方法可被子类继承。\n\n类的int属性如果没有赋初值，则在创建类对象时，会被赋值为0。\n\tJPA可能就是根据对象的id是否为0来判断表中是否存在该对象的记录，从而决定save方法是插入还是修改操作。\n类的String类型的属性不会再创建对象时被赋默认值，为null。\n\t类的对象类型属性，创建时不会赋予默认值，为null。\n\t\n#### 字符串\n关于字符串，在JVM的底层好像有一个字符串常量池。\n```java\npublic class Test {\n\n    A a;\n\n    static class A{\n        int id;\n        String name;\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setId(int id) {\n            this.id = id;\n        }\n\n        public int getId() {\n            return id;\n        }\n    }\n\n    public static void main(String[] args) {\n         A a = new A();\n         a.setName(\"name\");\n        System.out.println(a.getName());\n         Test.alter1(a);\n        System.out.println(a.getName());\n        System.out.println();\n        String s = \"hello\";\n        System.out.println(s);\n        alter2(s);\n        System.out.println(s);\n    }\n\n    static void alter1(A a){\n        a.name = \"alterA\";\n    }\n\n    static void alter2(String str){\n        str = \"hi\";\n    }\n}\n```\n运行结果：{% asset_img 01.png %}","categories":["java"]},{"title":"注解与反射","url":"/2021/11/16/zhu-jie-yu-fan-she/","content":"### 注解Annotation\n作用：注释和解释（狂神说的，很喜欢，简洁）。被人用来注释代码，并交给JVM去解释执行。\n\n定义：\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@interface MyAnnotation{\n    public String value();\n}\n```\n以上就简单自定义了一个注解。在定义注解的时候可以使用其他注解。\n\n元注解：用来注解注解的注解。\n四个元注解：\n```\n@Target 确定注解可以使用的地方，如类、接口、方法等\n@Retention 可以理解为注解的\"生命周期\"\n@Documented 此注解会被javadoc工具提取成文档\n@Inherited 允许子类继承父类中的注解\n```\n\n### 反射Reflection\n个人理解：通过Class类去操纵对象的过程就称为反射。\n代码示例：\n```\n\n```\n","tags":["注解","反射"],"categories":["java"]},{"title":"重载与重写","url":"/2021/11/16/chong-zai-yu-chong-xie/","content":"### 重载\n描述：一个类中，同一个方法名，有用多个参数类型或数量不同的方法实现，则称之为方法重载。\n代码示例：\n```\npublic class A{\n\tpublic void methodA(){};\n\tpublic void methodA(int a){};\n    public void methodA(String str){};\n}\n```\n\n### 继承\n定义：\n```\npublic class B extends A{\n\t\n}\n```\n类B继承了类A，B拥有A的所有方法（构造方法除外）和属性。类B可以对父类A的方法进行重写，还可以声明父类A没有的属性。\n构造方法：当父类有多个构造方法时，子类必须声明一个参数列表（可以是无参类型）和父类相同的构造方法，并在方法体的第一行调用父类的其中一个构造方法。\n注意，当父类只有默认无参构造方法时，子类的默认无参构造方法中默认调用了父类的无参构造方法。\n当以一个类声明了构造方法，默认的无参构造方法便不存在了。\n代码示例：\n```\n示例一：\npublic class Father {\n    public Father(){\n        System.out.println(\"Father\");\n    }\n\n    public Father(String name, String age){\n        System.out.println(name + age);\n    }\n}\n\nclass Son extends Father{\n\n    public Son(String name) {\n        super();\n    }\n}\n\n示例二：\npublic class Father {\n    public Father(){\n        System.out.println(\"Father\");\n    }\n\n    public Father(String name, String age){\n        System.out.println(name + age);\n    }\n}\n\nclass Son extends Father{\n\t//有默认的无参构造器，而且会默认调用父类的无参构造器\n\t\n\tpublic static void main(String[] args){\n\t\tnew Son();\n\t}\n}\n输出：Father\n\n示例三：\npublic class Father {\n    public Father(String name){\n        System.out.println(name);\n    }\n\n    public Father(String name, String age){\n        System.out.println(name + age);\n    }\n}\n\nclass Son extends Father{\n\tpublic Son(String name){\n\t\tsuper(name + \"age\");\n\t}\n}\n```\n\n### 重写\n描述：子类继承父类，并对继承的父类方法进行重新实现的过程，称之为方法重写。\n\n\n代码示例\n```\npublic class Father{\n\tpublic String method1(){\n\t\treturn \"father\";\n\t}\n}\n\npublic class Son extends Father{\n\tpublic String method1(){\n\t\treturn \"son\"\n\t}\n}\n```\n\n### 向上转型与向下转型\n\n#### 向上转型\n描述：把子类的对象实例赋值给父类的引用。\n代码示例：\n```\npublic class Father{\n\tpublic void method1(){\n\t\tSystem.out.println(\"father\");\n\t}\n}\n\npublic class B extends Father{\n\tpublic void method1(){\n\t\tSystem.out.println(\"son\");\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tFather f = new Son();\t//向上转型,将子类实例赋值给父类引用。可以理解为把子类对象向上转换成父类对象。 \n\t\tf.method1();\t//输出结果为\"son\",而不是\"father\"\n\t}\n}\n```\n通过向上转型的获得的对象引用，在调用方法时，只能调用父类中已有的方法，但执行的方法体是子类的方法。\n\n易混淆情况：\n```\npublic class Father{\n\tpublic void method1(){\n\t\tSystem.out.println(\"father\");\n\t}\n\t\n\tpublic void method2(){\n\t\tSystem.out.println(\"father.method2\");\n\t}\n}\n\npublic class B extends Father{\n\tpublic void method1(){\n\t\tSystem.out.println(\"son\");\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tFather f = new Son();\t//向上转型,将子类实例赋值给父类引用。可以理解为把子类对象向上转换成父类对象。 \n\t\tf.method2();\t//输出结果为\"father.method2\",method2()方法没有被子类B重写，是从父类A中继承过来的，也是类B的方法不要理解为method2不是B的方法。\n\t}\n}\n```\n\n代码示例：\n```\npublic class Father {\n    public String method1(){\n        return \"father\";\n    }\n}\nclass Son extends Father{\n    public String method1(){\n        return \"son\";\n    }\n\n    public String method2(){\n        return \"Son.method2\";\n    }\n\n    public static void main(String[] args){\n        Father f = new Son();\n        //System.out.println(f.method2());\t该行会提示报错，因为f此时是Father类型，没有method2()方法\n        System.out.println(((Son)f).method2());\t//此时再使用向下转型，便不会报错。输出结果为\"Son.method2\"\n    }\n}\n```\n\n#### 向上转型经典例题\n```\nclass A {\n    public String show(D obj) {\n        return (\"A and D\");\n    }\n\n    public String show(A obj) {\n        return (\"A and A\");\n    }\n\n}\n\nclass B extends A{\n    public String show(B obj){\n        return (\"B and B\");\n    }\n\n    public String show(A obj){\n        return (\"B and A\");\n    }\n}\n\nclass C extends B{\n\n}\n\nclass D extends B{\n\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        A a1 = new A();\n        A a2 = new B();\n        B b = new B();\n        C c = new C();\n        D d = new D();\n\n        System.out.println(\"1--\" + a1.show(b));\n        System.out.println(\"2--\" + a1.show(c));\n        System.out.println(\"3--\" + a1.show(d));\n        System.out.println(\"4--\" + a2.show(b));\n        System.out.println(\"5--\" + a2.show(c));\n        System.out.println(\"6--\" + a2.show(d));\n        System.out.println(\"7--\" + b.show(b));\n        System.out.println(\"8--\" + b.show(c));\n        System.out.println(\"9--\" + b.show(d));\n    }\n}\n//结果：\n//1--A and A\n//2--A and A\n//3--A and D\n//4--B and A\n//5--B and A\n//6--A and D\n//7--B and B\n//8--B and B\n//9--A and D\n\n//能看懂这个结果么？先自分析一下。\n```\n这个例子是非常复杂的啦，要想完全理解后面几个输出结果还要知道一条重要知识：\n```\n继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)\n(其实按照我前面的理解，感觉这一条原则不要也行，因为子类没有重写的方法是默认继承自父类的，验证了一下例题也没问题)\n```\n对于输出4，a2.show(b))的输出结果是\"B and A\"。对象a2是A类型，但是指向B类型实例，为向上转型。a2可执行的方法名为类A中的方法，public String show(D obj)和public String show(A obj)；\n```\n继承链第一步：this.show(O)显然不行，因为对象b是B类型，可执行方法中没有符合要求的。\n继承链第二步：super.show(O)，显然没有符合要求的。\n继承链第三步：this.show((super)O)，即shou((A) b)，执行类B中的方法show(A obj)，输出\"B and A\"\n```\n对于输出5，分析同输出4，略。\n对于输出6，a2.show(d))的输出结果为\"A and D\"，也很好理解。\n```\n继承链第一步：this.show(O)显然可以，因为类B继承了类A的public String show(D obj)方法，\n```\n\n\n\n[参考博文](https://blog.csdn.net/qq_31655965/article/details/54746235)","categories":["java"]},{"title":"SpringBoot-注解","url":"/2021/11/15/springboot-zhu-jie/","content":"### @Configuration\n注释类，向SpringBoot表示该类为一个配置类。该注解有一个属性proxyBeanMethods，默认为true，表示该类被SpringBoot所代理，可以理解为该被SpringBoot托管。\n@Configuration配置类本身也是一个组件，组件ID为类名（首字母小写）。\n\n### @Bean\n用来注释方法，要和 “能将类作为组件添加到容器中” 的注解组合使用，例如@Configuration和@Conpoment。表示向IOC容器中添加一个组件，组件ID默认为方法名，组件实例为方法的返回值。\n当@Configuration的 proxyBeanMethods=true 时，当使用类对象调用注解了@Bean的方法时，SpringBoot会去容器中寻找该组件，返回该组件的引用，而不是重新构造一个对象实例。多次从获取时，仍然引用的是容器中组件实例，即该方法的返回值保持单实例。\n当@Configuration的proxyBeanMethods=false时，表示配置类不会由SpringBoot所代理，使用类对象调用注解@Bean方法时，SpringBoot不会去容器中寻找组件，而是直接创建一个实例，每次调用都会创建不同的实例。\n\n```java\n@Configuration(\"haha\")\npublic class test {\n    @Bean\n    public User user(){\n        return new User();\n    }\n}\n\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        ConfigurableApplicationContext app = SpringApplication.run(DemoApplication.class, args);\n        System.out.println(app.containsBean(\"haha\"));\n        System.out.println(app.containsBean(\"user\"));\n    }\n}\n```\n输出结果为：{% asset_img 01.png 输出结果 %}\n\n#### 组件依赖：\n小结：注解@Bean和@Configuration表示在SpringBoot启动时，像容器中添加一个组件。但是如果proxyBeanMethods=true，表示该类被SpringBoot代理。 \n注意：如果使用普通方式，通过构造方法创建是实例时，和注解@Configuration、@Bean没有任何关系。\n\n### @Import\n注释类。表示向容器中添加组件。\n使用方式：@Import(\"***class\", \"***.class\")，组件名为全类名\n\n### @Component\n\n标注在类上，表示将该类作为一个组件添加到Spring容器中。\n\n### @ConfigurationProperties\n@ConfigurationProperties注解可以和@Component搭配（同一类中），也可以和@EnableConfigurationProperties搭配（不同类中）。\n@ConfigurationProperties将类的属性和配置文件中的属性进行绑定。如果该类只有@ConfigurationProperties注解而没有@Component注解，那么配置绑定功能是无法实现的，因为该类没有被作为组件添加到Spring容器中（不能享受Spring容器带来的强大功能），此时可以在其他类中使用@EnableConfigurationProperties注解，将类添加到容器中，开启配置绑定功能。\n代码示例：\n\n```java\npackage org.springframework.boot.autoconfigure.web;\n@ConfigurationProperties(\"spring.web\")\npublic class WebProperties {\n\n\tpublic static class Resources {\n        //和配置文件application.properties中的 spring.web.resources.static-locations 进行绑定\n\t\tprivate String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;\n\t}\n}\n```\n\n### @EnableConfigurationProperties\n对只有@ConfigurationProperties注解而没有@Component注解的配置类，使用@EnableConfigurationProperties将配置类添加到容器中。\n代码示例：\n\n```java\npackage org.springframework.boot.autoconfigure.web.servlet;\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,\n\t\tValidationAutoConfiguration.class })\npublic class WebMvcAutoConfiguration {\n\n\t@Configuration(proxyBeanMethods = false)\n\t@Import(EnableWebMvcConfiguration.class)\n\t@EnableConfigurationProperties({ WebMvcProperties.class,\n\t\t\torg.springframework.boot.autoconfigure.web.ResourceProperties.class, WebProperties.class })\n\t@Order(0)\n\tpublic static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware {\n\t\n\t}\n}\n\n\npackage org.springframework.boot.autoconfigure.web.servlet;\n@ConfigurationProperties(prefix = \"spring.mvc\")\npublic class WebMvcProperties {\n\n}\n```\n\n### 参数自动封装\n表单的字段会被自动封装到参数对象中。表单name属性的值要和对象的属性名一致，否则会封装失败，造成对象的属性值为null的情况。\n代码示例：\n\n```java\n@GetMapping(\"/form_createManager\")\n    public String createManager(Manager manager){\n        if(managerService.isExitsByManagerName(manager.getName())){\n            return \"redirect:/createManager.html\";\n        }else {\n            managerService.add(manager);\n            return \"redirect:/listManager.html\";\n        }\n    }\n```\n```html\n<form action=\"/form_createManager\">\n    <input type=\"text\" placeholder=\"姓名\" name=\"name\">\n    <input type=\"text\" placeholder=\"手机\" name=\"phone\">\n    <input type=\"email\" placeholder=\"邮箱\" name=\"email\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n```","tags":["注解"],"categories":["SpringBoot"]},{"title":"html","url":"/2021/10/31/html/","content":"#### textarea\ntextarea标签：\n```\n\tcols:字符列数\n\trows:字符行数\n\treadonly:值true/false 是否设为只读\n```\n去除首行缩进：将首尾标签放在同一行\n```\n\t<textarea>hello</textarea>\n```\n去除下拉斜线：添加属性 resize: none\n```\n\t<textarea style=\"resize: none;\">hello</textarea>\n```\n去除滚动条：添加属性 overflow: hidden\n```\n\t<textarea style=\"overflow: hidden;\">hello</textarea>\n```\n去除边框：添加属性border: none\n```\n\t<textarea style=\"border: none;\">hello</textarea>\n```\n去除点击文本时的边框：添加属性 outline: none\n```\n\t<textarea style=\"outline: none;\">hello</textarea\n```\n显示高度自适应：\n```\n\t<textarea  autoHeight=\"true\" readonly=\"readonly\" style=\"resize: \t\tnone; border: none; overflow: hidden; outline: \t\n\tnone;\">qwerrtyuiopasdfghjklzxcnm1234567890qwertyuiopasdfghjklzxcvbnm\n\t</textarea>\n```\n```js\n$(function(){\n        $.fn.autoHeight = function(){    \n            function autoHeight(elem){\n                elem.style.height = 'auto';\n                elem.scrollTop = 0; //防抖动\n                elem.style.height = elem.scrollHeight + 'px';\n            }\n            this.each(function(){\n                autoHeight(this);\n                $(this).on('keyup', function(){\n                    autoHeight(this);\n                });\n            });     \n}                \n   $('textarea[autoHeight]').autoHeight();    \n})\n```\ntextarea自适应小问题：实际textarea的宽度比文字行数多了一行\n\n```\n<!--单个媒体对象 start-->\n<div class=\"media\">\n<div class=\"media-left\">\n<a href=\"#\">\n<img class=\"media-object\" src=\"../images/72534562.jpg\" alt=\"头像\" width=\"64px\" height=\"64px\">\n<h5 style=\"margin: 0px;text-align: center;\">用户名</h5>\n</a>\n</div>\n<div class=\"media-body\">\n<h4 class=\"media-heading\">Media heading</h4>\n<textarea cols=\"50\" rows=\"3\" style=\"resize: none; border: none; overflow: hidden; outline: none;\" readonly=\"true\">Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo.</textarea>\n</div>\n</div>\n<!--单个媒体对象 end-->\n```","categories":["html"]},{"title":"thymeleaf","url":"/2021/10/30/thymeleaf/","content":"### 动态包含页面\n```js\n<script>\n    $(\"#head\").load(\"public/head.html\");\n</script>\n```\n### IDEA创建SpringBoot项目\n#### 重定向\n重定向的默认访问路径是Resource/templates,想要访问Resource/static下的静态资源返回字符串要明确添加redirect，例如 return \"redirect:html/hello.html\"\n\n### bootstrap&thymeleaf\n二者不兼容：bootstrap静态页面经由thymeleaf动态打开后静态页面样式消失\n\n### 动态创建列表\n代码示例：\n```\n<table>\n    <thead>\n    <tr>\n        <th>管理者名称</th>\n        <th>手机</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr th:each=\"manager : ${manager_list}\">\n        <td th:text=\"${manager.getName()}\"></td>\n        <td th:text=\"${manager.phone}\"></td>\n    </tr>\n    </tbody>\n</table>\n```\n1. 向request中放入一个名manager_list的List类型对象。\n\t向Request、Model、ModelAndView中放入数据，都是一样的效果，因为三者最终都将数据放入了同一个地方（雷神SpringBoot2中有讲）\n2. 使用Thymeleaf取数据，显示在列表中。\n\t${manager_list}:取出request中key为manager_list的对象\n\t${manager.getName()}和${manager.phone}两种方法都可以获取对象manager的属性\n\n### Thymeleaf常见错误\n1. 路径拼写错误。\n\t使用了Thymeleaf模板，默认使用了@Controller类的字符串返回类型会被当作转发请求，且返回的字符串不需要带后缀\".html'，因为Thymeleaf会默认去寻找html文件。如果想使用重定向，需要使用：return \"redirect:请求路径\"。\n2. thymeleaf获取request、session中的参数错误。\n\t使用thymeleaf表达式 ${...} 获取数据时，一定要确保在到达该页面前一定已经向对应的request、session中放入了要取的数据，否则也会造成错误。\n\t使用 ${对象.属性} 或 ${对象.方法} 获取数据时，一定确保属性名和方法名和Java类中的保持一致，即使少了一个字母也会报错\n\n###  background-image: url() 拼接\n\n设置背景\n```html\n<div th:style=\"'background:url(' + @{/<path-to-image>} + ');'\"></div>\n```\n根据属性值改变背景\n```html\n<div class=\"media-object resource-card-image\"  th:style=\"'background:url(' + @{(${collect.webLogo}=='' ? 'img/favicon.png' : ${collect.webLogo})} + ')'\" ></div>\n```\n\n### 行内写法（表达式内联）\n语法：\n```\n<p>Hello, [[${session.user.name}]]!</p>\n```\n禁用内联：\n```\n<p th:inline=\"none\">A double array looks like this: [[1, 2, 3], [4, 5]]!</p>\n```","tags":["bootstrap","thymeleaf"],"categories":["SpringBoot","html"]},{"title":"aplayer","url":"/2021/10/30/aplayer/","content":"使用aplayer播放器\n### 安装aplayer\n使用命令fs\n\tnpm install aplayer --save\n### 文章添加音乐\n在文章头部Front-matter中添加语句，否则不成功\n\taplayer: true\n在文章正文中添加以下语句。（具体字段属性请参考官方文档）\n\n### 方法2：使用hexo-tag-aplayer插件实现\n安装插件\n\tnpm install --save hexo-tag-aplayer\n在hexo的配置文件 _config.yml 中添加以下语句。\n\taplayer:\n\t\ttrue\n在文章正文添加以下语句。（具体字段属性请参考官方文档）\n使用hexo-tag-aplayer有个小问题，音乐播放列表列表不能折叠。添加\"listfolded:true\"后音乐页面直接不能显示了。\n\n{% aplayerlist %}\n{\n\t\"narrow\": false,\n    \"autoplay\": true,                        \n    \"mode\": \"random\",                        \n    \"showlrc\": 3,                             \n    \"mutex\": true,                           \n    \"theme\": \"#e6d0b2\",\t                     \n    \"preload\": \"metadata\",                    \n    \"listmaxheight\": \"513px\",                 \n    \"music\": [\n    {\n    \t\"title\": \"CoCo\",\n        \"author\": \"Jeff Williams\",\n\t    \"url\": \"caffeine.mp3\",\n        \"pic\": \"caffeine.jpeg\",\n        \"lrc\": \"caffeine.txt\"\n     },\n\t {\n     \t\"title\": \"アイロニ\",\n        \"author\": \"鹿乃\",\n        \"url\": \"irony.mp3\",\n        \"pic\": \"irony.jpg\"\n\t }\n\t]\n}\n{% endaplayerlist %}\n\nwocao","tags":["aplayer"],"categories":["blog"]},{"title":"my-first-blog","url":"/2021/10/17/my-first-blog/","content":"\nHexo + GitHub 搭建个人博客\n===\n环境准备\n---\n\tnpm、git\n使用命令（均在git bash下执行）\n---\n安装Hexo博客框架\n```\n\tnpm install hexo-cli -g\n```\n初始化项目文件夹\n```\n\thexo init 文件夹名称（后面不跟文件名称时，需要自己创建文件，并在切换到对应文件路径下执行该命令\n```\n安装npm依赖。执行上条命令时，会提示dependencies 下载失败。按照提示运行命令。\n```\n\tnpm install\n\t有时使用npm下载不成，可以使用cnpm install，多运行几次就好了（亲试）\n```\n本地预览博客是否搭建成功。执行以下两条命令。\n```\n\thexo g\t#编译静态文件\n\thexo s\t#本地预览\n```\n访问 http://localhost:4000/ 。出现以下页面表示本地搭建成功。\n\n![img](https://gitee.com/lsc180/images/raw/master/img/20201105103838.png)\n\n上线到Github\n---\n准备工作：获取SSH密钥\n\t查看本地有无SSH密钥\n\t```\n\tcd ~/.ssh\n\t```\n\t如果没有则生成密钥。\n\t```\n\tssh-keygen -t rsa -C \"你的邮箱\"\t\t#会提示你设置密钥文件名称，和密码，两者都可以为空，直接回车\n\t```\n\t再次查看密钥文件，查询结果出现***.ssh文件表示成功，同样会显示密钥路径。\nGithub设置SSH密钥\n\t在setting中选中SSH and GPG keys，点击New SSH key，密钥名称任取，密钥内容使用记事本打开生成的密钥文件，复制过去，就ok了。\n安装Github部署插件\n\t```\n\tnpm install hexo-deployer-git --save\n\t```\nGithub创建新库 username.github.io。修改项目目录下的配置文件。如下所示。\n\t```\n\tdeploy:\n  \t\ttype: git\n  \t\trepo: git@github.com:up-bear/up-bear.github.io.git\n \t\t branch: master\n\t```\n部署命令\n\t```\n\thexo d\n\t每次修改博客后，需要使用以下命令重新部署\n\thexo clean\n\thexo g\n\thexo d\n\t```\n访问博客网址username.github.io。\n\n{% meting \"523845661\" \"netease\" \"playlist\" \"theme:#FF4081\" \"mode:circulation\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %}","categories":["blog"]},{"title":"Hello World","url":"/2021/10/17/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]