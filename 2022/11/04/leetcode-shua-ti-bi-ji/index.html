<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="upbear">
    
    <title>
        
            leetcode刷题笔记 |
        
        upbear
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"up-bear.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/favicon.ico","favicon":"/images/favicon.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="upbear" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/avatar.svg">
                </a>
            
            <a class="logo-title" href="/">
                upbear
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">leetcode刷题笔记</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/favicon.ico">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">upbear</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2022-11-04 11:32:03
    </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="优先队列、最大-小堆"><a href="#优先队列、最大-小堆" class="headerlink" title="优先队列、最大/小堆"></a>优先队列、最大/小堆</h2><p>优先队列：<br>优先队列是一种概念，而不是一种具体的数据结构。</p>
<p>满足以下条件的数据结构都可以叫优先队列：</p>
<ol>
<li>可以快速插入新元素</li>
<li>可以快速取出所有元素的最值</li>
</ol>
<p>使用最大堆可以实现最大优先队列，使用最小堆实现最小优先队列</p>
<p>最大堆和最小堆都是完全二叉树！</p>
<p>最大堆：父节点大于所有子孙节点<br>最小堆：父节点小于所有子孙节点</p>
<p><img src="/./leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/001.png" alt="img 001"></p>
<p>上图所示为一个最小堆。</p>
<p>堆的插入：</p>
<p><img src="/./leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/002.png" alt="img 002"></p>
<p>取出最值：根节点即为最值。</p>
<p>删除最值：首先将堆的最后一个节点复制到根节点（最值删除），并删除最后一个节点，然后将根节点不断向下调整，直至满足最大/小堆的定义。</p>
<p><img src="/./leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/003.png" alt="img 003"></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35500719/article/details/127142965" >https://blog.csdn.net/qq_35500719/article/details/127142965<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/ACM_hades/article/details/89671679" >https://blog.csdn.net/ACM_hades/article/details/89671679<i class="fas fa-external-link-alt"></i></a></li>
</ol>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><ol>
<li>队列中元素其对应在<strong>原来序列中的顺序必须是单调递增的</strong></li>
<li>队列中元素的大小必须是<strong>单调递(增/减/自定义)</strong></li>
</ol>
<h3 id="适用问题"><a href="#适用问题" class="headerlink" title="适用问题"></a>适用问题</h3><ol>
<li>RMQ</li>
</ol>
<h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/LJD201724114126/article/details/80663855" >https://blog.csdn.net/LJD201724114126/article/details/80663855<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/I-Love-You-520/p/13454305.html" >https://www.cnblogs.com/I-Love-You-520/p/13454305.html<i class="fas fa-external-link-alt"></i></a></li>
</ol>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h1 id="经典方法"><a href="#经典方法" class="headerlink" title="经典方法"></a>经典方法</h1><h2 id="DP动态规划"><a href="#DP动态规划" class="headerlink" title="DP动态规划"></a>DP动态规划</h2><h2 id="未解题目"><a href="#未解题目" class="headerlink" title="未解题目"></a>未解题目</h2><ol>
<li>LCP 64 二叉树灯饰</li>
<li>LCP 34 二叉树染色</li>
</ol>
<h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><h2 id="RMQ区间最值问题"><a href="#RMQ区间最值问题" class="headerlink" title="RMQ区间最值问题"></a>RMQ区间最值问题</h2><p><strong>Range Minimum/Maximum Query</strong></p>
<p>LeetCode 239. 滑动窗口最大值<br>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line"></span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"> </span><br><span class="line">示例2：</span><br><span class="line">输入：nums = [1], k = 1</span><br><span class="line"></span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>优先队列（堆）</strong><br>可以使用优先队列（最大堆）。为了保证滑动窗口的合法性，以二元数组（index，nums[index]）的形式进行入队。二元数组的作用会在代码中用注释标识出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b[<span class="number">1</span>]-a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, m = n - k + <span class="number">1</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            q.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, nums[i]&#125;);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="comment">//循环条件中的 i-k 正是当前位置 i 为右端点的窗口左界限，&lt;i-k 说明该值滑出窗口 </span></span><br><span class="line">                <span class="keyword">while</span> (q.peek()[<span class="number">0</span>] &lt;= i - k) q.poll();</span><br><span class="line">                ans[idx++] = q.peek()[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单调队列</strong><br>关于 RMQ 的另外一个优秀做法通常是使用「单调队列/单调栈」。</p>
<p>随着窗口的不断平移，该过程会一直发生。若同一时刻存在两个数  和 （）所在一个窗口内，下标更大的数会被更晚移出窗口，此时如果有  的话，可以完全确定  将不会成为后续任何一个窗口的最大值，此时可以将必然不会是答案的  从候选中进行移除。</p>
<p>不难发现，当我们将所有必然不可能作为答案的元素（即所有满足的小于等于  ）移除后，候选集合满足「单调递减」特性，即集合首位元素为当前窗口中的最大值（为了满足窗口长度为  的要求，在从集合头部取答案时需要先将下标小于的等于的  的元素移除）。</p>
<p>为方便从尾部添加元素，从头部获取答案，我们可使用「双端队列」存储所有候选元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, m = n - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; nums[d.peekLast()] &lt;= nums[i]) d.pollLast();</span><br><span class="line">            d.addLast(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; d.peekFirst() &lt;= i - k) d.pollFirst();</span><br><span class="line">                ans[i - k + <span class="number">1</span>] = nums[d.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 num[i] 比队列末尾小，则 num[i] 仍能入队，因为有可能成为窗口的最大值。<br>第二个 while 循环，为了保证宽距为 k 窗口的合法性，清除已滑出窗口的元素<br>ans[i - k + 1] = nums[d.peekFirst()] 清除不合法元素后，队列的首元素即为以当前 i 为窗口右边界的窗口最大值</p>
</blockquote>
<h3 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a class="link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247493262&amp;idx=1&amp;sn=2d8e192a5767b49b9a13a6192ab3b833" >https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247493262&amp;idx=1&amp;sn=2d8e192a5767b49b9a13a6192ab3b833<i class="fas fa-external-link-alt"></i></a></li>
</ol>
<p>再手写的话今天两道题的任务就G了，偷懒一下。。。</p>
<h1 id="1668-最大重复子字符串"><a href="#1668-最大重复子字符串" class="headerlink" title="1668.最大重复子字符串"></a>1668.最大重复子字符串</h1><p>给你一个字符串 sequence ，如果字符串 word 连续重复 k 次形成的字符串是 sequence 的一个子字符串，那么单词 word 的 重复值为 k 。单词 word 的 最大重复值 是单词 word 在 sequence 中最大的重复值。如果 word 不是 sequence 的子串，那么重复值 k 为 0 。</p>
<h2 id="方法1：简单枚举-动态规划"><a href="#方法1：简单枚举-动态规划" class="headerlink" title="方法1：简单枚举+动态规划"></a>方法1：简单枚举+动态规划</h2><p>巧妙思路：巧妙利用了状态方程：f[i] = f[i-word.length]+1，数组<code>f</code>的元素值只与前面间隔<code>word.length</code>的元素有关（题目要求是连续重复的子字符串），最后数组<code>f</code>中的最大值即为最大重复值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRepeating</span><span class="params">(String sequence, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sequence.length(), m = word.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sequence.charAt(i - m + j + <span class="number">1</span>) != word.charAt(j)) &#123;</span><br><span class="line">                    valid = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                f[i] = (i == m - <span class="number">1</span> ? <span class="number">0</span> : f[i - m]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(f).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer-047-二叉树剪枝"><a href="#剑指Offer-047-二叉树剪枝" class="headerlink" title="剑指Offer || 047.二叉树剪枝"></a>剑指Offer || 047.二叉树剪枝</h1><p>给定一个二叉树 根节点 root ，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树（所属节点值和为0的子树）。<br>节点 node 的子树为 node 本身，以及所有 node 的后代。</p>
<h2 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h2><p>从树的底部向上开始剪枝，采用<strong>后序遍历</strong>的方式遍历二叉树，先判断左右子树为非零子树后，再判断整棵树是否为非零树。<br>如果左或右子树为零树，则将其赋值为<code>null</code>，完成剪枝动作。</p>
<p>判断子树是否为零树方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeSum</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    v1 = node.left != <span class="keyword">null</span> ? ((node.left.val + treeSum(node.left)) &gt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line">    v2 = node.right != <span class="keyword">null</span> ? ((node.right.val + treeSum(node.right)) &gt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (node.val + v1 + v2) &gt;=<span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 方法：递归遍历二叉树，遍历方式采用后序遍历</span></span><br><span class="line"><span class="comment">         * 思路：每一子树综合值为‘1’或者‘0’,如果根节点及两个子树值都为‘0‘，则删除该根节点及其子树</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v1, v2;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            pruneTree(root.left);</span><br><span class="line">            v1 = treeSum(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pruneTree(root.right);</span><br><span class="line">            v2 = treeSum(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v1 == <span class="number">0</span>)</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(v2 == <span class="number">0</span>)</span><br><span class="line">            root.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((root.val + v1 + v2) == <span class="number">0</span>)</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeSum</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v1, v2;</span><br><span class="line"></span><br><span class="line">        v1 = node.left != <span class="keyword">null</span> ? ((node.left.val + treeSum(node.left)) &gt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line">        v2 = node.right != <span class="keyword">null</span> ? ((node.right.val + treeSum(node.right)) &gt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (node.val + v1 + v2) &gt;=<span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进完善"><a href="#改进完善" class="headerlink" title="改进完善"></a>改进完善</h3><p>问题：当前判断子树是否为零树的方法<code>treeSum</code>，由于我们是从下到上去剪枝，会产生子树重复判断的问题。<br>假定一个树有3层，且子树都是非零树，当剪枝操作进行到第2层，调用方法<code>treeSum</code>判断第2层子树时，第3层子树便重复判断了一次。</p>
<p>改进：使用空间换时间的思想，用一种数据结构记录当前子树所有节点值之和（或者用布尔变量表示是否为零树），当判断一棵二叉树的子树时，只需到<code>对应的子树根节点</code>去判断即可。（该子树之前已经被判断过）</p>
<h2 id="方法1：递归"><a href="#方法1：递归" class="headerlink" title="方法1：递归"></a>方法1：递归</h2><p>树相关的题目首先考虑用递归解决。首先确定边界条件，当输入为空时，即可返回空。然后对左子树和右子树分别递归进行 pruneTree 操作。递归完成后，当这三个条件：左子树为空，右子树为空，当前节点的值为 0，同时满足时，才表示以当前节点为根的原二叉树的所有节点都为 0，需要将这棵子树移除，返回空。有任一条件不满足时，当前节点不应该移除，返回当前节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路对比"><a href="#思路对比" class="headerlink" title="思路对比"></a>思路对比</h2><p>看了官方的解题思路后，感觉是我递归了，但没有完全递归。。。<br>官方递归代码之简洁，显得我自己的代码很sb。<br>说明我有巨大的进步空间。</p>
<h1 id="795-区间子数组个数"><a href="#795-区间子数组个数" class="headerlink" title="795.区间子数组个数"></a>795.区间子数组个数</h1><h2 id="失败思路"><a href="#失败思路" class="headerlink" title="失败思路"></a>失败思路</h2><p>二级循环。</p>
<p>失败原因：时间复杂度高，接近O(n平方)。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路1</span></span><br><span class="line"><span class="comment">         * 双指针法：时间复杂度接近二级循环</span></span><br><span class="line"><span class="comment">         * 问题：耗时久，时间复杂度高</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length)&#123;</span><br><span class="line">            j = i;</span><br><span class="line">            max = nums[j];</span><br><span class="line">            <span class="keyword">while</span> (j &lt; nums.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; max)</span><br><span class="line">                    max = nums[j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(max &lt; left)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(max &gt;= left &amp;&amp; max &lt;= right)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法1：一次遍历"><a href="#方法1：一次遍历" class="headerlink" title="方法1：一次遍历"></a>方法1：一次遍历</h2><p>一个子数组的最大值范围在 [left,right] 表示子数组中不能含有大于 right 的元素，且至少含有一个处于 [left,right] 区间的元素。</p>
<p>我们可以将数组中的元素分为三类，并分别用 0, 1, 2 来表示：</p>
<ul>
<li>小于 left，用 0 表示；</li>
<li>大于等于 left 且小于等于 right，用 1 表示；</li>
<li>大于 right，用 2 表示。</li>
</ul>
<p>那么本题可以转换为求解不包含 2，且至少包含一个 1 的子数组数目。我们遍历 i，并将右端点固定在 i，求解有多少合法的子区间。过程中需要维护两个变量：</p>
<ol>
<li>last1，表示上一次 1 出现的位置，如果不存在则为 -1</li>
<li>last2，表示上一次 2 出现的位置，如果不存在则为 -1</li>
</ol>
<p>如果 last !=−1，那么子数组若以 i 为右端点，合法的左端点可以落在 (last2，last1] 之间。这样的左端点共有 last1−last2 个。</p>
<p>因此，我们遍历 i ：</p>
<ol>
<li>如果 left &lt;= nums[i] &lt;= right，则令 last1 = i</li>
<li>如果 nums[i] &gt; right，令 last2 = i，last1 = -1</li>
</ol>
<p>如果 last != -1，则将 last1 - last2 累加到结果中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, last1 = -<span class="number">1</span>, last2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= left &amp;&amp; nums[i] &lt;= right)&#123;</span><br><span class="line">                last1 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; right)&#123;</span><br><span class="line">                last2 = i;</span><br><span class="line">                last1 = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(last1 != -<span class="number">1</span>)&#123;</span><br><span class="line">                res += last1 - last2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解思考"><a href="#题解思考" class="headerlink" title="题解思考"></a>题解思考</h3><p>该方法为什么只需要一次遍历？<br>因为使用了两个变量<code>last1</code>和<code>last2</code>记录上一次<code>1</code>和<code>2</code>出现的位置，然后通过<code>last1 - last2</code>来计算子数组的数量，代替了第二次遍历。</p>
<p>为什么能代替第二次遍历呢？<br>该方法再<code>i</code>的遍历中，将当前<code>i</code>所在位置作为<code>子数组的右端点</code>，而<code>子数组的左端点</code>的数量由<code>last1 - last2</code>计算。</p>
<p>这里着重说明一下两个变量的更新规则和累加规则：</p>
<ul>
<li>last1 在<code>nums[i] &lt; left</code>时是不更新的，因为这时的 nums[i] 只能作为右端点和前面的元素组成子数组，自己本身是不能作为左端点的！</li>
<li>累加操作，只有在 last1 != -1 时进行，因为要在<code>last1 - last2</code>中选择左端点！</li>
</ul>
<p>该类似双指针，一开始我认为我的失败代码是双指针，简直笑死，算是真假李逵了。</p>
<h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h1><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<h2 id="个人思路-1"><a href="#个人思路-1" class="headerlink" title="个人思路"></a>个人思路</h2><p>将 int 型的<strong>最大值或最小值</strong>装入数组 ms 中（不包括符号），同时将 <strong>x</strong> 也反转装入数组 xs 中（位数不够时前面补零）。<br>最终输出结果时，将 xs 和 ms 对位比较，通过一个 int 变量 s，判断反转后的 x是否会超出界限</p>
<ul>
<li>s 初始值 = 1</li>
<li>如果 xs[i] &lt; ms[i]，s = s*0</li>
<li>如果 xs[i] == ms[i]，s = s*1</li>
<li>如果 xs[i] &gt; ms[i]，s = s*2；</li>
</ul>
<p>对位比较结束时，如果 s &lt;= 1，则反转后的 <strong>x</strong> 不超出界限，否则返回0。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 首先获取符号 +/-</span></span><br><span class="line"><span class="comment">         * 将int型的 Max 和 Min存入最值数组中</span></span><br><span class="line"><span class="comment">         * 将x也补零倒叙装入数组中</span></span><br><span class="line"><span class="comment">         * 通过两个数组进行比较</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ms;</span><br><span class="line">        <span class="keyword">int</span>[] xs;</span><br><span class="line">        <span class="keyword">if</span>( x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            len = String.valueOf(Integer.MAX_VALUE).length();</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            m = Integer.MAX_VALUE;</span><br><span class="line">            ms = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            xs = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            len = String.valueOf(Integer.MIN_VALUE).length()-<span class="number">1</span>;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">            m = Integer.MIN_VALUE;</span><br><span class="line">            ms = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            xs = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ms[len - <span class="number">1</span> - i] = flag * (m % <span class="number">10</span>);</span><br><span class="line">            m = m / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;  <span class="comment">//如果对位ys[i] &lt; ms[i]，s = s*0；如果对位等于，s = s*1；如果对位大于，s = s*2；</span></span><br><span class="line">        <span class="keyword">int</span> lenX = flag &gt; <span class="number">0</span> ? String.valueOf(x).length() : String.valueOf(x).length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; len - lenX)&#123;</span><br><span class="line">                xs[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                xs[i] = flag * (x % <span class="number">10</span>);</span><br><span class="line">                x = x / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xs[i] &lt; ms[i]) &#123;</span><br><span class="line">                    s = s * <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xs[i] == ms[i])&#123;</span><br><span class="line">                    s = s * <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    s = s * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            y = y*<span class="number">10</span> + xs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> flag * y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><p>解答成功:<br>    执行耗时:1 ms,击败了43.24% 的Java用户<br>    内存消耗:39 MB,击败了35.08% 的Java用户</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>负数对10求余，结果为负数！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = -123;</span><br><span class="line">int y = x % 10;</span><br><span class="line"></span><br><span class="line">输出：y = -3</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer-55-II-平衡二叉树"><a href="#剑指Offer-55-II-平衡二叉树" class="headerlink" title="剑指Offer 55 - II.平衡二叉树"></a>剑指Offer 55 - II.平衡二叉树</h1><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<h2 id="个人思路-2"><a href="#个人思路-2" class="headerlink" title="个人思路"></a>个人思路</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 前序遍历</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ld = countDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rd = countDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Math.abs(ld-rd) &gt; <span class="number">1</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>) &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDepth</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(countDepth(node.left), countDepth(node.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意后面还要判断左右子树是否为平衡树</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + Math.max(countDepth(node.left), countDepth(node.right));</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer-07-重建二叉树"><a href="#剑指Offer-07-重建二叉树" class="headerlink" title="剑指Offer 07.重建二叉树"></a>剑指Offer 07.重建二叉树</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。<br>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<h2 id="个人思路-3"><a href="#个人思路-3" class="headerlink" title="个人思路"></a>个人思路</h2><p>记录下思路加深记忆。</p>
<p>前序数组：pre = {3,9,20,15,7}<br>中序数组：in = {9,3,15,20,7}</p>
<p>每次重建一个节点需要以下参数：</p>
<ul>
<li>pre：前序数组</li>
<li>i1：前序数组中<strong>树节点范围</strong>开始下标</li>
<li>i2：前序数组中<strong>树节点范围</strong>末尾下标</li>
<li>in：中序数组</li>
<li>j1：中序数组<strong>树节点范围</strong>开始下标</li>
<li>j2：中序数组<strong>树节点范围</strong>末尾下标</li>
</ul>
<blockquote>
<p><strong>树节点范围</strong>指的是当前所重建节点及其所有子孙节点</p>
</blockquote>
<p>重建节点所需步骤：</p>
<ol>
<li>**pre[i1]**肯定为重建的根节点值</li>
<li><strong>in</strong>数组中和<strong>pre[i1]<strong>值相同的下标设为</strong>j</strong></li>
<li>**in[j]**左边为重建根节点左子树的所有节点，右边为重建根节点右子树的所有节点</li>
<li>重复以上操作重建根节点的左右子节点</li>
</ol>
<p>终止条件：</p>
<ol>
<li>i1 &gt; i2：重建所需节点数量为空，返回<strong>null</strong></li>
<li>i1 = i2：重建只需一个节点，则不需要再递归重建其左右子节点，直接返回该重建节点</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="keyword">null</span> ||preorder.length == <span class="number">0</span> || inorder == <span class="keyword">null</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length-<span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span>[] in, <span class="keyword">int</span> j1, <span class="keyword">int</span> j2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i1 &gt; i2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(pre[i1]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i1 == i2)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = j1;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt;= j2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j] == pre[i1])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = build(pre, i1+<span class="number">1</span>, i1+j-j1, in, j1, j-<span class="number">1</span>);</span><br><span class="line">        node.right = build(pre, i1+j-j1+<span class="number">1</span>, i2, in, j+<span class="number">1</span>, j2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1110-删点成林"><a href="#1110-删点成林" class="headerlink" title="1110.删点成林"></a>1110.删点成林</h1><p>给出二叉树的根节点 root，树上每个节点都有一个不同的值。<br>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。<br>返回森林中的每棵树。你可以按任意顺序组织答案。</p>
<h2 id="个人思路-4"><a href="#个人思路-4" class="headerlink" title="个人思路"></a>个人思路</h2><p>首先，判断一个节点是普通节点还是待删节点：</p>
<ul>
<li>普通节点：继续判断左右子节点，递归</li>
<li>待删节点：将该节点赋值为<code>null</code>，并对待删节点执行<strong>删除操作shear</strong><ul>
<li>将待删节点置为<code>null</code>需要借助其父节点，因为Java中的引用传递实质上也是值传递，只不过传递的是对象存储地址，因此在普通节点的递归函数<code>iterator</code>含有一个父节点参数！</li>
<li>删除操作shear：首先尝试从<code>list</code>中移除待删节点（因为后面会将待删节点左右子节点放入<code>list</code>中，如果后面递归中发现其子节点也是待删节点，则需从链表中移除！删除失败也无关紧要嘛），然后将其非空子节点放入链表中。</li>
</ul>
</li>
</ul>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">delNodes</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] to_delete)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : to_delete)&#123;</span><br><span class="line">            set.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode n0 = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        n0.left = root;</span><br><span class="line">        list.add(root);</span><br><span class="line">        iterator(n0, root, set);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否要删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIn</span><span class="params">(<span class="keyword">int</span> val, Set&lt;Integer&gt; set)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> set.contains(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(TreeNode root, TreeNode node, Set&lt;Integer&gt; set)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isIn(node.val, set))&#123;</span><br><span class="line">            shear(node, set);</span><br><span class="line">            <span class="keyword">if</span>(root.left == node)</span><br><span class="line">                root.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            iterator(node, node.left, set);</span><br><span class="line">            iterator(node, node.right, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shear</span><span class="params">(TreeNode root, Set&lt;Integer&gt; set)</span></span>&#123;</span><br><span class="line">        list.remove(root);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(root.left);</span><br><span class="line">            iterator(root, root.left, set);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(root.right);</span><br><span class="line">            iterator(root, root.right, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不足之处-1"><a href="#不足之处-1" class="headerlink" title="不足之处"></a>不足之处</h3><p>方法运行耗时和内存消耗不理想（leetcode打败几%的用户），我的方法也只对二叉树做一次遍历啊，复杂度应该是<code>O(n)</code>啊，暂时没想通为什么。</p>
<h2 id="labuladong"><a href="#labuladong" class="headerlink" title="labuladong"></a>labuladong</h2><p>关键在于理解到<strong>一个节点不是待删节点，且没有父节点，则是一棵新树</strong><br>其他细节：</p>
<ul>
<li>利用递归函数<code>doDelete</code>的返回值来完成节点的删除操作，即<strong>分解问题</strong>的思路</li>
<li>使用布尔变量<code>hasParent</code>传递节点是否有父节点这一信息</li>
</ul>
<p>这就是刷题二十年的功力，妙啊！</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; delSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">delNodes</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d : to_delete)&#123;</span><br><span class="line">            delSet.add(d);</span><br><span class="line">        &#125;</span><br><span class="line">        doDelete(root, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">doDelete</span><span class="params">(TreeNode root, <span class="keyword">boolean</span> hasParent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> deleted = delSet.contains(root.val);</span><br><span class="line">        <span class="keyword">if</span>(!deleted &amp;&amp; !hasParent)&#123;</span><br><span class="line">            res.add(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = doDelete(root.left, !deleted);</span><br><span class="line">        root.right = doDelete(root.right, !deleted);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deleted ? <span class="keyword">null</span> : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h1><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h2 id="个人思路-5"><a href="#个人思路-5" class="headerlink" title="个人思路"></a>个人思路</h2><p>对每个结点进行的操作：</p>
<ul>
<li>将左右字节点连接</li>
<li>将本节点的右子节点和<strong>右边兄弟节点</strong>的左子节点连接</li>
</ul>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果节点1的左右节点都不为 null，则将左子节点与右子节点连接</span></span><br><span class="line">        <span class="comment">//然后判断节点1是否有右侧节点，如果有，则将节点1的右子节点和节点2的右子节点进行连接</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)</span><br><span class="line">            root.left.next  = root.right;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span> &amp;&amp; root.next != <span class="keyword">null</span>)</span><br><span class="line">            root.right.next = root.next.left;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="labuladong-1"><a href="#labuladong-1" class="headerlink" title="labuladong"></a>labuladong</h2><p>将此题目中的二叉树看作一个三叉树，<strong>连接左右节点</strong>整体看作第三个节点（从代码的递归函数形式看勉强算吧，感觉这个抽象不是很有意义）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 遍历「三叉树」，连接相邻节点</span></span><br><span class="line">    traverse(root.left, root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node node1, Node node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">    <span class="comment">// 将传入的两个节点穿起来</span></span><br><span class="line">    node1.next = node2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接相同父节点的两个子节点</span></span><br><span class="line">    traverse(node1.left, node1.right);</span><br><span class="line">    traverse(node2.left, node2.right);</span><br><span class="line">    <span class="comment">// 连接跨越父节点的两个子节点</span></span><br><span class="line">    traverse(node1.right, node2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.二叉树展开为链表</h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li>
<li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li>
</ul>
<h2 id="个人思路-6"><a href="#个人思路-6" class="headerlink" title="个人思路"></a>个人思路</h2><p>采用分解问题的思路</p>
<p>每个节点进行的操作：</p>
<ul>
<li>返回当前子树的<strong>最右端节点</strong></li>
<li>将左子树迁移到子树的右边</li>
<li>将右子树迁移到<strong>最右端节点</strong>下面</li>
</ul>
<p>代码的复杂之处就在于<strong>如何找到并返回最右端节点</strong>，相比之下<strong>labuladong</strong>的思路就要巧妙很多，代码也简洁易懂</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每个子树根节点操作如下：</span></span><br><span class="line">        <span class="comment">// 1.TreeNode node = root.right</span></span><br><span class="line">        <span class="comment">// root.right = root.left</span></span><br><span class="line">        <span class="comment">// root.left = null</span></span><br><span class="line">        <span class="comment">// 2.返回最右端的节点 root_maxRight</span></span><br><span class="line">        <span class="comment">// root_maxRight.right = node</span></span><br><span class="line">        <span class="comment">// 关键！！！</span></span><br><span class="line">        <span class="comment">// 如果返回子树的最优端节点</span></span><br><span class="line"></span><br><span class="line">        change(root, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">change</span><span class="params">(TreeNode root, TreeNode parent)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode tempLeft = root.left;</span><br><span class="line">        TreeNode tempRight = root.right;</span><br><span class="line">        <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.right = root;</span><br><span class="line">            parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode leftParent = change(tempLeft, root);</span><br><span class="line">        TreeNode rightParent = <span class="keyword">null</span>;    </span><br><span class="line">        <span class="keyword">if</span>(leftParent != <span class="keyword">null</span>)</span><br><span class="line">            rightParent = change(tempRight, leftParent);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rightParent = change(root.right, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rightParent != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> rightParent;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftParent != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> leftParent;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="labuladong-2"><a href="#labuladong-2" class="headerlink" title="labuladong"></a>labuladong</h2><p>思路的巧妙之处在于：在后序位置利用了前面已经被递归处理的节点肯定是<strong>链式连接</strong>的，使用一个简单的循环就可以找出<strong>右子树需要连接的头节点</strong>，也即<strong>最右端节点</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：将以 root 为根的树拉平为链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用定义，把左右子树拉平</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**** 后序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">// 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    TreeNode right = root.right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、将左子树作为右子树</span></span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    root.right = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将原先的右子树接到当前右子树的末端</span></span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    p.right = right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p><strong>labuladong</strong>的代码胜在思路简单，代码优雅。但是我的代码在<strong>寻找最右端节点</strong>上不需要遍历之前已经处理过的节点，时间复杂度上应该会小胜一筹。嘻嘻。</p>
<h1 id="1372-二叉树中的最长交错路径"><a href="#1372-二叉树中的最长交错路径" class="headerlink" title="1372.二叉树中的最长交错路径"></a>1372.二叉树中的最长交错路径</h1><p>给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：</p>
<ul>
<li>选择二叉树中 任意 节点和一个方向（左或者右）</li>
<li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点</li>
<li>改变前进方向：左变右或者右变左</li>
<li>重复第二步和第三步，直到你在树中无法继续移动</li>
<li>交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）</li>
</ul>
<p>请你返回给定树中最长 交错路径 的长度。</p>
<h2 id="个人思路-7"><a href="#个人思路-7" class="headerlink" title="个人思路"></a>个人思路</h2><p>题目的注意点：节点的走向必须左右交替进行</p>
<p>采用遍历二叉树思路</p>
<p>每个节点需要做的事情：</p>
<ul>
<li>接替父节点的路径，方向交替的走向其子节点（如果父节点选择左方向，则该节点应选右方向走向其右子节点），路径长度加一</li>
<li>开辟一个新的路径，作为起始节点。选择与父节点相同的方向走向子节点，路径长度置零</li>
<li>更新最大路径长度</li>
</ul>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            traverse(root.left, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            traverse(root.right, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 路径长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> direction 0:左， 1：右</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> length, <span class="keyword">int</span> direction)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(length+<span class="number">1</span> &gt; max)</span><br><span class="line">            max = length+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(direction == <span class="number">0</span>) &#123;</span><br><span class="line">            traverse(root.left, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            traverse(root.right, length + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            traverse(root.left, length+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            traverse(root.right, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1696-跳跃游戏-VI"><a href="#1696-跳跃游戏-VI" class="headerlink" title="1696.跳跃游戏 VI"></a>1696.跳跃游戏 VI</h1><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。</p>
<p>一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。</p>
<p>你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。</p>
<p>请你返回你能得到的 最大得分 。</p>
<h2 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h2><p>思路如下：题目限制每次最大跳<code>K</code>步，且首尾已经限制，追求跳跃总和最大。每次在接下来的<code>K</code>个元素中<strong>顺序寻找第一个正数</strong>，加入到总和中；如果<code>K</code>个元素全为负则寻找<strong>最大的负数</strong>加入到总和中。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case: i=0, return nums[0],即f(0) = nums[0]</span></span><br><span class="line">        <span class="comment">//状态转移方程: f(n) = max&#123;f(n-m), m = 1,...,k&#125; + nums[n]</span></span><br><span class="line">        <span class="comment">//有两种写法：1. 从nums[n-1]倒着计算</span></span><br><span class="line">        <span class="comment">//          2. 从nums[0]顺着计算</span></span><br><span class="line">        <span class="keyword">return</span> dp(nums, k, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-<span class="number">1</span>-j &gt;= <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>-j] &gt; max)&#123;</span><br><span class="line">                max = nums[i-<span class="number">1</span>-j];</span><br><span class="line">                maxIndex = i-<span class="number">1</span>-j;</span><br><span class="line">                <span class="keyword">if</span>(max &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[i] + dp(nums, k, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><p>如果测试数据中出现一长段连续负数，<code>-1, -100, -100, -100, 1</code>，假设<code>K=3</code>此时按照思路会依次选择<code>-1, -100, 1</code>，但是实际上应该选择<code>-100, 1</code>。证明思路有问题！！！</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>这题也是用<strong>动态规划</strong>思路去解的，但是在解题的过程中太过注重问题细节，反观<strong>labuladong</strong>的题解，会发现<strong>动态规划类型问题</strong>的关键在于明确<strong>状态转移方程</strong>、如何定义<strong>dp函数/数组</strong>、怎么做<strong>选择</strong>，不用去过分关注解题的每一步是怎么进行，这些<strong>动态规划框架</strong>会帮你完成！！！</p>
<h2 id="labuladong-3"><a href="#labuladong-3" class="headerlink" title="labuladong"></a>labuladong</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步，暴力递归解法（超时）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">return</span> dp(nums, n - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：到达 nums[p] 所能获得的最大分数是 dp(nums, p)</span></span><br><span class="line">    <span class="comment">// 能跳到 nums[p]，必然是从 nums[p-k..p-1] 中的某个位置跳来的</span></span><br><span class="line">    <span class="comment">// 故状态转移方程为：dp[p] = max(nums[p-k..p-1]) + nums[p]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现状态转移方程</span></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp(nums, p - i, k));</span><br><span class="line">        &#125;</span><br><span class="line">        res += nums[p];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，带备忘录的递归解法（超时）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 备忘录初始化为最小值</span></span><br><span class="line">        Arrays.fill(memo, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">return</span> dp(nums, n - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：到达 nums[p] 所能获得的最大分数是 dp(nums, p)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查备忘录，避免冗余计算</span></span><br><span class="line">        <span class="keyword">if</span> (memo[p] != Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现状态转移方程，结果存入备忘录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            memo[p] = Math.max(memo[p], dp(nums, p - i, k));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[p] += nums[p];</span><br><span class="line">        <span class="keyword">return</span> memo[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步，自顶向下的递归改为自底向上的迭代解法（超时）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 定义：到达 nums[p] 的最大分数为 dp[p]</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// dp 数组初始化为最小值</span></span><br><span class="line">        Arrays.fill(dp, Integer.MIN_VALUE);</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; n; p++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p - i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[p] = Math.max(dp[p], dp[p - i]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[p] += nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四步，利用单调队列结构消除内层循环（通过）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        MonotonicQueue&lt;Integer&gt; window = <span class="keyword">new</span> MonotonicQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 定义：到达 nums[p] 的最大分数为 dp[p]</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// dp 数组初始化为最小值</span></span><br><span class="line">        Arrays.fill(dp, Integer.MIN_VALUE);</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        window.push(dp[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; n; p++) &#123;</span><br><span class="line">            dp[p] = window.max() + nums[p];</span><br><span class="line">            <span class="comment">// 维护窗口装着 dp[p-1..p-k]</span></span><br><span class="line">            <span class="keyword">if</span> (window.size() == k) &#123;</span><br><span class="line">                window.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            window.push(dp[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">单调队列的通用实现，可以高效维护最大值和最小值</span></span><br><span class="line"><span class="comment">由于考虑泛型和通用性，提交的性能会略差，你可自行精简</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h1><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。</p>
<p>返回 你可以获得的最大乘积 。</p>
<blockquote>
<p>2 &lt;= n &lt;= 58</p>
</blockquote>
<h2 id="思路初试"><a href="#思路初试" class="headerlink" title="思路初试"></a>思路初试</h2><p>读完题目可以感觉到是<strong>动态规划</strong>题目，那么想出<strong>状态转移方程</strong>是最为重要的。</p>
<p>很明显<strong>状态即数字n的大小</strong>，题目要求的是<strong>求和为n的一系列数字的乘积最大</strong>，那么可以想到构造方程：<code>f(n) = max&#123;k * f(n-k), k=1,2,...,n-1&#125;</code><br>用长度为n的数组<code>states</code>作为<code>bp Table</code>来完成剪枝</p>
<blockquote>
<p>题目中要求 n &gt;=2，状态方程中n实际上可以为 1，但是这没有太大关系</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] states;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * f(n) = max&#123;(n-k)*f(k), k = 1,2,...,n-2,n-1&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        states = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> bp(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bp</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(states[n] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> states[n];</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i*bp(n-i);</span><br><span class="line">            <span class="keyword">if</span>(max &lt; temp)</span><br><span class="line">                max = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        states[n] = max;</span><br><span class="line">        <span class="keyword">return</span> states[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提交运行，报错。<code>f(10)</code>结果为<code>27</code>。debug发现，求解过程中，<code>f(4)</code>结果为<code>3</code>，这显然是不对的，说明我们的状态方程出了问题。</p>
<h2 id="思路改进"><a href="#思路改进" class="headerlink" title="思路改进"></a>思路改进</h2><p><code>f(4) = max&#123;1*f(3), 2*f(2), 3*f(1)&#125;</code>，这里<code>f(2)=1</code>，到这里就能看出问题所在了。<code>f(4)</code>应该为<code>2*2 = 4</code>，但是按照我们的状态方程，我们又把<code>后面的2</code>转换为<code>f(2)</code>求解，所以最终导致<code>f(4)</code>结果错误。</p>
<p>分析发现，转换后的<code>f(n-k)</code>并不一定比<code>n-k</code>大。应改进状态方程，先得到原始的<code>n-k</code>和转换为<code>f(n-k)</code>中较大者，再乘<code>k</code>，改进后方程：<code>f(n) = max&#123;k * max[n-k, f(n-k)], k=1,2,...,n-1&#125;</code></p>
<p>正确代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] states;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * f(n) = max&#123;(n-k) * max[n-k,f(k)], k = 1,2,...,n-2,n-1&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        states = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> bp(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bp</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(states[n] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> states[n];</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bp = bp(n-i);</span><br><span class="line">            <span class="keyword">int</span> temp = i * (n-i &gt; bp ? n-i : bp);</span><br><span class="line">            <span class="keyword">if</span>(max &lt; temp)</span><br><span class="line">                max = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        states[n] = max;</span><br><span class="line">        <span class="keyword">return</span> states[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h1><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>
<h2 id="要点笔记"><a href="#要点笔记" class="headerlink" title="要点笔记"></a>要点笔记</h2><p>解题关键和难点在于<strong>状态方程</strong>，一旦理解到了最大正方形的找法，一切都迎刃而解了！可惜自己做的时候百思不得其解，哈哈。</p>
<p>状态方程见下<strong>labuladong</strong></p>
<p>还有需要注意的是，此题中的<strong>base case</strong>，为矩阵的首行和首列。</p>
<h2 id="labuladong-4"><a href="#labuladong-4" class="headerlink" title="labuladong"></a>labuladong</h2><p>关键是你要观察出一个全是 1 的正方形有什么特点，如何根据小的正方形推导出大的正方形（状态转移方程）</p>
<p>当<code>matrix[i][j]为1</code>，且它的左边、上边、左上边都存在正方形时，<code>matrix[i][j]</code>才能够作为一个更大的正方形的右下角：</p>
<p><img src="/./leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/221%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2.jpg" alt="img 221.最大正方形"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 类似「水桶效应」，最大边长取决于边长最短的那个正方形</span></span><br><span class="line">    dp[i][j] = min(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dp[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>题解代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 定义：以 matrix[i][j] 为右下角元素的全为 1 正方形矩阵的最大边长为 dp[i][j]。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base case，第一行和第一列的正方形边长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 值为 0 不可能是正方形的右下角</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(</span><br><span class="line">                    dp[i - <span class="number">1</span>][j],</span><br><span class="line">                    dp[i][j - <span class="number">1</span>]),</span><br><span class="line">                    dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                ) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                len = Math.max(len, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len * len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指-Offer-II-017-含有所有字符的最短字符（76-最小覆盖字串）"><a href="#剑指-Offer-II-017-含有所有字符的最短字符（76-最小覆盖字串）" class="headerlink" title="剑指 Offer II 017 含有所有字符的最短字符（76.最小覆盖字串）"></a>剑指 Offer II 017 含有所有字符的最短字符（76.最小覆盖字串）</h1><p>给定两个字符串 s 和 t 。返回 s 中包含 t 的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 “” 。</p>
<p>如果 s 中存在多个符合条件的子字符串，返回任意一个。</p>
<p>注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>示例 1：</p>
<p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>解释：最短子字符串 “BANC” 包含了字符串 t 的所有字符 ‘A’、’B’、’C’<br>示例 2：</p>
<p>输入：s = “a”, t = “a”<br>输出：”a”<br>示例 3：</p>
<p>输入：s = “a”, t = “aa”<br>输出：””<br>解释：t 中两个字符 ‘a’ 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。<br>提示：</p>
<ul>
<li>1 &lt;= s.length, t.length &lt;= 10^5</li>
<li>s 和 t 由英文字母组成</li>
</ul>
<h2 id="个人思路-8"><a href="#个人思路-8" class="headerlink" title="个人思路"></a>个人思路</h2><p>遇到求字串问题，优先考虑<strong>滑动窗口</strong>方法。</p>
<p>滑动窗口的关键在于<strong>缩小窗口的时机</strong>和<strong>如何缩小窗口</strong>，而且重点在于后者！！！</p>
<p>根据题目要求，所求字符串必须包含 t 的所有字符，且相应字符的数量必须不小于 t 中的数量。</p>
<p>缩小窗口：等到<strong>窗口合法</strong>后，left++。注意 left 右移后，窗口仍有可能合法，所以需要<strong>while循环</strong>判断窗口的合法性。</p>
<p>本方法的时间和空间复杂度都不是很好，可以看下面的改进方法。</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> il = <span class="number">0</span>, ir = s.length();    <span class="comment">//结果字符串索引</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                map.put(c, map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            window.put(c, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//窗口数据更新</span></span><br><span class="line">            <span class="keyword">if</span>(window.containsKey(r))&#123;</span><br><span class="line">                window.put(r, window.get(r)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//窗口左侧是否需要收缩</span></span><br><span class="line">            <span class="keyword">while</span> (isValidWindow(map, window))&#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; ir - il + <span class="number">1</span>) &#123;</span><br><span class="line">                    ir = right - <span class="number">1</span>;</span><br><span class="line">                    il = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">//窗口数据更新</span></span><br><span class="line">                <span class="keyword">if</span>(window.containsKey(l))&#123;</span><br><span class="line">                    window.put(l, window.get(l)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ir == s.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> s.substring(il, ir+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isValidWindow</span><span class="params">(HashMap&lt;Character, Integer&gt; map, HashMap&lt;Character, Integer&gt; window)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Character c : window.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(window.get(c) &lt; map.get(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><p>题解思路：利用双指针找到以下标right结尾，且含有t所有字符的最小长度区间[left,right]</p>
<p>定义两个数组 cnt1与cnt2，将字母转化成数字，并以此为下标，出现次数作为值存进数组中，当cnt2[n]&gt;=cnt1[n]，也就是cnt2中 n 所代表的字符出现次数，比cnt1中 n 所代表的字符出现次数多或相等，也就是含有。</p>
<p>改进方法真的非常巧妙！！！</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> m = t.length();</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//cnt1:t的参照数组</span></span><br><span class="line">        <span class="keyword">int</span>[] cnt1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="keyword">int</span>[] cnt2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="comment">//初始化cnt1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            cnt1[t.charAt(i)-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;   <span class="comment">//t中字符种类数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : cnt1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">                diff++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = s.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n)&#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            cnt2[r-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(cnt1[r-<span class="string">&#x27;A&#x27;</span>] == cnt2[r-<span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">                diff--;</span><br><span class="line">            <span class="comment">//窗口满足条件,尝试缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (diff == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min &gt; right-left)&#123;</span><br><span class="line">                    min = right-left;</span><br><span class="line">                    res = s.substring(left, right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//尝试缩小窗口</span></span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                cnt2[l-<span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                <span class="comment">//若移除字符 l 是否是 t 中的字符，且破环了窗口的合法性</span></span><br><span class="line">                <span class="keyword">if</span>(cnt1[l-<span class="string">&#x27;A&#x27;</span>] != <span class="number">0</span> &amp;&amp; cnt2[l-<span class="string">&#x27;A&#x27;</span>] &lt; cnt1[l-<span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">                    diff++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004.最大连续1的个数 III"></a>1004.最大连续1的个数 III</h1><p>给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。</p>
<p>示例 1：</p>
<p>输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2<br>输出：6<br>解释：[1,1,1,0,0,1,1,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 6。<br>示例 2：</p>
<p>输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3<br>输出：10<br>解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 10。</p>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 105</li>
<li>nums[i] 不是 0 就是 1</li>
<li>0 &lt;= k &lt;= nums.length</li>
<li>Related Topics</li>
<li><h2 id="个人思路-9"><a href="#个人思路-9" class="headerlink" title="个人思路"></a>个人思路</h2>这个题目很好体现了<strong>缩小窗口的时机</strong>也很重要，当然<strong>如何缩小窗口</strong>也很重要。<br>题目还有需要注意的是<strong>如何维护窗口</strong>，其他滑动窗口题目中<strong>维护窗口</strong>都很简单。</li>
</ul>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = nums[right];</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(r == <span class="number">1</span>)&#123;</span><br><span class="line">                max = Math.max(max, right-left);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//r == 0</span></span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//不能再翻转 r,缩小窗口，移动left到下一个 0 的后面位置</span></span><br><span class="line">                    <span class="comment">//这里条件不能写为 left &lt; right ,因为循环体里 left++ 是在后面！！！</span></span><br><span class="line">                    <span class="comment">// 因为 left = right-1时，还要进行 num[left] == 0的判断</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[left] == <span class="number">0</span>)&#123;</span><br><span class="line">                            k++;</span><br><span class="line">                            left++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前面将 left移动下一个 0 的后面的位置，k++。但是当前 r = 0，又消耗了一次 k，所以 k--</span></span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//翻转 r</span></span><br><span class="line">                    k--;</span><br><span class="line">                    max = Math.max(max, right-left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：leetcode刷题笔记</li>
        <li>本文作者：upbear</li>
        <li>创建时间：2022-11-04 11:32:03</li>
        <li>
            本文链接：https://up-bear.github.io/2022/11/04/leetcode-shua-ti-bi-ji/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2023/02/25/tu-shu-guan/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">图书馆</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/08/27/she-ji-mo-shi/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">设计模式</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'kWc8GocMTp4arF205KgVckzN-gzGzoHsz',
                    appKey: 'BdNz6qw6OQmWGoDSnTF3wbWF',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '尽情鞭挞我吧🤤',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'upbear';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>
              -
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">upbear</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E3%80%81%E6%9C%80%E5%A4%A7-%E5%B0%8F%E5%A0%86"><span class="nav-number">1.1.</span> <span class="nav-text">优先队列、最大&#x2F;小堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.1.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-number">1.2.</span> <span class="nav-text">单调队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.1.</span> <span class="nav-text">适用问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-number">1.3.</span> <span class="nav-text">线段树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">经典方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.1.</span> <span class="nav-text">DP动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E8%A7%A3%E9%A2%98%E7%9B%AE"><span class="nav-number">2.2.</span> <span class="nav-text">未解题目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">经典问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RMQ%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">RMQ区间最值问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-2"><span class="nav-number">3.1.1.</span> <span class="nav-text">参考链接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1668-%E6%9C%80%E5%A4%A7%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">1668.最大重复子字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E7%AE%80%E5%8D%95%E6%9E%9A%E4%B8%BE-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">4.1.</span> <span class="nav-text">方法1：简单枚举+动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%91%E6%8C%87Offer-047-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D"><span class="nav-number">5.</span> <span class="nav-text">剑指Offer || 047.二叉树剪枝</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF"><span class="nav-number">5.1.</span> <span class="nav-text">个人思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">5.1.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E5%AE%8C%E5%96%84"><span class="nav-number">5.1.2.</span> <span class="nav-text">改进完善</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E9%80%92%E5%BD%92"><span class="nav-number">5.2.</span> <span class="nav-text">方法1：递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E5%AF%B9%E6%AF%94"><span class="nav-number">5.3.</span> <span class="nav-text">思路对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#795-%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">795.区间子数组个数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%B1%E8%B4%A5%E6%80%9D%E8%B7%AF"><span class="nav-number">6.1.</span> <span class="nav-text">失败思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">6.2.</span> <span class="nav-text">方法1：一次遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%80%83"><span class="nav-number">6.2.1.</span> <span class="nav-text">题解思考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">7.</span> <span class="nav-text">7.整数反转</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF-1"><span class="nav-number">7.1.</span> <span class="nav-text">个人思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">7.1.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="nav-number">7.1.2.</span> <span class="nav-text">不足之处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">7.1.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%91%E6%8C%87Offer-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">8.</span> <span class="nav-text">剑指Offer 55 - II.平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF-2"><span class="nav-number">8.1.</span> <span class="nav-text">个人思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">8.1.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-number">8.1.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%91%E6%8C%87Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.</span> <span class="nav-text">剑指Offer 07.重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF-3"><span class="nav-number">9.1.</span> <span class="nav-text">个人思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">9.1.1.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1110-%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97"><span class="nav-number">10.</span> <span class="nav-text">1110.删点成林</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF-4"><span class="nav-number">10.1.</span> <span class="nav-text">个人思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="nav-number">10.1.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84-1"><span class="nav-number">10.1.2.</span> <span class="nav-text">不足之处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#labuladong"><span class="nav-number">10.2.</span> <span class="nav-text">labuladong</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="nav-number">10.2.1.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="nav-number">11.</span> <span class="nav-text">116.填充每个节点的下一个右侧节点指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF-5"><span class="nav-number">11.1.</span> <span class="nav-text">个人思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="nav-number">11.1.1.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#labuladong-1"><span class="nav-number">11.2.</span> <span class="nav-text">labuladong</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">12.</span> <span class="nav-text">114.二叉树展开为链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF-6"><span class="nav-number">12.1.</span> <span class="nav-text">个人思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="nav-number">12.1.1.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#labuladong-2"><span class="nav-number">12.2.</span> <span class="nav-text">labuladong</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83"><span class="nav-number">12.3.</span> <span class="nav-text">拓展思考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1372-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%A4%E9%94%99%E8%B7%AF%E5%BE%84"><span class="nav-number">13.</span> <span class="nav-text">1372.二叉树中的最长交错路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF-7"><span class="nav-number">13.1.</span> <span class="nav-text">个人思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="nav-number">13.1.1.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-VI"><span class="nav-number">14.</span> <span class="nav-text">1696.跳跃游戏 VI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF"><span class="nav-number">14.1.</span> <span class="nav-text">错误思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0"><span class="nav-number">14.2.</span> <span class="nav-text">错误原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E6%80%9D"><span class="nav-number">14.3.</span> <span class="nav-text">反思</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#labuladong-3"><span class="nav-number">14.4.</span> <span class="nav-text">labuladong</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="nav-number">15.</span> <span class="nav-text">343.整数拆分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E5%88%9D%E8%AF%95"><span class="nav-number">15.1.</span> <span class="nav-text">思路初试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E6%94%B9%E8%BF%9B"><span class="nav-number">15.2.</span> <span class="nav-text">思路改进</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">16.</span> <span class="nav-text">221.最大正方形</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0"><span class="nav-number">16.1.</span> <span class="nav-text">要点笔记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#labuladong-4"><span class="nav-number">16.2.</span> <span class="nav-text">labuladong</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-II-017-%E5%90%AB%E6%9C%89%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%97%E7%AC%A6%EF%BC%8876-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2%EF%BC%89"><span class="nav-number">17.</span> <span class="nav-text">剑指 Offer II 017 含有所有字符的最短字符（76.最小覆盖字串）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF-8"><span class="nav-number">17.1.</span> <span class="nav-text">个人思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="nav-number">17.1.1.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95"><span class="nav-number">17.2.</span> <span class="nav-text">改进方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="nav-number">17.2.1.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0-III"><span class="nav-number">18.</span> <span class="nav-text">1004.最大连续1的个数 III</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF-9"><span class="nav-number">18.1.</span> <span class="nav-text">个人思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="nav-number">18.1.1.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>




<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
